{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014-2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar common_1 = require(\"@google-cloud/common\");\n\nvar paginator_1 = require(\"@google-cloud/paginator\");\n\nvar promisify_1 = require(\"@google-cloud/promisify\");\n\nvar arrify = require(\"arrify\");\n\nvar async = require(\"async\");\n\nvar extend = require(\"extend\");\n\nvar fs = require(\"fs\");\n\nvar mime = require(\"mime-types\");\n\nvar path = require(\"path\");\n\nvar snakeize = require('snakeize');\n\nvar acl_1 = require(\"./acl\");\n\nvar file_1 = require(\"./file\");\n\nvar iam_1 = require(\"./iam\");\n\nvar notification_1 = require(\"./notification\");\n/**\n * The size of a file (in bytes) must be greater than this number to\n * automatically trigger a resumable upload.\n *\n * @const {number}\n * @private\n */\n\n\nvar RESUMABLE_THRESHOLD = 5000000;\n/**\n * Create a Bucket object to interact with a Cloud Storage bucket.\n *\n * @class\n * @hideconstructor\n *\n * @param {Storage} storage A {@link Storage} instance.\n * @param {string} name The name of the bucket.\n * @param {object} [options] Configuration object.\n * @param {string} [options.userProject] User project.\n *\n * @example\n * const {Storage} = require('@google-cloud/storage');\n * const storage = new Storage();\n * const bucket = storage.bucket('albums');\n */\n\nvar Bucket =\n/*#__PURE__*/\nfunction (_common_1$ServiceObje) {\n  _inherits(Bucket, _common_1$ServiceObje);\n\n  function Bucket(storage, name, options) {\n    var _this;\n\n    _classCallCheck(this, Bucket);\n\n    options = options || {}; // Allow for \"gs://\"-style input, and strip any trailing slashes.\n\n    name = name.replace(/^gs:\\/\\//, '').replace(/\\/+$/, '');\n    var requestQueryObject = {};\n    var userProject = options.userProject;\n\n    if (typeof userProject === 'string') {\n      requestQueryObject.userProject = userProject;\n    }\n\n    var methods = {\n      /**\n       * Create a bucket.\n       *\n       * @method Bucket#create\n       * @param {CreateBucketRequest} [metadata] Metadata to set for the bucket.\n       * @param {CreateBucketCallback} [callback] Callback function.\n       * @returns {Promise<CreateBucketResponse>}\n       *\n       * @example\n       * const {Storage} = require('@google-cloud/storage');\n       * const storage = new Storage();\n       * const bucket = storage.bucket('albums');\n       * bucket.create(function(err, bucket, apiResponse) {\n       *   if (!err) {\n       *     // The bucket was created successfully.\n       *   }\n       * });\n       *\n       * //-\n       * // If the callback is omitted, we'll return a Promise.\n       * //-\n       * bucket.create().then(function(data) {\n       *   const bucket = data[0];\n       *   const apiResponse = data[1];\n       * });\n       */\n      create: {\n        reqOpts: {\n          qs: requestQueryObject\n        }\n      },\n\n      /**\n       * @typedef {object} DeleteBucketOptions Configuration options.\n       * @param {string} [userProject] The ID of the project which will be\n       *     billed for the request.\n       */\n\n      /**\n       * @typedef {array} DeleteBucketResponse\n       * @property {object} 0 The full API response.\n       */\n\n      /**\n       * @callback DeleteBucketCallback\n       * @param {?Error} err Request error, if any.\n       * @param {object} apiResponse The full API response.\n       */\n\n      /**\n       * Delete the bucket.\n       *\n       * @see [Buckets: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/delete}\n       *\n       * @method Bucket#delete\n       * @param {DeleteBucketOptions} [options] Configuration options.\n       * @param {DeleteBucketCallback} [callback] Callback function.\n       * @returns {Promise<DeleteBucketResponse>}\n       *\n       * @example\n       * const {Storage} = require('@google-cloud/storage');\n       * const storage = new Storage();\n       * const bucket = storage.bucket('albums');\n       * bucket.delete(function(err, apiResponse) {});\n       *\n       * //-\n       * // If the callback is omitted, we'll return a Promise.\n       * //-\n       * bucket.delete().then(function(data) {\n       *   const apiResponse = data[0];\n       * });\n       *\n       * @example <caption>include:samples/buckets.js</caption>\n       * region_tag:storage_delete_bucket\n       * Another example:\n       */\n      delete: {\n        reqOpts: {\n          qs: requestQueryObject\n        }\n      },\n\n      /**\n       * @typedef {object} BucketExistsOptions Configuration options for Bucket#exists().\n       * @param {string} [userProject] The ID of the project which will be\n       *     billed for the request.\n       */\n\n      /**\n       * @typedef {array} BucketExistsResponse\n       * @property {boolean} 0 Whether the {@link Bucket} exists.\n       */\n\n      /**\n       * @callback BucketExistsCallback\n       * @param {?Error} err Request error, if any.\n       * @param {boolean} exists Whether the {@link Bucket} exists.\n       */\n\n      /**\n       * Check if the bucket exists.\n       *\n       * @method Bucket#exists\n       * @param {BucketExistsOptions} [options] Configuration options.\n       * @param {BucketExistsCallback} [callback] Callback function.\n       * @returns {Promise<BucketExistsResponse>}\n       *\n       * @example\n       * const {Storage} = require('@google-cloud/storage');\n       * const storage = new Storage();\n       * const bucket = storage.bucket('albums');\n       *\n       * bucket.exists(function(err, exists) {});\n       *\n       * //-\n       * // If the callback is omitted, we'll return a Promise.\n       * //-\n       * bucket.exists().then(function(data) {\n       *   const exists = data[0];\n       * });\n       */\n      exists: {\n        reqOpts: {\n          qs: requestQueryObject\n        }\n      },\n\n      /**\n       * @typedef {object} [GetBucketOptions] Configuration options for Bucket#get()\n       * @property {boolean} [autoCreate] Automatically create the object if\n       *     it does not exist. Default: `false`\n       * @property {string} [userProject] The ID of the project which will be\n       *     billed for the request.\n       */\n\n      /**\n       * @typedef {array} GetBucketResponse\n       * @property {Bucket} 0 The {@link Bucket}.\n       * @property {object} 1 The full API response.\n       */\n\n      /**\n       * @callback GetBucketCallback\n       * @param {?Error} err Request error, if any.\n       * @param {Bucket} bucket The {@link Bucket}.\n       * @param {object} apiResponse The full API response.\n       */\n\n      /**\n       * Get a bucket if it exists.\n       *\n       * You may optionally use this to \"get or create\" an object by providing\n       * an object with `autoCreate` set to `true`. Any extra configuration that\n       * is normally required for the `create` method must be contained within\n       * this object as well.\n       *\n       * @method Bucket#get\n       * @param {GetBucketOptions} [options] Configuration options.\n       * @param {GetBucketCallback} [callback] Callback function.\n       * @returns {Promise<GetBucketResponse>}\n       *\n       * @example\n       * const {Storage} = require('@google-cloud/storage');\n       * const storage = new Storage();\n       * const bucket = storage.bucket('albums');\n       *\n       * bucket.get(function(err, bucket, apiResponse) {\n       *   // `bucket.metadata` has been populated.\n       * });\n       *\n       * //-\n       * // If the callback is omitted, we'll return a Promise.\n       * //-\n       * bucket.get().then(function(data) {\n       *   const bucket = data[0];\n       *   const apiResponse = data[1];\n       * });\n       */\n      get: {\n        reqOpts: {\n          qs: requestQueryObject\n        }\n      },\n\n      /**\n       * @typedef {array} GetBucketMetadataResponse\n       * @property {object} 0 The bucket metadata.\n       * @property {object} 1 The full API response.\n       */\n\n      /**\n       * @callback GetBucketMetadataCallback\n       * @param {?Error} err Request error, if any.\n       * @param {object} metadata The bucket metadata.\n       * @param {object} apiResponse The full API response.\n       */\n\n      /**\n       * @typedef {object} GetBucketMetadataOptions Configuration options for Bucket#getMetadata().\n       * @property {string} [userProject] The ID of the project which will be\n       *     billed for the request.\n       */\n\n      /**\n       * Get the bucket's metadata.\n       *\n       * To set metadata, see {@link Bucket#setMetadata}.\n       *\n       * @see [Buckets: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/get}\n       *\n       * @method Bucket#getMetadata\n       * @param {GetBucketMetadataOptions} [options] Configuration options.\n       * @param {GetBucketMetadataCallback} [callback] Callback function.\n       * @returns {Promise<GetBucketMetadataResponse>}\n       *\n       * @example\n       * const {Storage} = require('@google-cloud/storage');\n       * const storage = new Storage();\n       * const bucket = storage.bucket('albums');\n       *\n       * bucket.getMetadata(function(err, metadata, apiResponse) {});\n       *\n       * //-\n       * // If the callback is omitted, we'll return a Promise.\n       * //-\n       * bucket.getMetadata().then(function(data) {\n       *   const metadata = data[0];\n       *   const apiResponse = data[1];\n       * });\n       *\n       * @example <caption>include:samples/requesterPays.js</caption>\n       * region_tag:storage_get_requester_pays_status\n       * Example of retrieving the requester pays status of a bucket:\n       */\n      getMetadata: {\n        reqOpts: {\n          qs: requestQueryObject\n        }\n      },\n\n      /**\n       * @typedef {object} SetBucketMetadataOptions Configuration options for Bucket#setMetadata().\n       * @property {string} [userProject] The ID of the project which will be\n       *     billed for the request.\n       */\n\n      /**\n       * @typedef {array} SetBucketMetadataResponse\n       * @property {object} apiResponse The full API response.\n       */\n\n      /**\n       * @callback SetBucketMetadataCallback\n       * @param {?Error} err Request error, if any.\n       * @param {object} metadata The bucket metadata.\n       */\n\n      /**\n       * Set the bucket's metadata.\n       *\n       * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n       *\n       * @method Bucket#setMetadata\n       * @param {object<string, *>} metadata The metadata you wish to set.\n       * @param {SetBucketMetadataOptions} [options] Configuration options.\n       * @param {SetBucketMetadataCallback} [callback] Callback function.\n       * @returns {Promise<SetBucketMetadataResponse>}\n       *\n       * @example\n       * const {Storage} = require('@google-cloud/storage');\n       * const storage = new Storage();\n       * const bucket = storage.bucket('albums');\n       *\n       * //-\n       * // Set website metadata field on the bucket.\n       * //-\n       * const metadata = {\n       *   website: {\n       *     mainPageSuffix: 'http://example.com',\n       *     notFoundPage: 'http://example.com/404.html'\n       *   }\n       * };\n       *\n       * bucket.setMetadata(metadata, function(err, apiResponse) {});\n       *\n       * //-\n       * // Enable versioning for your bucket.\n       * //-\n       * bucket.setMetadata({\n       *   versioning: {\n       *     enabled: true\n       *   }\n       * }, function(err, apiResponse) {});\n       *\n       * //-\n       * // Enable KMS encryption for objects within this bucket.\n       * //-\n       * bucket.setMetadata({\n       *   encryption: {\n       *     defaultKmsKeyName: 'projects/grape-spaceship-123/...'\n       *   }\n       * }, function(err, apiResponse) {});\n       *\n       * //-\n       * // Set the default event-based hold value for new objects in this\n       * // bucket.\n       * //-\n       * bucket.setMetadata({\n       *   defaultEventBasedHold: true\n       * }, function(err, apiResponse) {});\n       *\n       * //-\n       * // Remove object lifecycle rules.\n       * //-\n       * bucket.setMetadata({\n       *   lifecycle: null\n       * }, function(err, apiResponse) {});\n       *\n       * //-\n       * // If the callback is omitted, we'll return a Promise.\n       * //-\n       * bucket.setMetadata(metadata).then(function(data) {\n       *   const apiResponse = data[0];\n       * });\n       */\n      setMetadata: {\n        reqOpts: {\n          qs: requestQueryObject\n        }\n      }\n    };\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Bucket).call(this, {\n      parent: storage,\n      baseUrl: '/b',\n      id: name,\n      createMethod: storage.createBucket.bind(storage),\n      methods: methods\n    }));\n    _this.name = name;\n    _this.storage = storage;\n    _this.userProject = options.userProject;\n    _this.acl = new acl_1.Acl({\n      request: _this.request.bind(_assertThisInitialized(_assertThisInitialized(_this))),\n      pathPrefix: '/acl'\n    });\n    _this.acl.default = new acl_1.Acl({\n      request: _this.request.bind(_assertThisInitialized(_assertThisInitialized(_this))),\n      pathPrefix: '/defaultObjectAcl'\n    });\n    _this.iam = new iam_1.Iam(_assertThisInitialized(_assertThisInitialized(_this)));\n    _this.getFilesStream = paginator_1.paginator.streamify('getFiles');\n    return _this;\n  }\n  /**\n   * @typedef {object} AddLifecycleRuleOptions Configuration options for Bucket#addLifecycleRule().\n   * @property {string} [append=true] The new rules will be appended to any\n   *     pre-existing rules.\n   */\n\n  /**\n   * Add an object lifecycle management rule to the bucket.\n   *\n   * By default, an Object Lifecycle Management rule provided to this method\n   * will be included to the existing policy. To replace all existing rules,\n   * supply the `options` argument, setting `append` to `false`.\n   *\n   * @see [Object Lifecycle Management]{@link https://cloud.google.com/storage/docs/lifecycle}\n   * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n   *\n   * @param {LifecycleRule} rule The new lifecycle rule to be added to objects\n   *     in this bucket.\n   * @param {string} [rule.storageClass] When using the `setStorageClass`\n   *     action, provide this option to dictate which storage class the object\n   *     should update to.\n   * @param {AddLifecycleRuleOptions} [options] Configuration object.\n   * @param {boolean} [options.append=true] Append the new rule to the existing\n   *     policy.\n   * @param {SetBucketMetadataCallback} [callback] Callback function.\n   * @returns {Promise<SetBucketMetadataResponse>}\n   *\n   * @example\n   * const {Storage} = require('@google-cloud/storage');\n   * const storage = new Storage();\n   * const bucket = storage.bucket('albums');\n   *\n   * //-\n   * // Automatically have an object deleted from this bucket once it is 3 years\n   * // of age.\n   * //-\n   * bucket.addLifecycleRule({\n   *   action: 'delete',\n   *   condition: {\n   *     age: 365 * 3 // Specified in days.\n   *   }\n   * }, function(err, apiResponse) {\n   *   if (err) {\n   *     // Error handling omitted.\n   *   }\n   *\n   *   const lifecycleRules = bucket.metadata.lifecycle.rule;\n   *\n   *   // Iterate over the Object Lifecycle Management rules on this bucket.\n   *   lifecycleRules.forEach(lifecycleRule => {});\n   * });\n   *\n   * //-\n   * // By default, the rule you provide will be added to the existing policy.\n   * // Optionally, you can disable this behavior to replace all of the\n   * // pre-existing rules.\n   * //-\n   * const options = {\n   *   append: false\n   * };\n   *\n   * bucket.addLifecycleRule({\n   *   action: 'delete',\n   *   condition: {\n   *     age: 365 * 3 // Specified in days.\n   *   }\n   * }, options, function(err, apiResponse) {\n   *   if (err) {\n   *     // Error handling omitted.\n   *   }\n   *\n   *   // All rules have been replaced with the new \"delete\" rule.\n   *\n   *   // Iterate over the Object Lifecycle Management rules on this bucket.\n   *   lifecycleRules.forEach(lifecycleRule => {});\n   * });\n   *\n   * //-\n   * // For objects created before 2018, \"downgrade\" the storage class.\n   * //-\n   * bucket.addLifecycleRule({\n   *   action: 'setStorageClass',\n   *   storageClass: 'COLDLINE',\n   *   condition: {\n   *     createdBefore: new Date('2018')\n   *   }\n   * }, function(err, apiResponse) {});\n   *\n   * //-\n   * // Delete objects created before 2016 which have the Coldline storage\n   * // class.\n   * //-\n   * bucket.addLifecycleRule({\n   *   action: 'delete',\n   *   condition: {\n   *     matchesStorageClass: [\n   *       'COLDLINE'\n   *     ],\n   *     createdBefore: new Date('2016')\n   *   }\n   * }, function(err, apiResponse) {});\n   */\n\n\n  _createClass(Bucket, [{\n    key: \"addLifecycleRule\",\n    value: function addLifecycleRule(rule, optionsOrCallback, callback) {\n      var _this2 = this;\n\n      var options;\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else if (optionsOrCallback) {\n        options = optionsOrCallback;\n      }\n\n      options = options || {};\n      callback = callback || common_1.util.noop;\n      var newLifecycleRules = arrify(rule).map(function (rule) {\n        if (typeof rule.action === 'object') {\n          // This is a raw-formatted rule object, the way the API expects.\n          // Just pass it through as-is.\n          return rule;\n        }\n\n        var apiFormattedRule = {};\n        apiFormattedRule.condition = {};\n        apiFormattedRule.action = {\n          type: rule.action\n        }; // @TODO: Remove if the API becomes less picky.\n\n        if (rule.action === 'delete') {\n          apiFormattedRule.action.type = 'Delete';\n        }\n\n        if (rule.storageClass) {\n          apiFormattedRule.action.storageClass = rule.storageClass;\n        }\n\n        for (var condition in rule.condition) {\n          if (rule.condition[condition] instanceof Date) {\n            apiFormattedRule.condition[condition] = rule.condition[condition].toISOString().replace(/T.+$/, '');\n          } else {\n            apiFormattedRule.condition[condition] = rule.condition[condition];\n          }\n        }\n\n        return apiFormattedRule;\n      });\n\n      if (options.append === false) {\n        this.setMetadata({\n          lifecycle: {\n            rule: newLifecycleRules\n          }\n        }, callback);\n        return;\n      } // The default behavior appends the previously-defined lifecycle rules with\n      // the new ones just passed in by the user.\n\n\n      this.getMetadata(function (err, metadata) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        var currentLifecycleRules = arrify(metadata.lifecycle && metadata.lifecycle.rule);\n\n        _this2.setMetadata({\n          lifecycle: {\n            rule: currentLifecycleRules.concat(newLifecycleRules)\n          }\n        }, callback);\n      });\n    }\n    /**\n     * @typedef {object} CombineOptions\n     * @property {string} [kmsKeyName] Resource name of the Cloud KMS key, of\n     *     the form\n     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`,\n     *     that will be used to encrypt the object. Overwrites the object\n     * metadata's `kms_key_name` value, if any.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * @callback CombineCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File} newFile The new {@link File}.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * @typedef {array} CombineResponse\n     * @property {File} 0 The new {@link File}.\n     * @property {object} 1 The full API response.\n     */\n\n    /**\n     * Combine multiple files into one new file.\n     *\n     * @see [Objects: compose API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/compose}\n     *\n     * @throws {Error} if a non-array is provided as sources argument.\n     * @throws {Error} if less than two sources are provided.\n     * @throws {Error} if no destination is provided.\n     *\n     * @param {string[]|File[]} sources The source files that will be\n     *     combined.\n     * @param {string|File} destination The file you would like the\n     *     source files combined into.\n     * @param {CombineOptions} [options] Configuration options.\n     * @param {CombineCallback} [callback] Callback function.\n     * @returns {Promise<CombineResponse>}\n     *\n     * @example\n     * const logBucket = storage.bucket('log-bucket');\n     *\n     * const sources = [\n     *   logBucket.file('2013-logs.txt'),\n     *   logBucket.file('2014-logs.txt')\n     * ];\n     *\n     * const allLogs = logBucket.file('all-logs.txt');\n     *\n     * logBucket.combine(sources, allLogs, function(err, newFile, apiResponse) {\n     *   // newFile === allLogs\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * logBucket.combine(sources, allLogs).then(function(data) {\n     *   const newFile = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n\n  }, {\n    key: \"combine\",\n    value: function combine(sources, destination, optionsOrCallback, callback) {\n      var _this3 = this;\n\n      if (!Array.isArray(sources) || sources.length < 2) {\n        throw new Error('You must provide at least two source files.');\n      }\n\n      if (!destination) {\n        throw new Error('A destination file must be specified.');\n      }\n\n      var options = {};\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else if (optionsOrCallback) {\n        options = optionsOrCallback;\n      }\n\n      var convertToFile = function convertToFile(file) {\n        if (file instanceof file_1.File) {\n          return file;\n        }\n\n        return _this3.file(file);\n      }; // tslint:disable-next-line:no-any\n\n\n      sources = sources.map(convertToFile);\n      var destinationFile = convertToFile(destination);\n      callback = callback || common_1.util.noop;\n\n      if (!destinationFile.metadata.contentType) {\n        var destinationContentType = mime.contentType(destinationFile.name);\n\n        if (destinationContentType) {\n          destinationFile.metadata.contentType = destinationContentType;\n        }\n      } // Make the request from the destination File object.\n\n\n      destinationFile.request({\n        method: 'POST',\n        uri: '/compose',\n        json: {\n          destination: {\n            contentType: destinationFile.metadata.contentType\n          },\n          sourceObjects: sources.map(function (source) {\n            var sourceObject = {\n              name: source.name\n            };\n\n            if (source.metadata && source.metadata.generation) {\n              sourceObject.generation = source.metadata.generation;\n            }\n\n            return sourceObject;\n          })\n        },\n        qs: options\n      }, function (err, resp) {\n        if (err) {\n          callback(err, null, resp);\n          return;\n        }\n\n        callback(null, destinationFile, resp);\n      });\n    }\n    /**\n     * See a [Objects:\n     * watchAll request\n     * body](https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll).\n     *\n     * @typedef {object} CreateChannelConfig\n     * @property {string} address The address where notifications are\n     *     delivered for this channel.\n     * @extends WatchAllOptions\n     */\n\n    /**\n     * @typedef {object} CreateChannelOptions\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * @typedef {array} CreateChannelResponse\n     * @property {Channel} 0 The new {@link Channel}.\n     * @property {object} 1 The full API response.\n     */\n\n    /**\n     * @callback CreateChannelCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Channel} channel The new {@link Channel}.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * Create a channel that will be notified when objects in this bucket changes.\n     *\n     * @throws {Error} If an ID is not provided.\n     * @throws {Error} If an address is not provided.\n     *\n     * @see [Objects: watchAll API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll}\n     *\n     * @param {string} id The ID of the channel to create.\n     * @param {CreateChannelConfig} config Configuration for creating channel.\n     * @param {CreateChannelOptions} [options] Configuration options.\n     * @param {CreateChannelCallback} [callback] Callback function.\n     * @returns {Promise<CreateChannelResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     * const id = 'new-channel-id';\n     *\n     * const config = {\n     *   address: 'https://...'\n     * };\n     *\n     * bucket.createChannel(id, config, function(err, channel, apiResponse) {\n     *   if (!err) {\n     *     // Channel created successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.createChannel(id, config).then(function(data) {\n     *   const channel = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n\n  }, {\n    key: \"createChannel\",\n    value: function createChannel(id, config, optionsOrCallback, callback) {\n      var _this4 = this;\n\n      if (typeof id !== 'string') {\n        throw new Error('An ID is required to create a channel.');\n      }\n\n      if (typeof config.address !== 'string') {\n        throw new Error('An address is required to create a channel.');\n      }\n\n      var options = {};\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else if (optionsOrCallback) {\n        options = optionsOrCallback;\n      }\n\n      this.request({\n        method: 'POST',\n        uri: '/o/watch',\n        json: Object.assign({\n          id: id,\n          type: 'web_hook'\n        }, config),\n        qs: options\n      }, function (err, apiResponse) {\n        if (err) {\n          callback(err, null, apiResponse);\n          return;\n        }\n\n        var resourceId = apiResponse.resourceId;\n\n        var channel = _this4.storage.channel(id, resourceId);\n\n        channel.metadata = apiResponse;\n        callback(null, channel, apiResponse);\n      });\n    }\n    /**\n     * Metadata to set for the Notification.\n     *\n     * @typedef {object} CreateNotificationOptions\n     * @property {object} [customAttributes] An optional list of additional\n     *     attributes to attach to each Cloud PubSub message published for this\n     *     notification subscription.\n     * @property {string[]} [eventTypes] If present, only send notifications about\n     *     listed event types. If empty, sent notifications for all event types.\n     * @property {string} [objectNamePrefix] If present, only apply this\n     *     notification configuration to object names that begin with this prefix.\n     * @property {string} [payloadFormat] The desired content of the Payload.\n     *     Defaults to `JSON_API_V1`.\n     *\n     *     Acceptable values are:\n     *     - `JSON_API_V1`\n     *\n     *     - `NONE`\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * @callback CreateNotificationCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Notification} notification The new {@link Notification}.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * @typedef {array} CreateNotificationResponse\n     * @property {Notification} 0 The new {@link Notification}.\n     * @property {object} 1 The full API response.\n     */\n\n    /**\n     * Creates a notification subscription for the bucket.\n     *\n     * @see [Notifications: insert]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/insert}\n     *\n     * @param {Topic|string} topic The Cloud PubSub topic to which this\n     *     subscription publishes. If the project ID is omitted, the current\n     * project ID will be used.\n     *\n     *     Acceptable formats are:\n     *     - `projects/grape-spaceship-123/topics/my-topic`\n     *\n     *     - `my-topic`\n     * @param {CreateNotificationOptions} [options] Metadata to set for the\n     *     notification.\n     * @param {CreateNotificationCallback} [callback] Callback function.\n     * @returns {Promise<CreateNotificationResponse>}\n     * @throws {Error} If a valid topic is not provided.\n     * @see Notification#create\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const myBucket = storage.bucket('my-bucket');\n     *\n     * const callback = function(err, notification, apiResponse) {\n     *   if (!err) {\n     *     // The notification was created successfully.\n     *   }\n     * };\n     *\n     * myBucket.createNotification('my-topic', callback);\n     *\n     * //-\n     * // Configure the nofiication by providing Notification metadata.\n     * //-\n     * const metadata = {\n     *   objectNamePrefix: 'prefix-'\n     * };\n     *\n     * myBucket.createNotification('my-topic', metadata, callback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * myBucket.createNotification('my-topic').then(function(data) {\n     *   const notification = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/notifications.js</caption>\n     * region_tag:storage_create_notification\n     * Another example:\n     */\n\n  }, {\n    key: \"createNotification\",\n    value: function createNotification(topic, optionsOrCallback, callback) {\n      var _this5 = this;\n\n      var options = {};\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else if (optionsOrCallback) {\n        options = optionsOrCallback;\n      }\n\n      var topicIsObject = topic !== null && typeof topic === 'object';\n\n      if (topicIsObject && common_1.util.isCustomType(topic, 'pubsub/topic')) {\n        // tslint:disable-next-line:no-any\n        topic = topic.name;\n      }\n\n      if (typeof topic !== 'string') {\n        throw new Error('A valid topic name is required.');\n      }\n\n      var body = Object.assign({\n        topic: topic\n      }, options);\n\n      if (body.topic.indexOf('projects') !== 0) {\n        body.topic = 'projects/{{projectId}}/topics/' + body.topic;\n      }\n\n      body.topic = '//pubsub.googleapis.com/' + body.topic;\n\n      if (!body.payloadFormat) {\n        body.payloadFormat = 'JSON_API_V1';\n      }\n\n      var query = {};\n\n      if (body.userProject) {\n        query.userProject = body.userProject;\n        delete body.userProject;\n      }\n\n      this.request({\n        method: 'POST',\n        uri: '/notificationConfigs',\n        json: snakeize(body),\n        qs: query\n      }, function (err, apiResponse) {\n        if (err) {\n          callback(err, null, apiResponse);\n          return;\n        }\n\n        var notification = _this5.notification(apiResponse.id);\n\n        notification.metadata = apiResponse;\n        callback(null, notification, apiResponse);\n      });\n    }\n    /**\n     * @typedef {object} DeleteFilesOptions Query object. See {@link Bucket#getFiles}\n     *     for all of the supported properties.\n     * @property {boolean} [force] Suppress errors until all files have been\n     *     processed.\n     */\n\n    /**\n     * @callback DeleteFilesCallback\n     * @param {?Error|?Error[]} err Request error, if any, or array of errors from\n     *     files that were not able to be deleted.\n     * @param {object} [apiResponse] The full API response.\n     */\n\n    /**\n     * Iterate over the bucket's files, calling `file.delete()` on each.\n     *\n     * <strong>This is not an atomic request.</strong> A delete attempt will be\n     * made for each file individually. Any one can fail, in which case only a\n     * portion of the files you intended to be deleted would have.\n     *\n     * Operations are performed in parallel, up to 10 at once. The first error\n     * breaks the loop and will execute the provided callback with it. Specify\n     * `{ force: true }` to suppress the errors until all files have had a chance\n     * to be processed.\n     *\n     * The `query` object passed as the first argument will also be passed to\n     * {@link Bucket#getFiles}.\n     *\n     * @see [Objects: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete}\n     *\n     * @param {DeleteFilesOptions} [query] Query object. See {@link Bucket#getFiles}\n     * @param {DeleteFilesCallback} [callback] Callback function.\n     * @returns {Promise}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Delete all of the files in the bucket.\n     * //-\n     * bucket.deleteFiles(function(err) {});\n     *\n     * //-\n     * // By default, if a file cannot be deleted, this method will stop deleting\n     * // files from your bucket. You can override this setting with `force:\n     * // true`.\n     * //-\n     * bucket.deleteFiles({\n     *   force: true\n     * }, function(errors) {\n     *   // `errors`:\n     *   //    Array of errors if any occurred, otherwise null.\n     * });\n     *\n     * //-\n     * // The first argument to this method acts as a query to\n     * // {@link Bucket#getFiles}. As an example, you can delete files\n     * // which match a prefix.\n     * //-\n     * bucket.deleteFiles({\n     *   prefix: 'images/'\n     * }, function(err) {\n     *   if (!err) {\n     *     // All files in the `images` directory have been deleted.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.deleteFiles().then(function() {});\n     */\n\n  }, {\n    key: \"deleteFiles\",\n    value: function deleteFiles(queryOrCallback, callback) {\n      var query = {};\n\n      if (typeof queryOrCallback === 'function') {\n        callback = queryOrCallback;\n      } else if (queryOrCallback) {\n        query = queryOrCallback;\n      }\n\n      var MAX_PARALLEL_LIMIT = 10;\n      var errors = [];\n      this.getFiles(query, function (err, files) {\n        if (err) {\n          callback(err, {});\n          return;\n        }\n\n        var deleteFile = function deleteFile(file, callback) {\n          file.delete(query, function (err) {\n            if (err) {\n              if (query.force) {\n                errors.push(err);\n                callback();\n                return;\n              }\n\n              callback(err);\n              return;\n            }\n\n            callback(null);\n          });\n        }; // Iterate through each file and attempt to delete it.\n\n\n        async.eachLimit(files, MAX_PARALLEL_LIMIT, deleteFile, function (err) {\n          if (err || errors.length > 0) {\n            callback(err || errors);\n            return;\n          }\n\n          callback(null);\n        });\n      });\n    }\n    /**\n     * @typedef {array} DeleteLabelsResponse\n     * @property {object} 0 The full API response.\n     */\n\n    /**\n     * @callback DeleteLabelsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} metadata Bucket's metadata.\n     */\n\n    /**\n     * Delete one or more labels from this bucket.\n     *\n     * @param {string|string[]} labels The labels to delete. If no labels are\n     *     provided, all of the labels are removed.\n     * @param {DeleteLabelsCallback} [callback] Callback function.\n     * @returns {Promise<DeleteLabelsResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Delete all of the labels from this bucket.\n     * //-\n     * bucket.deleteLabels(function(err, apiResponse) {});\n     *\n     * //-\n     * // Delete a single label.\n     * //-\n     * bucket.deleteLabels('labelone', function(err, apiResponse) {});\n     *\n     * //-\n     * // Delete a specific set of labels.\n     * //-\n     * bucket.deleteLabels([\n     *   'labelone',\n     *   'labeltwo'\n     * ], function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.deleteLabels().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n\n  }, {\n    key: \"deleteLabels\",\n    value: function deleteLabels(labelsOrCallback, callback) {\n      var _this6 = this;\n\n      var labels = new Array();\n\n      if (typeof labelsOrCallback === 'function') {\n        callback = labelsOrCallback;\n      } else if (labelsOrCallback) {\n        labels = arrify(labelsOrCallback);\n      }\n\n      var deleteLabels = function deleteLabels(labels) {\n        var nullLabelMap = labels.reduce(function (nullLabelMap, labelKey) {\n          nullLabelMap[labelKey] = null;\n          return nullLabelMap;\n        }, {});\n\n        _this6.setLabels(nullLabelMap, callback);\n      };\n\n      if (labels.length === 0) {\n        this.getLabels(function (err, labels) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          deleteLabels(Object.keys(labels));\n        });\n      } else {\n        deleteLabels(labels);\n      }\n    }\n    /**\n     * @typedef {array} DisableRequesterPaysResponse\n     * @property {object} 0 The full API response.\n     */\n\n    /**\n     * @callback DisableRequesterPaysCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * <div class=\"notice\">\n     *   <strong>Early Access Testers Only</strong>\n     *   <p>\n     *     This feature is not yet widely-available.\n     *   </p>\n     * </div>\n     *\n     * Disable `requesterPays` functionality from this bucket.\n     *\n     * @param {DisableRequesterPaysCallback} [callback] Callback function.\n     * @returns {Promise<DisableRequesterPaysCallback>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.disableRequesterPays(function(err, apiResponse) {\n     *   if (!err) {\n     *     // requesterPays functionality disabled successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.disableRequesterPays().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     *\n     * @example <caption>include:samples/requesterPays.js</caption>\n     * region_tag:storage_disable_requester_pays\n     * Example of disabling requester pays:\n     */\n\n  }, {\n    key: \"disableRequesterPays\",\n    value: function disableRequesterPays(callback) {\n      this.setMetadata({\n        billing: {\n          requesterPays: false\n        }\n      }, callback || common_1.util.noop);\n    }\n    /**\n     * @typedef {array} EnableRequesterPaysResponse\n     * @property {object} 0 The full API response.\n     */\n\n    /**\n     * @callback EnableRequesterPaysCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * <div class=\"notice\">\n     *   <strong>Early Access Testers Only</strong>\n     *   <p>\n     *     This feature is not yet widely-available.\n     *   </p>\n     * </div>\n     *\n     * Enable `requesterPays` functionality for this bucket. This enables you, the\n     * bucket owner, to have the requesting user assume the charges for the access\n     * to your bucket and its contents.\n     *\n     * @param {EnableRequesterPaysCallback} [callback] Callback function.\n     * @returns {Promise<EnableRequesterPaysResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.enableRequesterPays(function(err, apiResponse) {\n     *   if (!err) {\n     *     // requesterPays functionality enabled successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.enableRequesterPays().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     *\n     * @example <caption>include:samples/requesterPays.js</caption>\n     * region_tag:storage_enable_requester_pays\n     * Example of enabling requester pays:\n     */\n\n  }, {\n    key: \"enableRequesterPays\",\n    value: function enableRequesterPays(callback) {\n      this.setMetadata({\n        billing: {\n          requesterPays: true\n        }\n      }, callback || common_1.util.noop);\n    }\n    /**\n     * Create a {@link File} object. See {@link File} to see how to handle\n     * the different use cases you may have.\n     *\n     * @param {string} name The name of the file in this bucket.\n     * @param {object} [options] Configuration options.\n     * @param {string|number} [options.generation] Only use a specific revision of\n     *     this file.\n     * @param {string} [options.encryptionKey] A custom encryption key. See\n     *     [Customer-supplied Encryption\n     * Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n     * @param {string} [options.kmsKeyName] The name of the Cloud KMS key that will\n     *     be used to encrypt the object. Must be in the format:\n     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.\n     *     KMS key ring must use the same location as the bucket.\n     * @returns {File}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     * const file = bucket.file('my-existing-file.png');\n     */\n\n  }, {\n    key: \"file\",\n    value: function file(name, options) {\n      if (!name) {\n        throw Error('A file name must be specified.');\n      }\n\n      return new file_1.File(this, name, options);\n    }\n    /**\n     * @typedef {array} GetFilesResponse\n     * @property {File[]} 0 Array of {@link File} instances.\n     */\n\n    /**\n     * @callback GetFilesCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files Array of {@link File} instances.\n     */\n\n    /**\n     * Query object for listing files.\n     *\n     * @typedef {object} GetFilesOptions\n     * @property {boolean} [autoPaginate=true] Have pagination handled\n     *     automatically.\n     * @property {string} [delimiter] Results will contain only objects whose\n     *     names, aside from the prefix, do not contain delimiter. Objects whose\n     *     names, aside from the prefix, contain delimiter will have their name\n     *     truncated after the delimiter, returned in `apiResponse.prefixes`.\n     *     Duplicate prefixes are omitted.\n     * @property {string} [directory] Filter results based on a directory name, or\n     *     more technically, a \"prefix\".\n     * @property {string} [prefix] Filter results to objects whose names begin\n     *     with this prefix.\n     * @property {number} [maxApiCalls] Maximum number of API calls to make.\n     * @property {number} [maxResults] Maximum number of items plus prefixes to\n     *     return.\n     * @property {string} [pageToken] A previously-returned page token\n     *     representing part of the larger set of results to view.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     * @property {boolean} [versions] If true, returns File objects scoped to\n     *     their versions.\n     */\n\n    /**\n     * Get {@link File} objects for the files currently in the bucket.\n     *\n     * @see [Objects: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/list}\n     *\n     * @param {GetFilesOptions} [query] Query object for listing files.\n     * @param {GetFilesCallback} [callback] Callback function.\n     * @returns {Promise<GetFilesResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.getFiles(function(err, files) {\n     *   if (!err) {\n     *     // files is an array of File objects.\n     *   }\n     * });\n     *\n     * //-\n     * // If your bucket has versioning enabled, you can get all of your files\n     * // scoped to their generation.\n     * //-\n     * bucket.getFiles({\n     *   versions: true\n     * }, function(err, files) {\n     *   // Each file is scoped to its generation.\n     * });\n     *\n     * //-\n     * // To control how many API requests are made and page through the results\n     * // manually, set `autoPaginate` to `false`.\n     * //-\n     * const callback = function(err, files, nextQuery, apiResponse) {\n     *   if (nextQuery) {\n     *     // More results exist.\n     *     bucket.getFiles(nextQuery, callback);\n     *   }\n     *\n     *   // The `metadata` property is populated for you with the metadata at the\n     *   // time of fetching.\n     *   files[0].metadata;\n     *\n     *   // However, in cases where you are concerned the metadata could have\n     *   // changed, use the `getMetadata` method.\n     *   files[0].getMetadata(function(err, metadata) {});\n     * };\n     *\n     * bucket.getFiles({\n     *   autoPaginate: false\n     * }, callback);\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.getFiles().then(function(data) {\n     *   const files = data[0];\n     * });\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_list_files\n     * Another example:\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_list_files_with_prefix\n     * Example of listing files, filtered by a prefix:\n     */\n\n  }, {\n    key: \"getFiles\",\n    value: function getFiles(queryOrCallback, callback) {\n      var _this7 = this;\n\n      var query = typeof queryOrCallback === 'object' ? queryOrCallback : {};\n\n      if (!callback) {\n        callback = queryOrCallback;\n      }\n\n      query = Object.assign({}, query);\n\n      if (query.directory) {\n        query.prefix = \"\".concat(query.directory, \"/\").replace(/\\/*$/, '/');\n        delete query.directory;\n      }\n\n      this.request({\n        uri: '/o',\n        qs: query\n      }, function (err, resp) {\n        if (err) {\n          // tslint:disable-next-line:no-any\n          callback(err, null, null, resp);\n          return;\n        }\n\n        var files = arrify(resp.items).map(function (file) {\n          var options = {};\n\n          if (query.versions) {\n            options.generation = file.generation;\n          }\n\n          if (file.kmsKeyName) {\n            options.kmsKeyName = file.kmsKeyName;\n          }\n\n          var fileInstance = _this7.file(file.name, options);\n\n          fileInstance.metadata = file;\n          return fileInstance;\n        });\n        var nextQuery = null;\n\n        if (resp.nextPageToken) {\n          nextQuery = Object.assign({}, query, {\n            pageToken: resp.nextPageToken\n          });\n        } // tslint:disable-next-line:no-any\n\n\n        callback(null, files, nextQuery, resp);\n      });\n    }\n    /**\n     * @typedef {object} GetLabelsOptions Configuration options for Bucket#getLabels().\n     * @param {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * @typedef {array} GetLabelsResponse\n     * @property {object} 0 Object of labels currently set on this bucket.\n     */\n\n    /**\n     * @callback GetLabelsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} labels Object of labels currently set on this bucket.\n     */\n\n    /**\n     * Get the labels currently set on this bucket.\n     *\n     * @param {object} [options] Configuration options.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {GetLabelsCallback} [callback] Callback function.\n     * @returns {Promise<GetLabelsCallback>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.getLabels(function(err, labels) {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   // labels = {\n     *   //   label: 'labelValue',\n     *   //   ...\n     *   // }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.getLabels().then(function(data) {\n     *   const labels = data[0];\n     * });\n     */\n\n  }, {\n    key: \"getLabels\",\n    value: function getLabels(optionsOrCallback, callback) {\n      var options = {};\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else if (optionsOrCallback) {\n        options = optionsOrCallback;\n      }\n\n      this.getMetadata(options, function (err, metadata) {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n\n        callback(null, metadata.labels || {});\n      });\n    }\n    /**\n     * @typedef {object} GetNotificationOptions Configuration options for Bucket#getNotification().\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * @callback GetNotificationsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {Notification[]} notifications Array of {@link Notification}\n     *     instances.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * @typedef {array} GetNotificationsResponse\n     * @property {Notification[]} 0 Array of {@link Notification} instances.\n     * @property {object} 1 The full API response.\n     */\n\n    /**\n     * Retrieves a list of notification subscriptions for a given bucket.\n     *\n     * @see [Notifications: list]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/list}\n     *\n     * @param {GetNotificationsOptions} [options] Configuration options.\n     * @param {GetNotificationsCallback} [callback] Callback function.\n     * @returns {Promise<GetNotificationsResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     *\n     * bucket.getNotifications(function(err, notifications, apiResponse) {\n     *   if (!err) {\n     *     // notifications is an array of Notification objects.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.getNotifications().then(function(data) {\n     *   const notifications = data[0];\n     *   const apiResponse = data[1];\n     * });\n     *\n     * @example <caption>include:samples/notifications.js</caption>\n     * region_tag:storage_list_notifications\n     * Another example:\n     */\n\n  }, {\n    key: \"getNotifications\",\n    value: function getNotifications(optionsOrCallback, callback) {\n      var _this8 = this;\n\n      var options = {};\n\n      if (typeof optionsOrCallback === 'function') {\n        callback = optionsOrCallback;\n      } else if (optionsOrCallback) {\n        options = optionsOrCallback;\n      }\n\n      this.request({\n        uri: '/notificationConfigs',\n        qs: options\n      }, function (err, resp) {\n        if (err) {\n          callback(err, null, resp);\n          return;\n        }\n\n        var notifications = arrify(resp.items).map(function (notification) {\n          var notificationInstance = _this8.notification(notification.id);\n\n          notificationInstance.metadata = notification;\n          return notificationInstance;\n        });\n        callback(null, notifications, resp);\n      });\n    }\n    /**\n     * @callback BucketLockCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * Lock a previously-defined retention policy. This will prevent changes to\n     * the policy.\n     *\n     * @throws {Error} if a metageneration is not provided.\n     *\n     * @param {Number|String} metageneration The bucket's metageneration. This is\n     *     accesssible from calling {@link File#getMetadata}.\n     * @param {BucketLockCallback} [callback] Callback function.\n     * @returns {Promise<BucketLockResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     *\n     * const metageneration = 2;\n     *\n     * bucket.lock(metageneration, function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.lock(metageneration).then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n\n  }, {\n    key: \"lock\",\n    value: function lock(metageneration, callback) {\n      var metatype = typeof metageneration;\n\n      if (metatype !== 'number' && metatype !== 'string') {\n        throw new Error('A metageneration must be provided.');\n      }\n\n      this.request({\n        method: 'POST',\n        uri: '/lockRetentionPolicy',\n        qs: {\n          ifMetagenerationMatch: metageneration\n        }\n      }, callback);\n    }\n    /**\n     * @typedef {array} MakeBucketPrivateResponse\n     * @property {File[]} 0 List of files made private.\n     */\n\n    /**\n     * @callback MakeBucketPrivateCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files List of files made private.\n     */\n\n    /**\n     * @typedef {object} MakeBucketPrivateOptions\n     * @param {boolean} [includeFiles=false] Make each file in the bucket\n     *     private.\n     * @param {boolean} [force] Queue errors occurred while making files\n     *     private until all files have been processed.\n     * @param {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * Make the bucket listing private.\n     *\n     * You may also choose to make the contents of the bucket private by\n     * specifying `includeFiles: true`. This will automatically run\n     * {@link File#makePrivate} for every file in the bucket.\n     *\n     * When specifying `includeFiles: true`, use `force: true` to delay execution\n     * of your callback until all files have been processed. By default, the\n     * callback is executed after the first error. Use `force` to queue such\n     * errors until all files have been processed, after which they will be\n     * returned as an array as the first argument to your callback.\n     *\n     * NOTE: This may cause the process to be long-running and use a high number\n     * of requests. Use with caution.\n     *\n     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n     *\n     * @param {MakeBucketPrivateOptions} [options] Configuration options.\n     * @param {MakeBucketPrivateCallback} [callback] Callback function.\n     * @returns {Promise<MakeBucketPrivateResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Make the bucket private.\n     * //-\n     * bucket.makePrivate(function(err) {});\n     *\n     * //-\n     * // Make the bucket and its contents private.\n     * //-\n     * const opts = {\n     *   includeFiles: true\n     * };\n     *\n     * bucket.makePrivate(opts, function(err, files) {\n     *   // `err`:\n     *   //    The first error to occur, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made private in the bucket.\n     * });\n     *\n     * //-\n     * // Make the bucket and its contents private, using force to suppress errors\n     * // until all files have been processed.\n     * //-\n     * const opts = {\n     *   includeFiles: true,\n     *   force: true\n     * };\n     *\n     * bucket.makePrivate(opts, function(errors, files) {\n     *   // `errors`:\n     *   //    Array of errors if any occurred, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made private in the bucket.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.makePrivate(opts).then(function(data) {\n     *   const files = data[0];\n     * });\n     */\n\n  }, {\n    key: \"makePrivate\",\n    value: function makePrivate(optionsOrCallback, callback) {\n      var _this9 = this;\n\n      var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n      callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n      options.private = true;\n\n      var setPredefinedAcl = function setPredefinedAcl(done) {\n        var query = {\n          predefinedAcl: 'projectPrivate'\n        };\n\n        if (options.userProject) {\n          query.userProject = options.userProject;\n        }\n\n        _this9.setMetadata({\n          // You aren't allowed to set both predefinedAcl & acl properties on\n          // a bucket so acl must explicitly be nullified.\n          acl: null\n        }, query, done);\n      };\n\n      var makeFilesPrivate = function makeFilesPrivate(done) {\n        if (!options.includeFiles) {\n          done();\n          return;\n        }\n\n        _this9.makeAllFilesPublicPrivate_(options, done);\n      }; // tslint:disable-next-line no-any\n\n\n      async.series([setPredefinedAcl, makeFilesPrivate], callback);\n    }\n    /**\n     * @typedef {object} MakeBucketPublicOptions\n     * @param {boolean} [includeFiles=false] Make each file in the bucket\n     *     private.\n     * @param {boolean} [force] Queue errors occurred while making files\n     *     private until all files have been processed.\n     */\n\n    /**\n     * @callback MakeBucketPublicCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files List of files made public.\n     */\n\n    /**\n     * @typedef {array} MakeBucketPublicResponse\n     * @property {File[]} 0 List of files made public.\n     */\n\n    /**\n     * Make the bucket publicly readable.\n     *\n     * You may also choose to make the contents of the bucket publicly readable by\n     * specifying `includeFiles: true`. This will automatically run\n     * {@link File#makePublic} for every file in the bucket.\n     *\n     * When specifying `includeFiles: true`, use `force: true` to delay execution\n     * of your callback until all files have been processed. By default, the\n     * callback is executed after the first error. Use `force` to queue such\n     * errors until all files have been processed, after which they will be\n     * returned as an array as the first argument to your callback.\n     *\n     * NOTE: This may cause the process to be long-running and use a high number\n     * of requests. Use with caution.\n     *\n     * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n     *\n     * @param {MakeBucketPublicOptions} [options] Configuration options.\n     * @param {MakeBucketPublicCallback} [callback] Callback function.\n     * @returns {Promise<MakeBucketPublicResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Make the bucket publicly readable.\n     * //-\n     * bucket.makePublic(function(err) {});\n     *\n     * //-\n     * // Make the bucket and its contents publicly readable.\n     * //-\n     * const opts = {\n     *   includeFiles: true\n     * };\n     *\n     * bucket.makePublic(opts, function(err, files) {\n     *   // `err`:\n     *   //    The first error to occur, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made public in the bucket.\n     * });\n     *\n     * //-\n     * // Make the bucket and its contents publicly readable, using force to\n     * // suppress errors until all files have been processed.\n     * //-\n     * const opts = {\n     *   includeFiles: true,\n     *   force: true\n     * };\n     *\n     * bucket.makePublic(opts, function(errors, files) {\n     *   // `errors`:\n     *   //    Array of errors if any occurred, otherwise null.\n     *   //\n     *   // `files`:\n     *   //    Array of files successfully made public in the bucket.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.makePublic(opts).then(function(data) {\n     *   const files = data[0];\n     * });\n     */\n\n  }, {\n    key: \"makePublic\",\n    value: function makePublic(optionsOrCallback, callback) {\n      var _this10 = this;\n\n      var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n      callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n      var req = extend(true, {\n        public: true\n      }, options);\n\n      var addAclPermissions = function addAclPermissions(done) {\n        // Allow reading bucket contents while preserving original permissions.\n        _this10.acl.add({\n          entity: 'allUsers',\n          role: 'READER'\n        }, done);\n      };\n\n      var addDefaultAclPermissions = function addDefaultAclPermissions(done) {\n        _this10.acl.default.add({\n          entity: 'allUsers',\n          role: 'READER'\n        }, done);\n      };\n\n      var makeFilesPublic = function makeFilesPublic(done) {\n        if (!req.includeFiles) {\n          done();\n          return;\n        }\n\n        _this10.makeAllFilesPublicPrivate_(req, done);\n      }; // tslint:disable-next-line:no-any\n\n\n      async.series([addAclPermissions, addDefaultAclPermissions, makeFilesPublic], callback);\n    }\n    /**\n     * Get a reference to a Cloud Pub/Sub Notification.\n     *\n     * @param {string} id ID of notification.\n     * @returns {Notification}\n     * @see Notification\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('my-bucket');\n     * const notification = bucket.notification('1');\n     */\n\n  }, {\n    key: \"notification\",\n    value: function notification(id) {\n      if (!id) {\n        throw new Error('You must supply a notification ID.');\n      }\n\n      return new notification_1.Notification(this, id);\n    }\n    /**\n     * Remove an already-existing retention policy from this bucket, if it is not\n     * locked.\n     *\n     * @param {SetBucketMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetBucketMetadataResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.removeRetentionPeriod(function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.removeRetentionPeriod().then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n\n  }, {\n    key: \"removeRetentionPeriod\",\n    value: function removeRetentionPeriod(callback) {\n      this.setMetadata({\n        retentionPolicy: null\n      }, callback);\n    }\n    /**\n     * Makes request and applies userProject query parameter if necessary.\n     *\n     * @private\n     *\n     * @param {object} reqOpts - The request options.\n     * @param {function} callback - The callback function.\n     */\n\n  }, {\n    key: \"request\",\n    value: function request(reqOpts, callback) {\n      if (this.userProject && (!reqOpts.qs || !reqOpts.qs.userProject)) {\n        reqOpts.qs = extend(reqOpts.qs, {\n          userProject: this.userProject\n        });\n      }\n\n      return _get(_getPrototypeOf(Bucket.prototype), \"request\", this).call(this, reqOpts, callback);\n    }\n    /**\n     * @typedef {array} SetLabelsResponse\n     * @property {object} 0 The bucket metadata.\n     */\n\n    /**\n     * @callback SetLabelsCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} metadata The bucket metadata.\n     */\n\n    /**\n     * @typedef {object} SetLabelsOptions Configuration options for Bucket#setLabels().\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * Set labels on the bucket.\n     *\n     * This makes an underlying call to {@link Bucket#setMetadata}, which\n     * is a PATCH request. This means an individual label can be overwritten, but\n     * unmentioned labels will not be touched.\n     *\n     * @param {object<string, string>} labels Labels to set on the bucket.\n     * @param {object} [options] Configuration options.\n     * @param {SetLabelsCallback} [callback] Callback function.\n     * @returns {Promise<SetLabelsResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * const labels = {\n     *   labelone: 'labelonevalue',\n     *   labeltwo: 'labeltwovalue'\n     * };\n     *\n     * bucket.setLabels(labels, function(err, metadata) {\n     *   if (!err) {\n     *     // Labels set successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.setLabels(labels).then(function(data) {\n     *   const metadata = data[0];\n     * });\n     */\n\n  }, {\n    key: \"setLabels\",\n    value: function setLabels(labels, optionsOrCallback, callback) {\n      var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n      callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n      callback = callback || common_1.util.noop;\n      this.setMetadata({\n        labels: labels\n      }, options, callback);\n    }\n    /**\n     * Lock all objects contained in the bucket, based on their creation time. Any\n     * attempt to overwrite or delete objects younger than the retention period\n     * will result in a `PERMISSION_DENIED` error.\n     *\n     * An unlocked retention policy can be modified or removed from the bucket via\n     * {@link File#removeRetentionPeriod} and {@link File#setRetentionPeriod}. A\n     * locked retention policy cannot be removed or shortened in duration for the\n     * lifetime of the bucket. Attempting to remove or decrease period of a locked\n     * retention policy will result in a `PERMISSION_DENIED` error. You can still\n     * increase the policy.\n     *\n     * @param {*} duration In seconds, the minimum retention time for all objects\n     *     contained in this bucket.\n     * @param {SetBucketMetadataCallback} [callback] Callback function.\n     * @returns {Promise<SetBucketMetadataResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     *\n     * const DURATION_SECONDS = 15780000; // 6 months.\n     *\n     * //-\n     * // Lock the objects in this bucket for 6 months.\n     * //-\n     * bucket.setRetentionPeriod(DURATION_SECONDS, function(err, apiResponse) {});\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.setRetentionPeriod(DURATION_SECONDS).then(function(data) {\n     *   const apiResponse = data[0];\n     * });\n     */\n\n  }, {\n    key: \"setRetentionPeriod\",\n    value: function setRetentionPeriod(duration, callback) {\n      this.setMetadata({\n        retentionPolicy: {\n          retentionPeriod: duration\n        }\n      }, callback);\n    }\n    /**\n     * @typedef {object} SetBucketStorageClassOptions\n     * @param {string} [userProject] - The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * @callback SetBucketStorageClassCallback\n     * @param {?Error} err Request error, if any.\n     */\n\n    /**\n     * Set the default storage class for new files in this bucket.\n     *\n     * @see [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes}\n     *\n     * @param {string} storageClass The new storage class. (`multi_regional`,\n     *     `regional`, `standard`, `nearline`, `coldline`, or\n     *     `durable_reduced_availability`)\n     * @param {object} [options] Configuration options.\n     * @param {string} [options.userProject] - The ID of the project which will be\n     *     billed for the request.\n     * @param {SetStorageClassCallback} [callback] Callback function.\n     * @returns {Promise}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.setStorageClass('regional', function(err, apiResponse) {\n     *   if (err) {\n     *     // Error handling omitted.\n     *   }\n     *\n     *   // The storage class was updated successfully.\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.setStorageClass('regional').then(function() {});\n     */\n\n  }, {\n    key: \"setStorageClass\",\n    value: function setStorageClass(storageClass, optionsOrCallback, callback) {\n      var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n      callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : callback; // In case we get input like `storageClass`, convert to `storage_class`.\n\n      storageClass = storageClass.replace(/-/g, '_').replace(/([a-z])([A-Z])/g, function (_, low, up) {\n        return low + '_' + up;\n      }).toUpperCase();\n      this.setMetadata({\n        storageClass: storageClass\n      }, options, callback);\n    }\n    /**\n     * Set a user project to be billed for all requests made from this Bucket\n     * object and any files referenced from this Bucket object.\n     *\n     * @param {string} userProject The user project.\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * bucket.setUserProject('grape-spaceship-123');\n     */\n\n  }, {\n    key: \"setUserProject\",\n    value: function setUserProject(userProject) {\n      var _this11 = this;\n\n      this.userProject = userProject;\n      var methods = ['create', 'delete', 'exists', 'get', 'getMetadata', 'setMetadata'];\n      methods.forEach(function (method) {\n        var methodConfig = _this11.methods[method];\n\n        if (typeof methodConfig === 'object') {\n          if (typeof methodConfig.reqOpts === 'object') {\n            extend(methodConfig.reqOpts.qs, {\n              userProject: userProject\n            });\n          } else {\n            methodConfig.reqOpts = {\n              qs: {\n                userProject: userProject\n              }\n            };\n          }\n        }\n      });\n    }\n    /**\n     * @typedef {object} UploadOptions Configuration options for Bucket#upload().\n     * @param {string|File} [options.destination] The place to save\n     *     your file. If given a string, the file will be uploaded to the bucket\n     *     using the string as a filename. When given a File object, your local\n     * file will be uploaded to the File object's bucket and under the File\n     * object's name. Lastly, when this argument is omitted, the file is uploaded\n     * to your bucket using the name of the local file.\n     * @param {string} [options.encryptionKey] A custom encryption key. See\n     *     [Customer-supplied Encryption\n     * Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n     * @param {boolean} [options.gzip] Automatically gzip the file. This will set\n     *     `options.metadata.contentEncoding` to `gzip`.\n     * @param {string} [options.kmsKeyName] The name of the Cloud KMS key that will\n     *     be used to encrypt the object. Must be in the format:\n     *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.\n     * @param {object} [options.metadata] See an\n     *     [Objects: insert request\n     * body](https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON).\n     * @param {string} [options.offset] The starting byte of the upload stream, for\n     *     resuming an interrupted upload. Defaults to 0.\n     * @param {string} [options.predefinedAcl] Apply a predefined set of access\n     *     controls to this object.\n     *\n     *     Acceptable values are:\n     *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n     *       `allAuthenticatedUsers` get `READER` access.\n     *\n     *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n     *       project team owners get `OWNER` access.\n     *\n     *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n     *       team owners get `READER` access.\n     *\n     *     - **`private`** - Object owner gets `OWNER` access.\n     *\n     *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n     *       team members get access according to their roles.\n     *\n     *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers`\n     * get `READER` access.\n     * @param {boolean} [options.private] Make the uploaded file private. (Alias for\n     *     `options.predefinedAcl = 'private'`)\n     * @param {boolean} [options.public] Make the uploaded file public. (Alias for\n     *     `options.predefinedAcl = 'publicRead'`)\n     * @param {boolean} [options.resumable] Force a resumable upload. (default:\n     *     true for files larger than 5 MB).\n     * @param {string} [options.uri] The URI for an already-created resumable\n     *     upload. See {@link File#createResumableUpload}.\n     * @param {string} [options.userProject] The ID of the project which will be\n     *     billed for the request.\n     * @param {string|boolean} [options.validation] Possible values: `\"md5\"`,\n     *     `\"crc32c\"`, or `false`. By default, data integrity is validated with an\n     *     MD5 checksum for maximum reliability. CRC32c will provide better\n     *     performance with less reliability. You may also choose to skip\n     * validation completely, however this is **not recommended**.\n     */\n\n    /**\n     * @typedef {array} UploadResponse\n     * @property {object} 0 The uploaded {@link File}.\n     * @property {object} 1 The full API response.\n     */\n\n    /**\n     * @callback UploadCallback\n     * @param {?Error} err Request error, if any.\n     * @param {object} file The uploaded {@link File}.\n     * @param {object} apiResponse The full API response.\n     */\n\n    /**\n     * Upload a file to the bucket. This is a convenience method that wraps\n     * {@link File#createWriteStream}.\n     *\n     * You can specify whether or not an upload is resumable by setting\n     * `options.resumable`. *Resumable uploads are enabled by default if your\n     * input file is larger than 5 MB.*\n     *\n     * For faster crc32c computation, you must manually install\n     * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n     *\n     *     $ npm install --save fast-crc32c\n     *\n     * @see [Upload Options (Simple or Resumable)]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#uploads}\n     * @see [Objects: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert}\n     *\n     * @param {string} pathString The fully qualified path to the file you\n     *     wish to upload to your bucket.\n     * @param {UploadOptions} [options] Configuration options.\n     * @param {UploadCallback} [callback] Callback function.\n     * @returns {Promise<UploadResponse>}\n     *\n     * @example\n     * const {Storage} = require('@google-cloud/storage');\n     * const storage = new Storage();\n     * const bucket = storage.bucket('albums');\n     *\n     * //-\n     * // Upload a file from a local path.\n     * //-\n     * bucket.upload('/local/path/image.png', function(err, file, apiResponse) {\n     *   // Your bucket now contains:\n     *   // - \"image.png\" (with the contents of `/local/path/image.png')\n     *\n     *   // `file` is an instance of a File object that refers to your new file.\n     * });\n     *\n     *\n     * //-\n     * // It's not always that easy. You will likely want to specify the filename\n     * // used when your new file lands in your bucket.\n     * //\n     * // You may also want to set metadata or customize other options.\n     * //-\n     * const options = {\n     *   destination: 'new-image.png',\n     *   resumable: true,\n     *   validation: 'crc32c',\n     *   metadata: {\n     *     metadata: {\n     *       event: 'Fall trip to the zoo'\n     *     }\n     *   }\n     * };\n     *\n     * bucket.upload('local-image.png', options, function(err, file) {\n     *   // Your bucket now contains:\n     *   // - \"new-image.png\" (with the contents of `local-image.png')\n     *\n     *   // `file` is an instance of a File object that refers to your new file.\n     * });\n     *\n     * //-\n     * // You can also have a file gzip'd on the fly.\n     * //-\n     * bucket.upload('index.html', { gzip: true }, function(err, file) {\n     *   // Your bucket now contains:\n     *   // - \"index.html\" (automatically compressed with gzip)\n     *\n     *   // Downloading the file with `file.download` will automatically decode\n     * the\n     *   // file.\n     * });\n     *\n     * //-\n     * // You may also re-use a File object, {File}, that references\n     * // the file you wish to create or overwrite.\n     * //-\n     * const options = {\n     *   destination: bucket.file('existing-file.png'),\n     *   resumable: false\n     * };\n     *\n     * bucket.upload('local-img.png', options, function(err, newFile) {\n     *   // Your bucket now contains:\n     *   // - \"existing-file.png\" (with the contents of `local-img.png')\n     *\n     *   // Note:\n     *   // The `newFile` parameter is equal to `file`.\n     * });\n     *\n     * //-\n     * // To use\n     * // <a\n     * href=\"https://cloud.google.com/storage/docs/encryption#customer-supplied\">\n     * // Customer-supplied Encryption Keys</a>, provide the `encryptionKey`\n     * option.\n     * //-\n     * const crypto = require('crypto');\n     * const encryptionKey = crypto.randomBytes(32);\n     *\n     * bucket.upload('img.png', {\n     *   encryptionKey: encryptionKey\n     * }, function(err, newFile) {\n     *   // `img.png` was uploaded with your custom encryption key.\n     *\n     *   // `newFile` is already configured to use the encryption key when making\n     *   // operations on the remote object.\n     *\n     *   // However, to use your encryption key later, you must create a `File`\n     *   // instance with the `key` supplied:\n     *   const file = bucket.file('img.png', {\n     *     encryptionKey: encryptionKey\n     *   });\n     *\n     *   // Or with `file#setEncryptionKey`:\n     *   const file = bucket.file('img.png');\n     *   file.setEncryptionKey(encryptionKey);\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.upload('local-image.png').then(function(data) {\n     *   const file = data[0];\n     * });\n     *\n     * To upload a file from a URL, use {@link File#createWriteStream}.\n     *\n     * @example <caption>include:samples/files.js</caption>\n     * region_tag:storage_upload_file\n     * Another example:\n     *\n     * @example <caption>include:samples/encryption.js</caption>\n     * region_tag:storage_upload_encrypted_file\n     * Example of uploading an encrypted file:\n     */\n\n  }, {\n    key: \"upload\",\n    value: function upload(pathString, optionsOrCallback, callback) {\n      // tslint:disable-next-line:no-any\n      if (global['GCLOUD_SANDBOX_ENV']) {\n        return;\n      }\n\n      var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n      callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n      options = Object.assign({\n        metadata: {}\n      }, options);\n      var newFile;\n\n      if (options.destination instanceof file_1.File) {\n        newFile = options.destination;\n      } else if (options.destination != null && typeof options.destination === 'string') {\n        // Use the string as the name of the file.\n        newFile = this.file(options.destination, {\n          encryptionKey: options.encryptionKey,\n          kmsKeyName: options.kmsKeyName\n        });\n      } else {\n        // Resort to using the name of the incoming file.\n        var destination = path.basename(pathString);\n        newFile = this.file(destination, {\n          encryptionKey: options.encryptionKey,\n          kmsKeyName: options.kmsKeyName\n        });\n      }\n\n      var contentType = mime.contentType(path.basename(pathString));\n\n      if (contentType && !options.metadata.contentType) {\n        options.metadata.contentType = contentType;\n      }\n\n      if (options.resumable != null && typeof options.resumable === 'boolean') {\n        upload();\n      } else {\n        // Determine if the upload should be resumable if it's over the threshold.\n        fs.stat(pathString, function (err, fd) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          options.resumable = fd.size > RESUMABLE_THRESHOLD;\n          upload();\n        });\n      }\n\n      function upload() {\n        fs.createReadStream(pathString).on('error', callback).pipe(newFile.createWriteStream(options)).on('error', callback).on('finish', function () {\n          callback(null, newFile, newFile.metadata);\n        });\n      }\n    }\n    /**\n     * @private\n     *\n     * @typedef {object} MakeAllFilesPublicPrivateOptions\n     * @property {boolean} [force] Suppress errors until all files have been\n     *     processed.\n     * @property {boolean} [private] Make files private.\n     * @property {boolean} [public] Make files public.\n     * @property {string} [userProject] The ID of the project which will be\n     *     billed for the request.\n     */\n\n    /**\n     * @private\n     *\n     * @callback SetBucketMetadataCallback\n     * @param {?Error} err Request error, if any.\n     * @param {File[]} files Files that were updated.\n     */\n\n    /**\n     * @typedef {array} MakeAllFilesPublicPrivateResponse\n     * @property {File[]} 0 List of files affected.\n     */\n\n    /**\n     * Iterate over all of a bucket's files, calling `file.makePublic()` (public)\n     * or `file.makePrivate()` (private) on each.\n     *\n     * Operations are performed in parallel, up to 10 at once. The first error\n     * breaks the loop, and will execute the provided callback with it. Specify\n     * `{ force: true }` to suppress the errors.\n     *\n     * @private\n     *\n     * @param {MakeAllFilesPublicPrivateOptions} [options] Configuration options.\n     * @param {MakeAllFilesPublicPrivateCallback} callback Callback function.\n     *\n     * @return {Promise<MakeAllFilesPublicPrivateResponse>}\n     */\n\n  }, {\n    key: \"makeAllFilesPublicPrivate_\",\n    value: function makeAllFilesPublicPrivate_(optionsOrCallback, callback) {\n      var MAX_PARALLEL_LIMIT = 10;\n      var errors = [];\n      var updatedFiles = [];\n      var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : {};\n      callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : callback;\n      this.getFiles(options, function (err, files) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        var processFile = function processFile(file, callback) {\n          var processedCallback = function processedCallback(err) {\n            if (err) {\n              if (options.force) {\n                errors.push(err);\n                callback();\n                return;\n              }\n\n              callback(err);\n              return;\n            }\n\n            updatedFiles.push(file);\n            callback();\n          };\n\n          if (options.public) {\n            file.makePublic(processedCallback);\n          } else if (options.private) {\n            file.makePrivate(options, processedCallback);\n          }\n        }; // Iterate through each file and make it public or private.\n\n\n        async.eachLimit(files, MAX_PARALLEL_LIMIT, processFile, function (err) {\n          if (err || errors.length > 0) {\n            callback(err || errors, updatedFiles);\n            return;\n          }\n\n          callback(null, updatedFiles);\n        });\n      });\n    }\n  }, {\n    key: \"getId\",\n    value: function getId() {\n      return this.id;\n    }\n  }]);\n\n  return Bucket;\n}(common_1.ServiceObject);\n\nexports.Bucket = Bucket;\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\n\npaginator_1.paginator.extend(Bucket, 'getFiles');\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n\npromisify_1.promisifyAll(Bucket, {\n  exclude: ['request', 'file', 'notification']\n});","map":null,"metadata":{},"sourceType":"script"}