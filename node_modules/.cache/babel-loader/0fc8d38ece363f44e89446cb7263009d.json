{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _possibleConstructorReturn = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _regeneratorRuntime = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar rbtree = require(\"functional-red-black-tree\");\n\nvar through2 = require(\"through2\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar document_1 = require(\"./document\");\n\nvar document_change_1 = require(\"./document-change\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar types_1 = require(\"./types\");\n\nvar util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n *\n * @private\n * @type {number}\n */\n\n\nvar WATCH_TARGET_ID = 0x1;\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\n\nvar ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * List of GRPC Error Codes.\n *\n * This corresponds to\n * {@link https://github.com/grpc/grpc/blob/master/doc/statuscodes.md}.\n */\n\nvar GRPC_STATUS_CODE = {\n  // Not an error; returned on success.\n  OK: 0,\n  // The operation was cancelled (typically by the caller).\n  CANCELLED: 1,\n  // Unknown error. An example of where this error may be returned is if a\n  // Status value received from another address space belongs to an error-space\n  // that is not known in this address space. Also errors raised by APIs that\n  // do not return enough error information may be converted to this error.\n  UNKNOWN: 2,\n  // Client specified an invalid argument. Note that this differs from\n  // FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n  // problematic regardless of the state of the system (e.g., a malformed file\n  // name).\n  INVALID_ARGUMENT: 3,\n  // Deadline expired before operation could complete. For operations that\n  // change the state of the system, this error may be returned even if the\n  // operation has completed successfully. For example, a successful response\n  // from a server could have been delayed long enough for the deadline to\n  // expire.\n  DEADLINE_EXCEEDED: 4,\n  // Some requested entity (e.g., file or directory) was not found.\n  NOT_FOUND: 5,\n  // Some entity that we attempted to create (e.g., file or directory) already\n  // exists.\n  ALREADY_EXISTS: 6,\n  // The caller does not have permission to execute the specified operation.\n  // PERMISSION_DENIED must not be used for rejections caused by exhausting\n  // some resource (use RESOURCE_EXHAUSTED instead for those errors).\n  // PERMISSION_DENIED must not be used if the caller can not be identified\n  // (use UNAUTHENTICATED instead for those errors).\n  PERMISSION_DENIED: 7,\n  // The request does not have valid authentication credentials for the\n  // operation.\n  UNAUTHENTICATED: 16,\n  // Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n  // entire file system is out of space.\n  RESOURCE_EXHAUSTED: 8,\n  // Operation was rejected because the system is not in a state required for\n  // the operation's execution. For example, directory to be deleted may be\n  // non-empty, an rmdir operation is applied to a non-directory, etc.\n  //\n  // A litmus test that may help a service implementor in deciding\n  // between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n  //  (a) Use UNAVAILABLE if the client can retry just the failing call.\n  //  (b) Use ABORTED if the client should retry at a higher-level\n  //      (e.g., restarting a read-modify-write sequence).\n  //  (c) Use FAILED_PRECONDITION if the client should not retry until\n  //      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n  //      fails because the directory is non-empty, FAILED_PRECONDITION\n  //      should be returned since the client should not retry unless\n  //      they have first fixed up the directory by deleting files from it.\n  //  (d) Use FAILED_PRECONDITION if the client performs conditional\n  //      REST Get/Update/Delete on a resource and the resource on the\n  //      server does not match the condition. E.g., conflicting\n  //      read-modify-write on the same resource.\n  FAILED_PRECONDITION: 9,\n  // The operation was aborted, typically due to a concurrency issue like\n  // sequencer check failures, transaction aborts, etc.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  ABORTED: 10,\n  // Operation was attempted past the valid range. E.g., seeking or reading\n  // past end of file.\n  //\n  // Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n  // if the system state changes. For example, a 32-bit file system will\n  // generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n  // range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n  // an offset past the current file size.\n  //\n  // There is a fair bit of overlap between FAILED_PRECONDITION and\n  // OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n  // when it applies so that callers who are iterating through a space can\n  // easily look for an OUT_OF_RANGE error to detect when they are done.\n  OUT_OF_RANGE: 11,\n  // Operation is not implemented or not supported/enabled in this service.\n  UNIMPLEMENTED: 12,\n  // Internal errors. Means some invariants expected by underlying System has\n  // been broken. If you see one of these errors, Something is very broken.\n  INTERNAL: 13,\n  // The service is currently unavailable. This is a most likely a transient\n  // condition and may be corrected by retrying with a backoff.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  UNAVAILABLE: 14,\n  // Unrecoverable data loss or corruption.\n  DATA_LOSS: 15,\n  // Force users to include a default branch:\n  DO_NOT_USE: -1\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\n\nvar DOCUMENT_WATCH_COMPARATOR = function DOCUMENT_WATCH_COMPARATOR(doc1, doc2) {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\n\n\nvar Watch =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  function Watch(firestore) {\n    _classCallCheck(this, Watch);\n\n    this._firestore = firestore;\n    this._backoff = new backoff_1.ExponentialBackoff();\n    this._requestTag = util_1.requestTag();\n  }\n  /**\n   * Determines whether an error is considered permanent and should not be\n   * retried. Errors that don't provide a GRPC error code are always considered\n   * transient in this context.\n   *\n   * @private\n   * @param error An error object.\n   * @return Whether the error is permanent.\n   */\n\n\n  _createClass(Watch, [{\n    key: \"isPermanentError\",\n    value: function isPermanentError(error) {\n      if (error.code === undefined) {\n        logger_1.logger('Watch.onSnapshot', this._requestTag, 'Unable to determine error code: ', error);\n        return false;\n      }\n\n      switch (error.code) {\n        case GRPC_STATUS_CODE.CANCELLED:\n        case GRPC_STATUS_CODE.UNKNOWN:\n        case GRPC_STATUS_CODE.DEADLINE_EXCEEDED:\n        case GRPC_STATUS_CODE.RESOURCE_EXHAUSTED:\n        case GRPC_STATUS_CODE.INTERNAL:\n        case GRPC_STATUS_CODE.UNAVAILABLE:\n        case GRPC_STATUS_CODE.UNAUTHENTICATED:\n          return false;\n\n        default:\n          return true;\n      }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n\n  }, {\n    key: \"isResourceExhaustedError\",\n    value: function isResourceExhaustedError(error) {\n      return error.code === GRPC_STATUS_CODE.RESOURCE_EXHAUSTED;\n    }\n    /**\n     * Starts a watch and attaches a listener for document change events.\n     *\n     * @private\n     * @param onNext A callback to be called every time a new snapshot is\n     * available.\n     * @param onError A callback to be called if the listen fails or is cancelled.\n     * No further callbacks will occur.\n     *\n     * @returns An unsubscribe function that can be called to cancel the snapshot\n     * listener.\n     */\n\n  }, {\n    key: \"onSnapshot\",\n    value: function onSnapshot(onNext, onError) {\n      var _this = this;\n\n      // The sorted tree of QueryDocumentSnapshots as sent in the last snapshot.\n      // We only look at the keys.\n      var docTree = rbtree(this.getComparator()); // A map of document names to QueryDocumentSnapshots for the last sent\n      // snapshot.\n\n      var docMap = new Map(); // The accumulates map of document changes (keyed by document name) for the\n      // current snapshot.\n\n      var changeMap = new Map(); // The current state of the query results.\n\n      var current = false; // We need this to track whether we've pushed an initial set of changes,\n      // since we should push those even when there are no changes, if there \\\n      // aren't docs.\n\n      var hasPushed = false; // The server assigns and updates the resume token.\n\n      var resumeToken = undefined; // Indicates whether we are interested in data from the stream. Set to false\n      // in the 'unsubscribe()' callback.\n\n      var isActive = true; // Sentinel value for a document remove.\n\n      var REMOVED = {};\n      var request = {}; // We may need to replace the underlying stream on reset events.\n      // This is the one that will be returned and proxy the current one.\n\n      var stream = through2.obj(); // The current stream to the backend.\n\n      var currentStream = null;\n      /** Helper to clear the docs on RESET or filter mismatch. */\n\n      var resetDocs = function resetDocs() {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Resetting documents');\n        changeMap.clear();\n        resumeToken = undefined;\n        docTree.forEach(function (snapshot) {\n          // Mark each document as deleted. If documents are not deleted, they\n          // will be send again by the server.\n          changeMap.set(snapshot.ref.path, REMOVED);\n        });\n        current = false;\n      };\n      /** Closes the stream and calls onError() if the stream is still active. */\n\n\n      var closeStream = function closeStream(err) {\n        if (currentStream) {\n          currentStream.unpipe(stream);\n          currentStream.end();\n          currentStream = null;\n        }\n\n        stream.end();\n\n        if (isActive) {\n          isActive = false;\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Invoking onError: ', err);\n          onError(err);\n        }\n      };\n      /**\n       * Re-opens the stream unless the specified error is considered permanent.\n       * Clears the change map.\n       */\n\n\n      var maybeReopenStream = function maybeReopenStream(err) {\n        if (currentStream) {\n          currentStream.unpipe(stream);\n          currentStream = null;\n        }\n\n        if (isActive && !_this.isPermanentError(err)) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Stream ended, re-opening after retryable error: ', err);\n          changeMap.clear();\n\n          if (_this.isResourceExhaustedError(err)) {\n            _this._backoff.resetToMax();\n          }\n\n          initStream();\n        } else {\n          closeStream(err);\n        }\n      };\n      /** Helper to restart the outgoing stream to the backend. */\n\n\n      var restartStream = function restartStream() {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Restarting stream');\n\n        if (currentStream) {\n          currentStream.unpipe(stream);\n          currentStream.end();\n          currentStream = null;\n        }\n\n        initStream();\n      };\n      /**\n       * Initializes a new stream to the backend with backoff.\n       */\n\n\n      var initStream = function initStream() {\n        _this._backoff.backoffAndWait().then(function () {\n          return __awaiter(_this, void 0, void 0,\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee() {\n            var _this2 = this;\n\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    if (isActive) {\n                      _context.next = 3;\n                      break;\n                    }\n\n                    logger_1.logger('Watch.onSnapshot', this._requestTag, 'Not initializing inactive stream');\n                    return _context.abrupt(\"return\");\n\n                  case 3:\n                    _context.next = 5;\n                    return this._firestore.initializeIfNeeded();\n\n                  case 5:\n                    request.database = this._firestore.formattedName;\n                    request.addTarget = this.getTarget(resumeToken); // Note that we need to call the internal _listen API to pass additional\n                    // header values in readWriteStream.\n\n                    this._firestore.readWriteStream('listen', request, this._requestTag, true).then(function (backendStream) {\n                      if (!isActive) {\n                        logger_1.logger('Watch.onSnapshot', _this2._requestTag, 'Closing inactive stream');\n                        backendStream.end();\n                        return;\n                      }\n\n                      logger_1.logger('Watch.onSnapshot', _this2._requestTag, 'Opened new stream');\n                      currentStream = backendStream;\n                      currentStream.on('error', function (err) {\n                        maybeReopenStream(err);\n                      });\n                      currentStream.on('end', function () {\n                        var err = new types_1.GrpcError('Stream ended unexpectedly');\n                        err.code = GRPC_STATUS_CODE.UNKNOWN;\n                        maybeReopenStream(err);\n                      });\n                      currentStream.pipe(stream);\n                      currentStream.resume();\n                    }).catch(closeStream);\n\n                  case 8:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this);\n          }));\n        });\n      };\n      /**\n       * Checks if the current target id is included in the list of target ids.\n       * If no targetIds are provided, returns true.\n       */\n\n\n      function affectsTarget(targetIds, currentId) {\n        if (targetIds === undefined || targetIds.length === 0) {\n          return true;\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = targetIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var targetId = _step.value;\n\n            if (targetId === currentId) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      }\n      /** Splits up document changes into removals, additions, and updates. */\n\n\n      function extractChanges(docMap, changes, readTime) {\n        var deletes = [];\n        var adds = [];\n        var updates = [];\n        changes.forEach(function (value, name) {\n          if (value === REMOVED) {\n            if (docMap.has(name)) {\n              deletes.push(name);\n            }\n          } else if (docMap.has(name)) {\n            value.readTime = readTime;\n            updates.push(value.build());\n          } else {\n            value.readTime = readTime;\n            adds.push(value.build());\n          }\n        });\n        return {\n          deletes: deletes,\n          adds: adds,\n          updates: updates\n        };\n      }\n      /**\n       * Applies the mutations in changeMap to both the document tree and the\n       * document lookup map. Modified docMap in-place and returns the updated\n       * state.\n       * @private\n       */\n\n\n      var computeSnapshot = function computeSnapshot(docTree, docMap, changes) {\n        var updatedTree = docTree;\n        var updatedMap = docMap;\n        assert(docTree.length === docMap.size, 'The document tree and document ' + 'map should have the same number of entries.');\n        /**\n         * Applies a document delete to the document tree and the document\n         * map. Returns the corresponding DocumentChange event.\n         * @private\n         */\n\n        function deleteDoc(name) {\n          assert(updatedMap.has(name), 'Document to delete does not exist');\n          var oldDocument = updatedMap.get(name);\n          var existing = updatedTree.find(oldDocument);\n          var oldIndex = existing.index;\n          updatedTree = existing.remove();\n          updatedMap.delete(name);\n          return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n        }\n        /**\n         * Applies a document add to the document tree and the document map.\n         * Returns the corresponding DocumentChange event.\n         * @private\n         */\n\n\n        function addDoc(newDocument) {\n          var name = newDocument.ref.path;\n          assert(!updatedMap.has(name), 'Document to add already exists');\n          updatedTree = updatedTree.insert(newDocument, null);\n          var newIndex = updatedTree.find(newDocument).index;\n          updatedMap.set(name, newDocument);\n          return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n        }\n        /**\n         * Applies a document modification to the document tree and the\n         * document map. Returns the DocumentChange event for successful\n         * modifications.\n         * @private\n         */\n\n\n        function modifyDoc(newDocument) {\n          var name = newDocument.ref.path;\n          assert(updatedMap.has(name), 'Document to modify does not exist');\n          var oldDocument = updatedMap.get(name);\n\n          if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n            var removeChange = deleteDoc(name);\n            var addChange = addDoc(newDocument);\n            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n          }\n\n          return null;\n        } // Process the sorted changes in the order that is expected by our\n        // clients (removals, additions, and then modifications). We also need\n        // to sort the individual changes to assure that oldIndex/newIndex\n        // keep incrementing.\n\n\n        var appliedChanges = [];\n        changes.deletes.sort(function (name1, name2) {\n          // Deletes are sorted based on the order of the existing document.\n          return _this.getComparator()(updatedMap.get(name1), updatedMap.get(name2));\n        });\n        changes.deletes.forEach(function (name) {\n          var change = deleteDoc(name);\n          appliedChanges.push(change);\n        });\n        changes.adds.sort(_this.getComparator());\n        changes.adds.forEach(function (snapshot) {\n          var change = addDoc(snapshot);\n          appliedChanges.push(change);\n        });\n        changes.updates.sort(_this.getComparator());\n        changes.updates.forEach(function (snapshot) {\n          var change = modifyDoc(snapshot);\n\n          if (change) {\n            appliedChanges.push(change);\n          }\n        });\n        assert(updatedTree.length === updatedMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n        return {\n          updatedTree: updatedTree,\n          updatedMap: updatedMap,\n          appliedChanges: appliedChanges\n        };\n      };\n      /**\n       * Assembles a new snapshot from the current set of changes and invokes the\n       * user's callback. Clears the current changes on completion.\n       */\n\n\n      var push = function push(readTime, nextResumeToken) {\n        var changes = extractChanges(docMap, changeMap, readTime);\n        var diff = computeSnapshot(docTree, docMap, changes);\n\n        if (!hasPushed || diff.appliedChanges.length > 0) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Sending snapshot with %d changes and %d documents', String(diff.appliedChanges.length), diff.updatedTree.length);\n          onNext(readTime, diff.updatedTree.length, function () {\n            return diff.updatedTree.keys;\n          }, function () {\n            return diff.appliedChanges;\n          });\n          hasPushed = true;\n        }\n\n        docTree = diff.updatedTree;\n        docMap = diff.updatedMap;\n        changeMap.clear();\n        resumeToken = nextResumeToken;\n      };\n      /**\n       * Returns the current count of all documents, including the changes from\n       * the current changeMap.\n       */\n\n\n      function currentSize() {\n        var changes = extractChanges(docMap, changeMap, timestamp_1.Timestamp.now());\n        return docMap.size + changes.adds.length - changes.deletes.length;\n      }\n\n      initStream();\n      stream.on('data', function (proto) {\n        if (proto.targetChange) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing target change');\n          var change = proto.targetChange;\n          var noTargetIds = !change.targetIds || change.targetIds.length === 0;\n\n          if (change.targetChangeType === 'NO_CHANGE') {\n            if (noTargetIds && change.readTime && current) {\n              // This means everything is up-to-date, so emit the current\n              // set of docs as a snapshot, if there were changes.\n              push(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n            }\n          } else if (change.targetChangeType === 'ADD') {\n            if (WATCH_TARGET_ID !== change.targetIds[0]) {\n              closeStream(Error('Unexpected target ID sent by server'));\n            }\n          } else if (change.targetChangeType === 'REMOVE') {\n            var code = 13;\n            var message = 'internal error';\n\n            if (change.cause) {\n              code = change.cause.code;\n              message = change.cause.message;\n            } // @todo: Surface a .code property on the exception.\n\n\n            closeStream(new Error('Error ' + code + ': ' + message));\n          } else if (change.targetChangeType === 'RESET') {\n            // Whatever changes have happened so far no longer matter.\n            resetDocs();\n          } else if (change.targetChangeType === 'CURRENT') {\n            current = true;\n          } else {\n            closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n          }\n\n          if (change.resumeToken && affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n            _this._backoff.reset();\n          }\n        } else if (proto.documentChange) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing change event'); // No other targetIds can show up here, but we still need to see\n          // if the targetId was in the added list or removed list.\n\n          var targetIds = proto.documentChange.targetIds || [];\n          var removedTargetIds = proto.documentChange.removedTargetIds || [];\n          var changed = false;\n          var removed = false;\n\n          for (var i = 0; i < targetIds.length; i++) {\n            if (targetIds[i] === WATCH_TARGET_ID) {\n              changed = true;\n            }\n          }\n\n          for (var _i = 0; _i < removedTargetIds.length; _i++) {\n            if (removedTargetIds[_i] === WATCH_TARGET_ID) {\n              removed = true;\n            }\n          }\n\n          var document = proto.documentChange.document;\n          var name = document.name;\n          var relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n\n          if (changed) {\n            logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Received document change');\n            var snapshot = new document_1.DocumentSnapshotBuilder();\n            snapshot.ref = _this._firestore.doc(relativeName);\n            snapshot.fieldsProto = document.fields || {};\n            snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n            snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n            changeMap.set(relativeName, snapshot);\n          } else if (removed) {\n            logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Received document remove');\n            changeMap.set(relativeName, REMOVED);\n          }\n        } else if (proto.documentDelete || proto.documentRemove) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing remove event');\n          var _name = (proto.documentDelete || proto.documentRemove).document;\n          var _relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(_name).relativeName;\n          changeMap.set(_relativeName, REMOVED);\n        } else if (proto.filter) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing filter update');\n\n          if (proto.filter.count !== currentSize()) {\n            // We need to remove all the current results.\n            resetDocs(); // The filter didn't match, so re-issue the query.\n\n            restartStream();\n          }\n        } else {\n          closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n        }\n      }).on('end', function () {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing stream end');\n\n        if (currentStream) {\n          // Pass the event on to the underlying stream.\n          currentStream.end();\n        }\n      });\n      return function () {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Ending stream'); // Prevent further callbacks.\n\n        isActive = false;\n\n        onNext = function onNext() {};\n\n        onError = function onError() {};\n\n        stream.end();\n      };\n    }\n  }]);\n\n  return Watch;\n}();\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\n\n\nvar DocumentWatch =\n/*#__PURE__*/\nfunction (_Watch) {\n  _inherits(DocumentWatch, _Watch);\n\n  function DocumentWatch(firestore, ref) {\n    var _this3;\n\n    _classCallCheck(this, DocumentWatch);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(DocumentWatch).call(this, firestore));\n    _this3.ref = ref;\n    return _this3;\n  }\n\n  _createClass(DocumentWatch, [{\n    key: \"getComparator\",\n    value: function getComparator() {\n      return DOCUMENT_WATCH_COMPARATOR;\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(resumeToken) {\n      var formattedName = this.ref.formattedName;\n      return {\n        documents: {\n          documents: [formattedName]\n        },\n        targetId: WATCH_TARGET_ID,\n        resumeToken: resumeToken\n      };\n    }\n  }]);\n\n  return DocumentWatch;\n}(Watch);\n\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\n\nvar QueryWatch =\n/*#__PURE__*/\nfunction (_Watch2) {\n  _inherits(QueryWatch, _Watch2);\n\n  function QueryWatch(firestore, query) {\n    var _this4;\n\n    _classCallCheck(this, QueryWatch);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(QueryWatch).call(this, firestore));\n    _this4.query = query;\n    _this4.comparator = query.comparator();\n    return _this4;\n  }\n\n  _createClass(QueryWatch, [{\n    key: \"getComparator\",\n    value: function getComparator() {\n      return this.query.comparator();\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(resumeToken) {\n      var query = this.query.toProto();\n      return {\n        query: query,\n        targetId: WATCH_TARGET_ID,\n        resumeToken: resumeToken\n      };\n    }\n  }]);\n\n  return QueryWatch;\n}(Watch);\n\nexports.QueryWatch = QueryWatch;","map":null,"metadata":{},"sourceType":"script"}