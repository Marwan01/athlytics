{"ast":null,"code":"/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client Interceptors\n *\n * This module describes the interceptor framework for clients.\n * An interceptor is a function which takes an options object and a nextCall\n * function and returns an InterceptingCall:\n *\n * ```\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options));\n * }\n * ```\n *\n * The interceptor function must return an InterceptingCall object. Returning\n * `new InterceptingCall(nextCall(options))` will satisfy the contract (but\n * provide no interceptor functionality). `nextCall` is a function which will\n * generate the next interceptor in the chain.\n *\n * To implement interceptor functionality, create a requester and pass it to\n * the InterceptingCall constructor:\n *\n * `return new InterceptingCall(nextCall(options), requester);`\n *\n * A requester is a POJO with zero or more of the following methods:\n *\n * `start(metadata, listener, next)`\n * * To continue, call next(metadata, listener). Listeners are described\n * * below.\n *\n * `sendMessage(message, next)`\n * * To continue, call next(message).\n *\n * `halfClose(next)`\n * * To continue, call next().\n *\n * `cancel(message, next)`\n * * To continue, call next().\n *\n * A listener is a POJO with one or more of the following methods:\n *\n * `onReceiveMetadata(metadata, next)`\n * * To continue, call next(metadata)\n *\n * `onReceiveMessage(message, next)`\n * * To continue, call next(message)\n *\n * `onReceiveStatus(status, next)`\n * * To continue, call next(status)\n *\n * A listener is provided by the requester's `start` method. The provided\n * listener implements all the inbound interceptor methods, which can be called\n * to short-circuit the gRPC call.\n *\n * Three usage patterns are supported for listeners:\n * 1) Pass the listener along without modification: `next(metadata, listener)`.\n *   In this case the interceptor declines to intercept any inbound operations.\n * 2) Create a new listener with one or more inbound interceptor methods and\n *   pass it to `next`. In this case the interceptor will fire on the inbound\n *   operations implemented in the new listener.\n * 3) Make direct inbound calls to the provided listener's methods. This\n *   short-circuits the interceptor stack.\n *\n * Do not modify the listener passed in. Either pass it along unmodified,\n * ignore it, or call methods on it to short-circuit the call.\n *\n * To intercept errors, implement the `onReceiveStatus` method and test for\n * `status.code !== grpc.status.OK`.\n *\n * To intercept trailers, examine `status.metadata` in the `onReceiveStatus`\n * method.\n *\n * This is a trivial implementation of all interceptor methods:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     start: function(metadata, listener, next) {\n *       next(metadata, {\n *         onReceiveMetadata: function (metadata, next) {\n *           next(metadata);\n *         },\n *         onReceiveMessage: function (message, next) {\n *           next(message);\n *         },\n *         onReceiveStatus: function (status, next) {\n *           next(status);\n *         },\n *       });\n *     },\n *     sendMessage: function(message, next) {\n *       next(message);\n *     },\n *     halfClose: function(next) {\n *       next();\n *     },\n *     cancel: function(message, next) {\n *       next();\n *     }\n *   });\n * };\n *\n * This is an interceptor with a single method:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     sendMessage: function(message, next) {\n *       next(message);\n *     }\n *   });\n * };\n *\n * Builders are provided for convenience: StatusBuilder, ListenerBuilder,\n * and RequesterBuilder\n *\n * gRPC client operations use this mapping to interceptor methods:\n *\n * grpc.opType.SEND_INITIAL_METADATA -> start\n * grpc.opType.SEND_MESSAGE -> sendMessage\n * grpc.opType.SEND_CLOSE_FROM_CLIENT -> halfClose\n * grpc.opType.RECV_INITIAL_METADATA -> onReceiveMetadata\n * grpc.opType.RECV_MESSAGE -> onReceiveMessage\n * grpc.opType.RECV_STATUS_ON_CLIENT -> onReceiveStatus\n *\n * @module\n */\n'use strict';\n\nvar _defineProperty = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _OP_DEPENDENCIES, _interceptorGenerator, _listenerGenerators;\n\nvar _ = require('lodash');\n\nvar grpc = require('./grpc_extension');\n\nvar Metadata = require('./metadata');\n\nvar constants = require('./constants');\n\nvar common = require('./common');\n\nvar methodTypes = constants.methodTypes;\n\nvar EventEmitter = require('events').EventEmitter;\n/**\n * A custom error thrown when interceptor configuration fails.\n * @param {string} message The error message\n * @param {object=} extra\n * @constructor\n */\n\n\nvar InterceptorConfigurationError = function InterceptorConfigurationError(message, extra) {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n  this.extra = extra;\n};\n\nrequire('util').inherits(InterceptorConfigurationError, Error);\n/**\n * A builder for gRPC status objects.\n * @constructor\n */\n\n\nfunction StatusBuilder() {\n  this.code = null;\n  this.details = null;\n  this.metadata = null;\n}\n/**\n * Adds a status code to the builder.\n * @param {number} code The status code.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withCode = function (code) {\n  this.code = code;\n  return this;\n};\n/**\n * Adds details to the builder.\n * @param {string} details A status message.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withDetails = function (details) {\n  this.details = details;\n  return this;\n};\n/**\n * Adds metadata to the builder.\n * @param {Metadata} metadata The gRPC status metadata.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withMetadata = function (metadata) {\n  this.metadata = metadata;\n  return this;\n};\n/**\n * Builds the status object.\n * @return {grpc~StatusObject} A gRPC status.\n */\n\n\nStatusBuilder.prototype.build = function () {\n  var status = {};\n\n  if (this.code !== undefined) {\n    status.code = this.code;\n  }\n\n  if (this.details) {\n    status.details = this.details;\n  }\n\n  if (this.metadata) {\n    status.metadata = this.metadata;\n  }\n\n  return status;\n};\n/**\n * A builder for listener interceptors.\n * @constructor\n */\n\n\nfunction ListenerBuilder() {\n  this.metadata = null;\n  this.message = null;\n  this.status = null;\n}\n/**\n * Adds an onReceiveMetadata method to the builder.\n * @param {MetadataListener} on_receive_metadata A listener method for\n * receiving metadata.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveMetadata = function (on_receive_metadata) {\n  this.metadata = on_receive_metadata;\n  return this;\n};\n/**\n * Adds an onReceiveMessage method to the builder.\n * @param {MessageListener} on_receive_message A listener method for receiving\n * messages.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveMessage = function (on_receive_message) {\n  this.message = on_receive_message;\n  return this;\n};\n/**\n * Adds an onReceiveStatus method to the builder.\n * @param {StatusListener} on_receive_status A listener method for receiving\n * status.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveStatus = function (on_receive_status) {\n  this.status = on_receive_status;\n  return this;\n};\n/**\n * Builds the call listener.\n * @return {grpc~Listener}\n */\n\n\nListenerBuilder.prototype.build = function () {\n  var self = this;\n  var listener = {};\n  listener.onReceiveMetadata = self.metadata;\n  listener.onReceiveMessage = self.message;\n  listener.onReceiveStatus = self.status;\n  return listener;\n};\n/**\n * A builder for the outbound methods of an interceptor.\n * @constructor\n */\n\n\nfunction RequesterBuilder() {\n  this.start = null;\n  this.message = null;\n  this.half_close = null;\n  this.cancel = null;\n}\n/**\n * Add a metadata requester to the builder.\n * @param {MetadataRequester} start A requester method for handling metadata.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withStart = function (start) {\n  this.start = start;\n  return this;\n};\n/**\n * Add a message requester to the builder.\n * @param {MessageRequester} send_message A requester method for handling\n * messages.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withSendMessage = function (send_message) {\n  this.message = send_message;\n  return this;\n};\n/**\n * Add a close requester to the builder.\n * @param {CloseRequester} half_close A requester method for handling client\n * close.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withHalfClose = function (half_close) {\n  this.half_close = half_close;\n  return this;\n};\n/**\n * Add a cancel requester to the builder.\n * @param {CancelRequester} cancel A requester method for handling `cancel`\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withCancel = function (cancel) {\n  this.cancel = cancel;\n  return this;\n};\n/**\n * Builds the requester's interceptor methods.\n * @return {grpc~Requester}\n */\n\n\nRequesterBuilder.prototype.build = function () {\n  var requester = {};\n  requester.start = this.start;\n  requester.sendMessage = this.message;\n  requester.halfClose = this.half_close;\n  requester.cancel = this.cancel;\n  return requester;\n};\n/**\n * Transforms a list of interceptor providers into interceptors.\n * @param {InterceptorProvider[]} providers\n * @param {grpc~MethodDefinition} method_definition\n * @return {null|Interceptor[]}\n */\n\n\nvar resolveInterceptorProviders = function resolveInterceptorProviders(providers, method_definition) {\n  if (!_.isArray(providers)) {\n    return null;\n  }\n\n  var interceptors = [];\n\n  for (var i = 0; i < providers.length; i++) {\n    var provider = providers[i];\n    var interceptor = provider(method_definition);\n\n    if (interceptor) {\n      interceptors.push(interceptor);\n    }\n  }\n\n  return interceptors;\n};\n/**\n * A chainable gRPC call proxy which will delegate to an optional requester\n * object. By default, interceptor methods will chain to next_call. If a\n * requester is provided which implements an interceptor method, that\n * requester method will be executed as part of the chain.\n * @param {InterceptingCall|null} next_call The next call in the chain\n * @param {grpc~Requester=} requester Interceptor methods to handle request\n * operations.\n * @constructor\n */\n\n\nfunction InterceptingCall(next_call, requester) {\n  this.next_call = next_call;\n  this.requester = requester;\n}\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain\n * @param {string} method_name\n * @return {function} The next method in the chain\n * @private\n */\n\n\nInterceptingCall.prototype._getNextCall = function (method_name) {\n  return this.next_call ? this.next_call[method_name].bind(this.next_call) : function () {};\n};\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingCall (next_call), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingCall's method\n * @return {null}\n * @private\n */\n\n\nInterceptingCall.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_call = next ? next : this._getNextCall(method_name);\n\n  if (this.requester && this.requester[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n\n    switch (num_args) {\n      case 0:\n        return this.requester[method_name](next_call);\n\n      case 1:\n        return this.requester[method_name](args_array[0], next_call);\n\n      case 2:\n        return this.requester[method_name](args_array[0], args_array[1], next_call);\n    }\n  } else {\n    return next_call(args_array[0], args_array[1]);\n  }\n};\n/**\n * Starts a call through the outbound interceptor chain and adds an element to\n * the reciprocal inbound listener chain.\n * @param {grpc.Metadata} metadata The outgoing metadata.\n * @param {grpc~Listener} listener An intercepting listener for inbound\n * operations.\n */\n\n\nInterceptingCall.prototype.start = function (metadata, listener) {\n  var self = this; // If the listener provided is an InterceptingListener, use it. Otherwise, we\n  // must be at the end of the listener chain, and any listener operations\n  // should be terminated in an EndListener.\n\n  var next_listener = _getInterceptingListener(listener, new EndListener()); // Build the next method in the interceptor chain\n\n\n  var next = function next(metadata, current_listener) {\n    // If there is a next call in the chain, run it. Otherwise do nothing.\n    if (self.next_call) {\n      // Wire together any listener provided with the next listener\n      var listener = _getInterceptingListener(current_listener, next_listener);\n\n      self.next_call.start(metadata, listener);\n    }\n  };\n\n  this._callNext('start', [metadata, next_listener], next);\n};\n/**\n * Pass a message through the interceptor chain.\n * @param {jspb.Message} message\n */\n\n\nInterceptingCall.prototype.sendMessage = function (message) {\n  this._callNext('sendMessage', [message]);\n};\n/**\n * Run a close operation through the interceptor chain\n */\n\n\nInterceptingCall.prototype.halfClose = function () {\n  this._callNext('halfClose');\n};\n/**\n * Run a cancel operation through the interceptor chain\n */\n\n\nInterceptingCall.prototype.cancel = function () {\n  this._callNext('cancel');\n};\n/**\n * Run a cancelWithStatus operation through the interceptor chain.\n * @param {grpc~StatusObject} status\n * @param {string} message\n */\n\n\nInterceptingCall.prototype.cancelWithStatus = function (status, message) {\n  this._callNext('cancelWithStatus', [status, message]);\n};\n/**\n * Pass a getPeer call down to the base gRPC call (should not be intercepted)\n * @return {object}\n */\n\n\nInterceptingCall.prototype.getPeer = function () {\n  return this._callNext('getPeer');\n};\n/**\n * For streaming calls, we need to transparently pass the stream's context\n * through the interceptor chain. Passes the context between InterceptingCalls\n * but hides it from any requester implementations.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message to send.\n */\n\n\nInterceptingCall.prototype.sendMessageWithContext = function (context, message) {\n  var next = this.next_call ? this.next_call.sendMessageWithContext.bind(this.next_call, context) : context;\n\n  this._callNext('sendMessage', [message], next);\n};\n/**\n * For receiving streaming messages, we need to seed the base interceptor with\n * the streaming context to create a RECV_MESSAGE batch.\n * @param {object} context Carries objects needed for streaming operations\n */\n\n\nInterceptingCall.prototype.recvMessageWithContext = function (context) {\n  this._callNext('recvMessageWithContext', [context]);\n};\n/**\n * A chain-able listener object which will delegate to a custom listener when\n * appropriate.\n * @param {InterceptingListener|null} next_listener The next\n * InterceptingListener in the chain\n * @param {grpc~Listener=} delegate A custom listener object which may implement\n * specific operations\n * @constructor\n */\n\n\nfunction InterceptingListener(next_listener, delegate) {\n  this.delegate = delegate || {};\n  this.next_listener = next_listener;\n}\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain.\n * @param {string} method_name The name of the listener method.\n * @return {function} The next method in the chain\n * @private\n */\n\n\nInterceptingListener.prototype._getNextListener = function (method_name) {\n  return this.next_listener ? this.next_listener[method_name].bind(this.next_listener) : function () {};\n};\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingListener (next_listener), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingListener's method\n * @return {null}\n * @private\n */\n\n\nInterceptingListener.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_listener = next ? next : this._getNextListener(method_name);\n\n  if (this.delegate && this.delegate[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n\n    switch (num_args) {\n      case 0:\n        return this.delegate[method_name](next_listener);\n\n      case 1:\n        return this.delegate[method_name](args_array[0], next_listener);\n\n      case 2:\n        return this.delegate[method_name](args_array[0], args_array[1], next_listener);\n    }\n  } else {\n    return next_listener(args_array[0], args_array[1]);\n  }\n};\n/**\n * Inbound metadata receiver.\n * @param {Metadata} metadata\n */\n\n\nInterceptingListener.prototype.onReceiveMetadata = function (metadata) {\n  this._callNext('onReceiveMetadata', [metadata]);\n};\n/**\n * Inbound message receiver.\n * @param {jspb.Message} message\n */\n\n\nInterceptingListener.prototype.onReceiveMessage = function (message) {\n  this._callNext('onReceiveMessage', [message]);\n};\n/**\n * When intercepting streaming message, we need to pass the streaming context\n * transparently along the chain. Hides the context from the delegate listener\n * methods.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message received.\n */\n\n\nInterceptingListener.prototype.recvMessageWithContext = function (context, message) {\n  var fallback = this.next_listener.recvMessageWithContext;\n  var next_method = this.next_listener ? fallback.bind(this.next_listener, context) : context;\n\n  if (this.delegate.onReceiveMessage) {\n    this.delegate.onReceiveMessage(message, next_method, context);\n  } else {\n    next_method(message);\n  }\n};\n/**\n * Inbound status receiver.\n * @param {grpc~StatusObject} status\n */\n\n\nInterceptingListener.prototype.onReceiveStatus = function (status) {\n  this._callNext('onReceiveStatus', [status]);\n};\n/**\n * A dead-end listener used to terminate a call chain. Used when an interceptor\n * creates a branch chain, when the branch returns the listener chain will\n * terminate here.\n * @constructor\n */\n\n\nfunction EndListener() {}\n\nEndListener.prototype.onReceiveMetadata = function () {};\n\nEndListener.prototype.onReceiveMessage = function () {};\n\nEndListener.prototype.onReceiveStatus = function () {};\n\nEndListener.prototype.recvMessageWithContext = function () {};\n/**\n * Get a call object built with the provided options.\n * @param {grpc.Channel} channel\n * @param {string} path\n * @param {grpc.Client~CallOptions=} options Options object.\n */\n\n\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = _.get(options, 'parent.call');\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n\n  var call = channel.createCall(path, deadline, host, parent, propagate_flags);\n\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n\n  return call;\n}\n\nvar OP_DEPENDENCIES = (_OP_DEPENDENCIES = {}, _defineProperty(_OP_DEPENDENCIES, grpc.opType.SEND_MESSAGE, [grpc.opType.SEND_INITIAL_METADATA]), _defineProperty(_OP_DEPENDENCIES, grpc.opType.SEND_CLOSE_FROM_CLIENT, [grpc.opType.SEND_MESSAGE]), _defineProperty(_OP_DEPENDENCIES, grpc.opType.RECV_MESSAGE, [grpc.opType.SEND_INITIAL_METADATA]), _OP_DEPENDENCIES);\n/**\n * Produces a callback triggered by streaming response messages.\n * @private\n * @param {EventEmitter} emitter\n * @param {grpc.internal~Call} call\n * @param {function} get_listener Returns a grpc~Listener.\n * @param {grpc~deserialize} deserialize\n * @return {Function}\n */\n\nfunction _getStreamReadCallback(emitter, call, get_listener, deserialize) {\n  return function (err, response) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      emitter.finished = true;\n\n      emitter._readsDone();\n\n      return;\n    }\n\n    var data = response.read;\n    var deserialized;\n\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      emitter._readsDone({\n        code: constants.status.INTERNAL,\n        details: 'Failed to parse server response'\n      });\n\n      return;\n    }\n\n    if (data === null) {\n      emitter._readsDone();\n\n      return;\n    }\n\n    var listener = get_listener();\n    var context = {\n      call: call,\n      listener: listener\n    };\n    listener.recvMessageWithContext(context, deserialized);\n  };\n}\n/**\n * Tests whether a batch can be started.\n * @private\n * @param {number[]} batch_ops The operations in the batch we are checking.\n * @param {number[]} completed_ops Previously completed operations.\n * @return {boolean}\n */\n\n\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = _.flatMap(batch_ops, function (op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n\n    if (batch_ops.indexOf(required_dep) === -1 && completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Enforces the order of operations for synchronous requests. If a batch's\n * operations cannot be started because required operations have not started\n * yet, the batch is deferred until requirements are met.\n * @private\n * @param {grpc.Client~Call} call\n * @param {object} batch\n * @param {object} batch_state\n * @param {number[]} [batch_state.completed_ops] The ops already sent.\n * @param {object} [batch_state.deferred_batches] Batches to be sent after\n *     their dependencies are fulfilled.\n * @param {function} callback\n * @return {object}\n */\n\n\nfunction _startBatchIfReady(call, batch, batch_state, callback) {\n  var completed_ops = batch_state.completed_ops;\n  var deferred_batches = batch_state.deferred_batches;\n\n  var batch_ops = _.map(_.keys(batch), Number);\n\n  if (_areBatchRequirementsMet(batch_ops, completed_ops)) {\n    // Dependencies are met, start the batch and any deferred batches whose\n    // dependencies are met as a result.\n    call.startBatch(batch, callback);\n    completed_ops = _.union(completed_ops, batch_ops);\n    deferred_batches = _.flatMap(deferred_batches, function (deferred_batch) {\n      var deferred_batch_ops = _.map(_.keys(deferred_batch), Number);\n\n      if (_areBatchRequirementsMet(deferred_batch_ops, completed_ops)) {\n        call.startBatch(deferred_batch.batch, deferred_batch.callback);\n        return [];\n      }\n\n      return [deferred_batch];\n    });\n  } else {\n    // Dependencies are not met, defer the batch\n    deferred_batches = deferred_batches.concat({\n      batch: batch,\n      callback: callback\n    });\n  }\n\n  return {\n    completed_ops: completed_ops,\n    deferred_batches: deferred_batches\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for unary calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\n\n\nfunction _getUnaryInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = method_definition.requestSerialize;\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var call = getCall(channel, method_definition.path, options);\n    var first_listener;\n    var final_requester = {};\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n\n    final_requester.start = function (metadata, listener) {\n      var batch = _defineProperty({}, grpc.opType.SEND_INITIAL_METADATA, metadata._getCoreRepresentation());\n\n      first_listener = listener;\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.sendMessage = function (message) {\n      var batch = _defineProperty({}, grpc.opType.SEND_MESSAGE, serialize(message));\n\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.halfClose = function () {\n      var _batch3;\n\n      var batch = (_batch3 = {}, _defineProperty(_batch3, grpc.opType.SEND_CLOSE_FROM_CLIENT, true), _defineProperty(_batch3, grpc.opType.RECV_INITIAL_METADATA, true), _defineProperty(_batch3, grpc.opType.RECV_MESSAGE, true), _defineProperty(_batch3, grpc.opType.RECV_STATUS_ON_CLIENT, true), _batch3);\n\n      var callback = function callback(err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              /* Change status to indicate bad server response. This\n               * will result in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        first_listener.onReceiveMetadata(response.metadata);\n        first_listener.onReceiveMessage(deserialized);\n        first_listener.onReceiveStatus(status);\n      };\n\n      batch_state = _startBatchIfReady(call, batch, batch_state, callback);\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for client streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\n\n\nfunction _getClientStreamingInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var first_listener;\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n\n    final_requester.start = function (metadata, listener) {\n      var _metadata_batch;\n\n      var metadata_batch = (_metadata_batch = {}, _defineProperty(_metadata_batch, grpc.opType.SEND_INITIAL_METADATA, metadata._getCoreRepresentation()), _defineProperty(_metadata_batch, grpc.opType.RECV_INITIAL_METADATA, true), _metadata_batch);\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_MESSAGE] = true;\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              /* Change status to indicate bad server response. This will result\n               * in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n\n        listener.onReceiveMessage(deserialized);\n        listener.onReceiveStatus(status);\n      });\n    };\n\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n\n      if (_.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n\n      var batch = _defineProperty({}, grpc.opType.SEND_MESSAGE, message);\n\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n\n    final_requester.halfClose = function () {\n      var batch = _defineProperty({}, grpc.opType.SEND_CLOSE_FROM_CLIENT, true);\n\n      call.startBatch(batch, function () {});\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for server streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\n\n\nfunction _getServerStreamingInterceptor(method_definition, channel, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  var serialize = method_definition.requestSerialize;\n  return function (options) {\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    var first_listener;\n\n    var get_listener = function get_listener() {\n      return first_listener;\n    };\n\n    final_requester.start = function (metadata, listener) {\n      var _metadata_batch2;\n\n      first_listener = listener;\n      metadata = metadata.clone();\n      var metadata_batch = (_metadata_batch2 = {}, _defineProperty(_metadata_batch2, grpc.opType.SEND_INITIAL_METADATA, metadata._getCoreRepresentation()), _defineProperty(_metadata_batch2, grpc.opType.RECV_INITIAL_METADATA, true), _metadata_batch2);\n\n      var callback = function callback(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        first_listener.onReceiveMetadata(Metadata._fromCoreRepresentation(response.metadata));\n      };\n\n      batch_state = _startBatchIfReady(call, metadata_batch, batch_state, callback);\n\n      var status_batch = _defineProperty({}, grpc.opType.RECV_STATUS_ON_CLIENT, true);\n\n      call.startBatch(status_batch, function (err, response) {\n        if (err) {\n          emitter.emit('error', err);\n          return;\n        }\n\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        first_listener.onReceiveStatus(response.status);\n      });\n    };\n\n    final_requester.sendMessage = function (argument) {\n      var message = serialize(argument);\n\n      if (options) {\n        message.grpcWriteFlags = options.flags;\n      }\n\n      var send_batch = _defineProperty({}, grpc.opType.SEND_MESSAGE, message);\n\n      var callback = function callback(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n      };\n\n      batch_state = _startBatchIfReady(call, send_batch, batch_state, callback);\n    };\n\n    final_requester.halfClose = function () {\n      var batch = _defineProperty({}, grpc.opType.SEND_CLOSE_FROM_CLIENT, true);\n\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = _defineProperty({}, grpc.opType.RECV_MESSAGE, true);\n\n      var callback = _getStreamReadCallback(emitter, call, get_listener, deserialize);\n\n      batch_state = _startBatchIfReady(call, recv_batch, batch_state, callback);\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for bi-directional\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\n\n\nfunction _getBidiStreamingInterceptor(method_definition, channel, emitter) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return function (options) {\n    var first_listener;\n\n    var get_listener = function get_listener() {\n      return first_listener;\n    };\n\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n\n    final_requester.start = function (metadata, listener) {\n      var _metadata_batch3;\n\n      var metadata_batch = (_metadata_batch3 = {}, _defineProperty(_metadata_batch3, grpc.opType.SEND_INITIAL_METADATA, metadata._getCoreRepresentation()), _defineProperty(_metadata_batch3, grpc.opType.RECV_INITIAL_METADATA, true), _metadata_batch3);\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        var status = response.status;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            emitter.emit('error', err);\n            return;\n          }\n        }\n\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        listener.onReceiveStatus(status);\n      });\n    };\n\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n\n      if (_.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n\n      var batch = _defineProperty({}, grpc.opType.SEND_MESSAGE, message);\n\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n\n    final_requester.halfClose = function () {\n      var batch = _defineProperty({}, grpc.opType.SEND_CLOSE_FROM_CLIENT, true);\n\n      call.startBatch(batch, function () {});\n    };\n\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = _defineProperty({}, grpc.opType.RECV_MESSAGE, true);\n\n      call.startBatch(recv_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces a listener for responding to callers of unary RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\n\n\nfunction _getUnaryListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function onReceiveMetadata(metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function onReceiveMessage(message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function onReceiveStatus(status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n\n      emitter.emit('status', status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of client streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\n\n\nfunction _getClientStreamingListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function onReceiveMetadata(metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function onReceiveMessage(message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function onReceiveStatus(status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n\n      emitter.emit('status', status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of server streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\n\n\nfunction _getServerStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function onReceiveMetadata(metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function onReceiveMessage(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n\n        var get_listener = function get_listener() {\n          return context.listener;\n        };\n\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function onReceiveStatus(status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of bi-directional RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\n\n\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function onReceiveMetadata(metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function onReceiveMessage(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n\n        var get_listener = function get_listener() {\n          return context.listener;\n        };\n\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function onReceiveStatus(status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\nvar interceptorGenerators = (_interceptorGenerator = {}, _defineProperty(_interceptorGenerator, methodTypes.UNARY, _getUnaryInterceptor), _defineProperty(_interceptorGenerator, methodTypes.CLIENT_STREAMING, _getClientStreamingInterceptor), _defineProperty(_interceptorGenerator, methodTypes.SERVER_STREAMING, _getServerStreamingInterceptor), _defineProperty(_interceptorGenerator, methodTypes.BIDI_STREAMING, _getBidiStreamingInterceptor), _interceptorGenerator);\nvar listenerGenerators = (_listenerGenerators = {}, _defineProperty(_listenerGenerators, methodTypes.UNARY, _getUnaryListener), _defineProperty(_listenerGenerators, methodTypes.CLIENT_STREAMING, _getClientStreamingListener), _defineProperty(_listenerGenerators, methodTypes.SERVER_STREAMING, _getServerStreamingListener), _defineProperty(_listenerGenerators, methodTypes.BIDI_STREAMING, _getBidiStreamingListener), _listenerGenerators);\n/**\n * Creates the last listener in an interceptor stack.\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function=} callback\n * @return {grpc~Listener}\n */\n\nfunction getLastListener(method_definition, emitter, callback) {\n  if (emitter instanceof Function) {\n    callback = emitter;\n\n    callback = function callback() {};\n  }\n\n  if (!(callback instanceof Function)) {\n    callback = function callback() {};\n  }\n\n  if (!(emitter instanceof EventEmitter && callback instanceof Function)) {\n    throw new Error('Argument mismatch in getLastListener');\n  }\n\n  var method_type = common.getMethodType(method_definition);\n  var generator = listenerGenerators[method_type];\n  return generator(method_definition, emitter, callback);\n}\n/**\n *\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Client~CallOptions} options\n * @param {Interceptor[]} interceptors\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n */\n\n\nfunction getInterceptingCall(method_definition, options, interceptors, channel, responder) {\n  var last_interceptor = _getLastInterceptor(method_definition, channel, responder);\n\n  var all_interceptors = interceptors.concat(last_interceptor);\n  return _buildChain(all_interceptors, options);\n}\n/**\n * Creates the last interceptor in an interceptor stack.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n * @return {Interceptor}\n */\n\n\nfunction _getLastInterceptor(method_definition, channel, responder) {\n  var callback = responder instanceof Function ? responder : function () {};\n  var emitter = responder instanceof EventEmitter ? responder : new EventEmitter();\n  var method_type = common.getMethodType(method_definition);\n  var generator = interceptorGenerators[method_type];\n  return generator(method_definition, channel, emitter, callback);\n}\n/**\n * Chain a list of interceptors together and return the first InterceptingCall.\n * @private\n * @param {Interceptor[]} interceptors An interceptor stack.\n * @param {grpc.Client~CallOptions} options Call options.\n * @return {InterceptingCall}\n */\n\n\nfunction _buildChain(interceptors, options) {\n  var next = function next(interceptors) {\n    if (interceptors.length === 0) {\n      return function (options) {};\n    }\n\n    var head_interceptor = interceptors[0];\n    var rest_interceptors = interceptors.slice(1);\n    return function (options) {\n      return head_interceptor(options, next(rest_interceptors));\n    };\n  };\n\n  var chain = next(interceptors)(options);\n  return new InterceptingCall(chain);\n}\n/**\n * Wraps a plain listener object in an InterceptingListener if it isn't an\n * InterceptingListener already.\n * @param {InterceptingListener|object|null} current_listener\n * @param {InterceptingListener|EndListener} next_listener\n * @return {InterceptingListener|null}\n * @private\n */\n\n\nfunction _getInterceptingListener(current_listener, next_listener) {\n  if (!_isInterceptingListener(current_listener)) {\n    return new InterceptingListener(next_listener, current_listener);\n  }\n\n  return current_listener;\n}\n/**\n * Test if the listener exists and is an InterceptingListener.\n * @param listener\n * @return {boolean}\n * @private\n */\n\n\nfunction _isInterceptingListener(listener) {\n  return listener && listener.constructor.name === 'InterceptingListener';\n}\n\nexports.resolveInterceptorProviders = resolveInterceptorProviders;\nexports.InterceptingCall = InterceptingCall;\nexports.ListenerBuilder = ListenerBuilder;\nexports.RequesterBuilder = RequesterBuilder;\nexports.StatusBuilder = StatusBuilder;\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nexports.getInterceptingCall = getInterceptingCall;\nexports.getLastListener = getLastListener;","map":null,"metadata":{},"sourceType":"script"}