{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar jws = require(\"jws\");\n\nvar LRU = require(\"lru-cache\");\n\nvar messages = require(\"../messages\");\n\nvar DEFAULT_HEADER = {\n  alg: 'RS256',\n  typ: 'JWT'\n};\n\nvar JWTAccess =\n/*#__PURE__*/\nfunction () {\n  /**\n   * JWTAccess service account credentials.\n   *\n   * Create a new access token by using the credential to create a new JWT token\n   * that's recognized as the access token.\n   *\n   * @param email the service account email address.\n   * @param key the private key that will be used to sign the token.\n   * @param keyId the ID of the private key used to sign the token.\n   */\n  function JWTAccess(email, key, keyId) {\n    _classCallCheck(this, JWTAccess);\n\n    this.cache = new LRU({\n      max: 500,\n      maxAge: 60 * 60 * 1000\n    });\n    this.email = email;\n    this.key = key;\n    this.keyId = keyId;\n  }\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createdScoped before use.\n   * @deprecated\n   * @return always false\n   */\n\n\n  _createClass(JWTAccess, [{\n    key: \"createScopedRequired\",\n    value: function createScopedRequired() {\n      // JWT Header authentication does not use scopes.\n      messages.warn(messages.JWT_ACCESS_CREATE_SCOPED_DEPRECATED);\n      return false;\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param authURI The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @deprecated Please use `getRequestHeaders` instead.\n     * @returns An object that includes the authorization header.\n     */\n\n  }, {\n    key: \"getRequestMetadata\",\n    value: function getRequestMetadata(url, additionalClaims) {\n      messages.warn(messages.JWT_ACCESS_GET_REQUEST_METADATA_DEPRECATED);\n      return {\n        headers: this.getRequestHeaders(url, additionalClaims)\n      };\n    }\n    /**\n     * Get a non-expired access token, after refreshing if necessary.\n     *\n     * @param url The URI being authorized.\n     * @param additionalClaims An object with a set of additional claims to\n     * include in the payload.\n     * @returns An object that includes the authorization header.\n     */\n\n  }, {\n    key: \"getRequestHeaders\",\n    value: function getRequestHeaders(url, additionalClaims) {\n      var cachedToken = this.cache.get(url);\n\n      if (cachedToken) {\n        return cachedToken;\n      }\n\n      var iat = Math.floor(new Date().getTime() / 1000);\n      var exp = iat + 3600; // 3600 seconds = 1 hour\n      // The payload used for signed JWT headers has:\n      // iss == sub == <client email>\n      // aud == <the authorization uri>\n\n      var defaultClaims = {\n        iss: this.email,\n        sub: this.email,\n        aud: url,\n        exp: exp,\n        iat: iat\n      }; // if additionalClaims are provided, ensure they do not collide with\n      // other required claims.\n\n      if (additionalClaims) {\n        for (var claim in defaultClaims) {\n          if (additionalClaims[claim]) {\n            throw new Error(\"The '\".concat(claim, \"' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.\"));\n          }\n        }\n      }\n\n      var header = this.keyId ? Object.assign({}, DEFAULT_HEADER, {\n        kid: this.keyId\n      }) : DEFAULT_HEADER;\n      var payload = Object.assign(defaultClaims, additionalClaims); // Sign the jwt and add it to the cache\n\n      var signedJWT = jws.sign({\n        header: header,\n        payload: payload,\n        secret: this.key\n      });\n      var headers = {\n        Authorization: \"Bearer \".concat(signedJWT)\n      };\n      this.cache.set(url, headers);\n      return headers;\n    }\n    /**\n     * Create a JWTAccess credentials instance using the given input options.\n     * @param json The input object.\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      if (!json) {\n        throw new Error('Must pass in a JSON object containing the service account auth settings.');\n      }\n\n      if (!json.client_email) {\n        throw new Error('The incoming JSON object does not contain a client_email field');\n      }\n\n      if (!json.private_key) {\n        throw new Error('The incoming JSON object does not contain a private_key field');\n      } // Extract the relevant information from the json key file.\n\n\n      this.email = json.client_email;\n      this.key = json.private_key;\n      this.keyId = json.private_key_id;\n      this.projectId = json.project_id;\n    }\n  }, {\n    key: \"fromStream\",\n    value: function fromStream(inputStream, callback) {\n      if (callback) {\n        this.fromStreamAsync(inputStream).then(function (r) {\n          return callback();\n        }, callback);\n      } else {\n        return this.fromStreamAsync(inputStream);\n      }\n    }\n  }, {\n    key: \"fromStreamAsync\",\n    value: function fromStreamAsync(inputStream) {\n      var _this = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!inputStream) {\n          reject(new Error('Must pass in a stream containing the service account auth settings.'));\n        }\n\n        var s = '';\n        inputStream.setEncoding('utf8').on('data', function (chunk) {\n          return s += chunk;\n        }).on('error', reject).on('end', function () {\n          try {\n            var data = JSON.parse(s);\n\n            _this.fromJSON(data);\n\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      });\n    }\n  }]);\n\n  return JWTAccess;\n}();\n\nexports.JWTAccess = JWTAccess;","map":null,"metadata":{},"sourceType":"script"}