{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nvar _defineProperty = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar grpc = require(\"grpc\");\n\nvar channel_ref_1 = require(\"./channel_ref\");\n\nvar CLIENT_CHANNEL_ID = 'grpc_gcp.client_channel.id';\n/**\n * A channel management factory that implements grpc.Channel APIs.\n */\n\nvar GcpChannelFactory =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param address The address of the server to connect to.\n   * @param credentials Channel credentials to use when connecting\n   * @param options A map of channel options.\n   */\n  function GcpChannelFactory(address, credentials, // tslint:disable-next-line:no-any options can be any object\n  options) {\n    _classCallCheck(this, GcpChannelFactory);\n\n    this.methodToAffinity = {};\n    this.affinityKeyToChannelRef = {};\n    this.channelRefs = [];\n\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options !== 'object') {\n      throw new TypeError('Channel options must be an object with string keys and integer or string values');\n    }\n\n    this.maxSize = 10;\n    this.maxConcurrentStreamsLowWatermark = 100;\n    var gcpApiConfig = options.gcpApiConfig;\n\n    if (gcpApiConfig) {\n      if (gcpApiConfig.channelPool) {\n        var channelPool = gcpApiConfig.channelPool;\n        if (channelPool.maxSize) this.maxSize = channelPool.maxSize;\n\n        if (channelPool.maxConcurrentStreamsLowWatermark) {\n          this.maxConcurrentStreamsLowWatermark = channelPool.maxConcurrentStreamsLowWatermark;\n        }\n      }\n\n      this.initMethodToAffinityMap(gcpApiConfig);\n    }\n\n    delete options.gcpApiConfig;\n    this.options = options;\n    this.target = address;\n    this.credentials = credentials; // Initialize channel in the pool to avoid empty pool.\n\n    this.getChannelRef();\n  }\n\n  _createClass(GcpChannelFactory, [{\n    key: \"initMethodToAffinityMap\",\n    value: function initMethodToAffinityMap(gcpApiConfig) {\n      var methodList = gcpApiConfig.method;\n\n      if (methodList) {\n        for (var i = 0; i < methodList.length; i++) {\n          var method = methodList[i];\n          var nameList = method.name;\n\n          if (nameList) {\n            for (var j = 0; j < nameList.length; j++) {\n              var methodName = nameList[j];\n\n              if (method.affinity) {\n                this.methodToAffinity[methodName] = method.affinity;\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Picks a grpc channel from the pool and wraps it with ChannelRef.\n     * @param affinityKey Affinity key to get the bound channel.\n     * @return Wrapper containing the grpc channel.\n     */\n\n  }, {\n    key: \"getChannelRef\",\n    value: function getChannelRef(affinityKey) {\n      if (affinityKey && this.affinityKeyToChannelRef[affinityKey]) {\n        // Chose an bound channel if affinityKey is specified.\n        return this.affinityKeyToChannelRef[affinityKey];\n      } // Sort channel refs by active streams count.\n\n\n      this.channelRefs.sort(function (ref1, ref2) {\n        return ref1.getActiveStreamsCount() - ref2.getActiveStreamsCount();\n      });\n      var size = this.channelRefs.length; // Chose the channelRef that has the least busy channel.\n\n      if (size > 0 && this.channelRefs[0].getActiveStreamsCount() < this.maxConcurrentStreamsLowWatermark) {\n        return this.channelRefs[0];\n      } // If all existing channels are busy, and channel pool still has capacity,\n      // create a new channel in the pool.\n\n\n      if (size < this.maxSize) {\n        var channelOptions = Object.assign(_defineProperty({}, CLIENT_CHANNEL_ID, size), this.options);\n        var grpcChannel = new grpc.Channel(this.target, this.credentials, channelOptions);\n        var channelRef = new channel_ref_1.ChannelRef(grpcChannel, size);\n        this.channelRefs.push(channelRef);\n        return channelRef;\n      } else {\n        return this.channelRefs[0];\n      }\n    }\n    /**\n     * Get AffinityConfig associated with a certain method.\n     * @param methodName Method name of the request.\n     */\n\n  }, {\n    key: \"getAffinityConfig\",\n    value: function getAffinityConfig(methodName) {\n      return this.methodToAffinity[methodName];\n    }\n    /**\n     * Bind channel with affinity key.\n     * @param channelRef ChannelRef instance that contains the grpc channel.\n     * @param affinityKey The affinity key used for binding the channel.\n     */\n\n  }, {\n    key: \"bind\",\n    value: function bind(channelRef, affinityKey) {\n      if (!affinityKey || !channelRef) return;\n      var existingChannelRef = this.affinityKeyToChannelRef[affinityKey];\n\n      if (!existingChannelRef) {\n        this.affinityKeyToChannelRef[affinityKey] = channelRef;\n      }\n\n      this.affinityKeyToChannelRef[affinityKey].affinityCountIncr();\n    }\n    /**\n     * Unbind channel with affinity key.\n     * @param boundKey Affinity key bound to a channel.\n     */\n\n  }, {\n    key: \"unbind\",\n    value: function unbind(boundKey) {\n      if (!boundKey) return;\n      var boundChannelRef = this.affinityKeyToChannelRef[boundKey];\n\n      if (boundChannelRef) {\n        boundChannelRef.affinityCountDecr();\n\n        if (boundChannelRef.getAffinityCount() <= 0) {\n          delete this.affinityKeyToChannelRef[boundKey];\n        }\n      }\n    }\n    /**\n     * Close all channels in the channel pool.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.channelRefs.forEach(function (ref) {\n        ref.getChannel().close();\n      });\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return this.target;\n    }\n    /**\n     * Get the current connectivity state of the channel pool.\n     * @param tryToConnect If true, the channel will start connecting if it is\n     *     idle. Otherwise, idle channels will only start connecting when a\n     *     call starts.\n     * @return connectivity state of channel pool.\n     */\n\n  }, {\n    key: \"getConnectivityState\",\n    value: function getConnectivityState(tryToConnect) {\n      var ready = 0;\n      var idle = 0;\n      var connecting = 0;\n      var transientFailure = 0;\n      var shutdown = 0;\n\n      for (var i = 0; i < this.channelRefs.length; i++) {\n        var grpcChannel = this.channelRefs[i].getChannel();\n        var state = grpcChannel.getConnectivityState(tryToConnect);\n\n        switch (state) {\n          case grpc.connectivityState.READY:\n            ready++;\n            break;\n\n          case grpc.connectivityState.SHUTDOWN:\n            shutdown++;\n            break;\n\n          case grpc.connectivityState.TRANSIENT_FAILURE:\n            transientFailure++;\n            break;\n\n          case grpc.connectivityState.CONNECTING:\n            connecting++;\n            break;\n\n          case grpc.connectivityState.IDLE:\n            idle++;\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      if (ready > 0) {\n        return grpc.connectivityState.READY;\n      } else if (connecting > 0) {\n        return grpc.connectivityState.CONNECTING;\n      } else if (transientFailure > 0) {\n        return grpc.connectivityState.TRANSIENT_FAILURE;\n      } else if (idle > 0) {\n        return grpc.connectivityState.IDLE;\n      } else if (shutdown > 0) {\n        return grpc.connectivityState.SHUTDOWN;\n      }\n\n      throw new Error('Cannot get connectivity state because no channel provides valid state.');\n    }\n    /**\n     * Watch for connectivity state changes. Currently This function will throw\n     * not implemented error because the implementation requires lot of work but\n     * has little use cases.\n     * @param currentState The state to watch for transitions from. This should\n     *     always be populated by calling getConnectivityState immediately before.\n     * @param deadline A deadline for waiting for a state change\n     * @param callback Called with no error when the state changes, or with an\n     *     error if the deadline passes without a state change\n     */\n\n  }, {\n    key: \"watchConnectivityState\",\n    value: function watchConnectivityState(currentState, deadline, callback) {\n      throw new Error('Function watchConnectivityState not implemented!');\n    }\n    /**\n     * Create a call object. This function will not be called when using\n     * grpc.Client class. But since it's a public function of grpc.Channel,\n     * It needs to be implemented for potential use cases.\n     * @param method The full method string to request.\n     * @param deadline The call deadline.\n     * @param host A host string override for making the request.\n     * @param parentCall A server call to propagate some information from.\n     * @param propagateFlags A bitwise combination of elements of\n     *     {@link grpc.propagate} that indicates what information to propagate\n     *     from parentCall.\n     * @return a grpc call object.\n     */\n\n  }, {\n    key: \"createCall\",\n    value: function createCall(method, deadline, host, parentCall, propagateFlags) {\n      var grpcChannel = this.getChannelRef().getChannel();\n      return grpcChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n    }\n  }]);\n\n  return GcpChannelFactory;\n}();\n\nexports.GcpChannelFactory = GcpChannelFactory;","map":null,"metadata":{},"sourceType":"script"}