{"ast":null,"code":"\"use strict\";\n\nmodule.exports = MapField; // extends Field\n\nvar Field = require(\"./field\");\n\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\n\nvar types = require(\"./types\"),\n    util = require(\"./util\");\n/**\r\n * Constructs a new map field instance.\r\n * @classdesc Reflected map field.\r\n * @extends FieldBase\r\n * @constructor\r\n * @param {string} name Unique name within its namespace\r\n * @param {number} id Unique id within its namespace\r\n * @param {string} keyType Key type\r\n * @param {string} type Value type\r\n * @param {Object.<string,*>} [options] Declared options\r\n * @param {string} [comment] Comment associated with this field\r\n */\n\n\nfunction MapField(name, id, keyType, type, options, comment) {\n  Field.call(this, name, id, type, undefined, undefined, options, comment);\n  /* istanbul ignore if */\n\n  if (!util.isString(keyType)) throw TypeError(\"keyType must be a string\");\n  /**\r\n   * Key type.\r\n   * @type {string}\r\n   */\n\n  this.keyType = keyType; // toJSON, marker\n\n  /**\r\n   * Resolved key type if not a basic type.\r\n   * @type {ReflectionObject|null}\r\n   */\n\n  this.resolvedKeyType = null; // Overrides Field#map\n\n  this.map = true;\n}\n/**\r\n * Map field descriptor.\r\n * @interface IMapField\r\n * @extends {IField}\r\n * @property {string} keyType Key type\r\n */\n\n/**\r\n * Extension map field descriptor.\r\n * @interface IExtensionMapField\r\n * @extends IMapField\r\n * @property {string} extend Extended type\r\n */\n\n/**\r\n * Constructs a map field from a map field descriptor.\r\n * @param {string} name Field name\r\n * @param {IMapField} json Map field descriptor\r\n * @returns {MapField} Created map field\r\n * @throws {TypeError} If arguments are invalid\r\n */\n\n\nMapField.fromJSON = function fromJSON(name, json) {\n  return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n/**\r\n * Converts this map field to a map field descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IMapField} Map field descriptor\r\n */\n\n\nMapField.prototype.toJSON = function toJSON(toJSONOptions) {\n  var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n  return util.toObject([\"keyType\", this.keyType, \"type\", this.type, \"id\", this.id, \"extend\", this.extend, \"options\", this.options, \"comment\", keepComments ? this.comment : undefined]);\n};\n/**\r\n * @override\r\n */\n\n\nMapField.prototype.resolve = function resolve() {\n  if (this.resolved) return this; // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n\n  if (types.mapKey[this.keyType] === undefined) throw Error(\"invalid key type: \" + this.keyType);\n  return Field.prototype.resolve.call(this);\n};\n/**\r\n * Map field decorator (TypeScript).\r\n * @name MapField.d\r\n * @function\r\n * @param {number} fieldId Field id\r\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\r\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\r\n * @returns {FieldDecorator} Decorator function\r\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\r\n */\n\n\nMapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n  // submessage value: decorate the submessage and use its name as the type\n  if (typeof fieldValueType === \"function\") fieldValueType = util.decorateType(fieldValueType).name; // enum reference value: create a reflected copy of the enum and keep reuseing it\n  else if (fieldValueType && typeof fieldValueType === \"object\") fieldValueType = util.decorateEnum(fieldValueType).name;\n  return function mapFieldDecorator(prototype, fieldName) {\n    util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n  };\n};","map":null,"metadata":{},"sourceType":"script"}