{"ast":null,"code":"\"use strict\";\n\nvar $protobuf = require(\"../..\");\n\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(require(\"../../google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace,\n    Root = $protobuf.Root,\n    Enum = $protobuf.Enum,\n    Type = $protobuf.Type,\n    Field = $protobuf.Field,\n    MapField = $protobuf.MapField,\n    OneOf = $protobuf.OneOf,\n    Service = $protobuf.Service,\n    Method = $protobuf.Method; // --- Root ---\n\n/**\r\n * Properties of a FileDescriptorSet message.\r\n * @interface IFileDescriptorSet\r\n * @property {IFileDescriptorProto[]} file Files\r\n */\n\n/**\r\n * Properties of a FileDescriptorProto message.\r\n * @interface IFileDescriptorProto\r\n * @property {string} [name] File name\r\n * @property {string} [package] Package\r\n * @property {*} [dependency] Not supported\r\n * @property {*} [publicDependency] Not supported\r\n * @property {*} [weakDependency] Not supported\r\n * @property {IDescriptorProto[]} [messageType] Nested message types\r\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\r\n * @property {IServiceDescriptorProto[]} [service] Nested services\r\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\r\n * @property {IFileOptions} [options] Options\r\n * @property {*} [sourceCodeInfo] Not supported\r\n * @property {string} [syntax=\"proto2\"] Syntax\r\n */\n\n/**\r\n * Properties of a FileOptions message.\r\n * @interface IFileOptions\r\n * @property {string} [javaPackage]\r\n * @property {string} [javaOuterClassname]\r\n * @property {boolean} [javaMultipleFiles]\r\n * @property {boolean} [javaGenerateEqualsAndHash]\r\n * @property {boolean} [javaStringCheckUtf8]\r\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\r\n * @property {string} [goPackage]\r\n * @property {boolean} [ccGenericServices]\r\n * @property {boolean} [javaGenericServices]\r\n * @property {boolean} [pyGenericServices]\r\n * @property {boolean} [deprecated]\r\n * @property {boolean} [ccEnableArenas]\r\n * @property {string} [objcClassPrefix]\r\n * @property {string} [csharpNamespace]\r\n */\n\n/**\r\n * Values of he FileOptions.OptimizeMode enum.\r\n * @typedef IFileOptionsOptimizeMode\r\n * @type {number}\r\n * @property {number} SPEED=1\r\n * @property {number} CODE_SIZE=2\r\n * @property {number} LITE_RUNTIME=3\r\n */\n\n/**\r\n * Creates a root from a descriptor set.\r\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Root} Root instance\r\n */\n\nRoot.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n  var root = new Root();\n\n  if (descriptor.file) {\n    var fileDescriptor, filePackage;\n\n    for (var j = 0, i; j < descriptor.file.length; ++j) {\n      filePackage = root;\n      if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n      if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n      if (fileDescriptor.messageType) for (i = 0; i < fileDescriptor.messageType.length; ++i) {\n        filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));\n      }\n      if (fileDescriptor.enumType) for (i = 0; i < fileDescriptor.enumType.length; ++i) {\n        filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));\n      }\n      if (fileDescriptor.extension) for (i = 0; i < fileDescriptor.extension.length; ++i) {\n        filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));\n      }\n      if (fileDescriptor.service) for (i = 0; i < fileDescriptor.service.length; ++i) {\n        filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));\n      }\n      var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n\n      if (opts) {\n        var ks = Object.keys(opts);\n\n        for (i = 0; i < ks.length; ++i) {\n          filePackage.setOption(ks[i], opts[ks[i]]);\n        }\n      }\n    }\n  }\n\n  return root;\n};\n/**\r\n * Converts a root to a descriptor set.\r\n * @returns {Message<IFileDescriptorSet>} Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n */\n\n\nRoot.prototype.toDescriptor = function toDescriptor(syntax) {\n  var set = exports.FileDescriptorSet.create();\n  Root_toDescriptorRecursive(this, set.file, syntax);\n  return set;\n}; // Traverses a namespace and assembles the descriptor set\n\n\nfunction Root_toDescriptorRecursive(ns, files, syntax) {\n  // Create a new file\n  var file = exports.FileDescriptorProto.create({\n    name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n  });\n  if (syntax) file.syntax = syntax;\n  if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1); // Add nested types\n\n  for (var i = 0, nested; i < ns.nestedArray.length; ++i) {\n    if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(syntax));else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());else if (nested instanceof Field) file.extension.push(nested.toDescriptor(syntax));else if (nested instanceof Service) file.service.push(nested.toDescriptor());else if (nested instanceof\n    /* plain */\n    Namespace) Root_toDescriptorRecursive(nested, files, syntax);\n  } // requires new file\n  // Keep package-level options\n\n\n  file.options = toDescriptorOptions(ns.options, exports.FileOptions); // And keep the file only if there is at least one nested object\n\n  if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n} // --- Type ---\n\n/**\r\n * Properties of a DescriptorProto message.\r\n * @interface IDescriptorProto\r\n * @property {string} [name] Message type name\r\n * @property {IFieldDescriptorProto[]} [field] Fields\r\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\r\n * @property {IDescriptorProto[]} [nestedType] Nested message types\r\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\r\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\r\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\r\n * @property {IMessageOptions} [options] Not supported\r\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\r\n * @property {string[]} [reservedName] Reserved names\r\n */\n\n/**\r\n * Properties of a MessageOptions message.\r\n * @interface IMessageOptions\r\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\r\n */\n\n/**\r\n * Properties of an ExtensionRange message.\r\n * @interface IDescriptorProtoExtensionRange\r\n * @property {number} [start] Start field id\r\n * @property {number} [end] End field id\r\n */\n\n/**\r\n * Properties of a ReservedRange message.\r\n * @interface IDescriptorProtoReservedRange\r\n * @property {number} [start] Start field id\r\n * @property {number} [end] End field id\r\n */\n\n\nvar unnamedMessageIndex = 0;\n/**\r\n * Creates a type from a descriptor.\r\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n * @returns {Type} Type instance\r\n */\n\nType.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor); // Create the message type\n\n  var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)),\n      i;\n  /* Oneofs */\n\n  if (descriptor.oneofDecl) for (i = 0; i < descriptor.oneofDecl.length; ++i) {\n    type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n  }\n  /* Fields */\n\n  if (descriptor.field) for (i = 0; i < descriptor.field.length; ++i) {\n    var field = Field.fromDescriptor(descriptor.field[i], syntax);\n    type.add(field);\n    if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) // eslint-disable-line no-prototype-builtins\n      type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n  }\n  /* Extension fields */\n\n  if (descriptor.extension) for (i = 0; i < descriptor.extension.length; ++i) {\n    type.add(Field.fromDescriptor(descriptor.extension[i], syntax));\n  }\n  /* Nested types */\n\n  if (descriptor.nestedType) for (i = 0; i < descriptor.nestedType.length; ++i) {\n    type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));\n    if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n  }\n  /* Nested enums */\n\n  if (descriptor.enumType) for (i = 0; i < descriptor.enumType.length; ++i) {\n    type.add(Enum.fromDescriptor(descriptor.enumType[i]));\n  }\n  /* Extension ranges */\n\n  if (descriptor.extensionRange && descriptor.extensionRange.length) {\n    type.extensions = [];\n\n    for (i = 0; i < descriptor.extensionRange.length; ++i) {\n      type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);\n    }\n  }\n  /* Reserved... */\n\n\n  if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n    type.reserved = [];\n    /* Ranges */\n\n    if (descriptor.reservedRange) for (i = 0; i < descriptor.reservedRange.length; ++i) {\n      type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);\n    }\n    /* Names */\n\n    if (descriptor.reservedName) for (i = 0; i < descriptor.reservedName.length; ++i) {\n      type.reserved.push(descriptor.reservedName[i]);\n    }\n  }\n\n  return type;\n};\n/**\r\n * Converts a type to a descriptor.\r\n * @returns {Message<IDescriptorProto>} Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n */\n\n\nType.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.DescriptorProto.create({\n    name: this.name\n  }),\n      i;\n  /* Fields */\n\n  for (i = 0; i < this.fieldsArray.length; ++i) {\n    var fieldDescriptor;\n    descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));\n\n    if (this._fieldsArray[i] instanceof MapField) {\n      // map fields are repeated FieldNameEntry\n      var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType),\n          valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType),\n          valueTypeName = valueType ===\n      /* type */\n      11 || valueType ===\n      /* enum */\n      14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n      descriptor.nestedType.push(exports.DescriptorProto.create({\n        name: fieldDescriptor.typeName,\n        field: [exports.FieldDescriptorProto.create({\n          name: \"key\",\n          number: 1,\n          label: 1,\n          type: keyType\n        }), // can't reference a type or enum\n        exports.FieldDescriptorProto.create({\n          name: \"value\",\n          number: 2,\n          label: 1,\n          type: valueType,\n          typeName: valueTypeName\n        })],\n        options: exports.MessageOptions.create({\n          mapEntry: true\n        })\n      }));\n    }\n  }\n  /* Oneofs */\n\n\n  for (i = 0; i < this.oneofsArray.length; ++i) {\n    descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n  }\n  /* Nested... */\n\n\n  for (i = 0; i < this.nestedArray.length; ++i) {\n    /* Extension fields */\n    if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));\n    /* Types */\n    else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));\n      /* Enums */\n      else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor()); // plain nested namespaces become packages instead in Root#toDescriptor\n  }\n  /* Extension ranges */\n\n\n  if (this.extensions) for (i = 0; i < this.extensions.length; ++i) {\n    descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n      start: this.extensions[i][0],\n      end: this.extensions[i][1]\n    }));\n  }\n  /* Reserved... */\n\n  if (this.reserved) for (i = 0; i < this.reserved.length; ++i) {\n    /* Names */\n    if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n    /* Ranges */\n    else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n        start: this.reserved[i][0],\n        end: this.reserved[i][1]\n      }));\n  }\n  descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n  return descriptor;\n}; // --- Field ---\n\n/**\r\n * Properties of a FieldDescriptorProto message.\r\n * @interface IFieldDescriptorProto\r\n * @property {string} [name] Field name\r\n * @property {number} [number] Field id\r\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\r\n * @property {IFieldDescriptorProtoType} [type] Field basic type\r\n * @property {string} [typeName] Field type name\r\n * @property {string} [extendee] Extended type name\r\n * @property {string} [defaultValue] Literal default value\r\n * @property {number} [oneofIndex] Oneof index if part of a oneof\r\n * @property {*} [jsonName] Not supported\r\n * @property {IFieldOptions} [options] Field options\r\n */\n\n/**\r\n * Values of the FieldDescriptorProto.Label enum.\r\n * @typedef IFieldDescriptorProtoLabel\r\n * @type {number}\r\n * @property {number} LABEL_OPTIONAL=1\r\n * @property {number} LABEL_REQUIRED=2\r\n * @property {number} LABEL_REPEATED=3\r\n */\n\n/**\r\n * Values of the FieldDescriptorProto.Type enum.\r\n * @typedef IFieldDescriptorProtoType\r\n * @type {number}\r\n * @property {number} TYPE_DOUBLE=1\r\n * @property {number} TYPE_FLOAT=2\r\n * @property {number} TYPE_INT64=3\r\n * @property {number} TYPE_UINT64=4\r\n * @property {number} TYPE_INT32=5\r\n * @property {number} TYPE_FIXED64=6\r\n * @property {number} TYPE_FIXED32=7\r\n * @property {number} TYPE_BOOL=8\r\n * @property {number} TYPE_STRING=9\r\n * @property {number} TYPE_GROUP=10\r\n * @property {number} TYPE_MESSAGE=11\r\n * @property {number} TYPE_BYTES=12\r\n * @property {number} TYPE_UINT32=13\r\n * @property {number} TYPE_ENUM=14\r\n * @property {number} TYPE_SFIXED32=15\r\n * @property {number} TYPE_SFIXED64=16\r\n * @property {number} TYPE_SINT32=17\r\n * @property {number} TYPE_SINT64=18\r\n */\n\n/**\r\n * Properties of a FieldOptions message.\r\n * @interface IFieldOptions\r\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\r\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\r\n */\n\n/**\r\n * Values of the FieldOptions.JSType enum.\r\n * @typedef IFieldOptionsJSType\r\n * @type {number}\r\n * @property {number} JS_NORMAL=0\r\n * @property {number} JS_STRING=1\r\n * @property {number} JS_NUMBER=2\r\n */\n// copied here from parse.js\n\n\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n/**\r\n * Creates a field from a descriptor.\r\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n * @returns {Field} Field instance\r\n */\n\nField.fromDescriptor = function fromDescriptor(descriptor, syntax) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n  if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\"); // Rewire field type\n\n  var fieldType;\n  if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;else fieldType = fromDescriptorType(descriptor.type); // Rewire field rule\n\n  var fieldRule;\n\n  switch (descriptor.label) {\n    // 0 is reserved for errors\n    case 1:\n      fieldRule = undefined;\n      break;\n\n    case 2:\n      fieldRule = \"required\";\n      break;\n\n    case 3:\n      fieldRule = \"repeated\";\n      break;\n\n    default:\n      throw Error(\"illegal label: \" + descriptor.label);\n  }\n\n  var extendee = descriptor.extendee;\n\n  if (descriptor.extendee !== undefined) {\n    extendee = extendee.length ? extendee : undefined;\n  }\n\n  var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n  field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n\n  if (descriptor.defaultValue && descriptor.defaultValue.length) {\n    var defaultValue = descriptor.defaultValue;\n\n    switch (defaultValue) {\n      case \"true\":\n      case \"TRUE\":\n        defaultValue = true;\n        break;\n\n      case \"false\":\n      case \"FALSE\":\n        defaultValue = false;\n        break;\n\n      default:\n        var match = numberRe.exec(defaultValue);\n        if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n\n        break;\n    }\n\n    field.setOption(\"default\", defaultValue);\n  }\n\n  if (packableDescriptorType(descriptor.type)) {\n    if (syntax === \"proto3\") {\n      // defaults to packed=true (internal preset is packed=true)\n      if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n    } else if (!(descriptor.options && descriptor.options.packed)) // defaults to packed=false\n      field.setOption(\"packed\", false);\n  }\n\n  return field;\n};\n/**\r\n * Converts a field to a descriptor.\r\n * @returns {Message<IFieldDescriptorProto>} Descriptor\r\n * @param {string} [syntax=\"proto2\"] Syntax\r\n */\n\n\nField.prototype.toDescriptor = function toDescriptor(syntax) {\n  var descriptor = exports.FieldDescriptorProto.create({\n    name: this.name,\n    number: this.id\n  });\n\n  if (this.map) {\n    descriptor.type = 11; // message\n\n    descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n\n    descriptor.label = 3; // repeated\n  } else {\n    // Rewire field type\n    switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {\n      case 10: // group\n\n      case 11: // type\n\n      case 14:\n        // enum\n        descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n        break;\n    } // Rewire field rule\n\n\n    switch (this.rule) {\n      case \"repeated\":\n        descriptor.label = 3;\n        break;\n\n      case \"required\":\n        descriptor.label = 2;\n        break;\n\n      default:\n        descriptor.label = 1;\n        break;\n    }\n  } // Handle extension field\n\n\n  descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend; // Handle part of oneof\n\n  if (this.partOf) if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n\n  if (this.options) {\n    descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n    if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n  }\n\n  if (syntax === \"proto3\") {\n    // defaults to packed=true\n    if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n  } else if (this.packed) // defaults to packed=false\n    (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n\n  return descriptor;\n}; // --- Enum ---\n\n/**\r\n * Properties of an EnumDescriptorProto message.\r\n * @interface IEnumDescriptorProto\r\n * @property {string} [name] Enum name\r\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\r\n * @property {IEnumOptions} [options] Enum options\r\n */\n\n/**\r\n * Properties of an EnumValueDescriptorProto message.\r\n * @interface IEnumValueDescriptorProto\r\n * @property {string} [name] Name\r\n * @property {number} [number] Value\r\n * @property {*} [options] Not supported\r\n */\n\n/**\r\n * Properties of an EnumOptions message.\r\n * @interface IEnumOptions\r\n * @property {boolean} [allowAlias] Whether aliases are allowed\r\n * @property {boolean} [deprecated]\r\n */\n\n\nvar unnamedEnumIndex = 0;\n/**\r\n * Creates an enum from a descriptor.\r\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Enum} Enum instance\r\n */\n\nEnum.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor); // Construct values object\n\n  var values = {};\n  if (descriptor.value) for (var i = 0; i < descriptor.value.length; ++i) {\n    var name = descriptor.value[i].name,\n        value = descriptor.value[i].number || 0;\n    values[name && name.length ? name : \"NAME\" + value] = value;\n  }\n  return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n};\n/**\r\n * Converts an enum to a descriptor.\r\n * @returns {Message<IEnumDescriptorProto>} Descriptor\r\n */\n\n\nEnum.prototype.toDescriptor = function toDescriptor() {\n  // Values\n  var values = [];\n\n  for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i) {\n    values.push(exports.EnumValueDescriptorProto.create({\n      name: ks[i],\n      number: this.values[ks[i]]\n    }));\n  }\n\n  return exports.EnumDescriptorProto.create({\n    name: this.name,\n    value: values,\n    options: toDescriptorOptions(this.options, exports.EnumOptions)\n  });\n}; // --- OneOf ---\n\n/**\r\n * Properties of a OneofDescriptorProto message.\r\n * @interface IOneofDescriptorProto\r\n * @property {string} [name] Oneof name\r\n * @property {*} [options] Not supported\r\n */\n\n\nvar unnamedOneofIndex = 0;\n/**\r\n * Creates a oneof from a descriptor.\r\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {OneOf} OneOf instance\r\n */\n\nOneOf.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n  return new OneOf( // unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++ // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option\n  );\n};\n/**\r\n * Converts a oneof to a descriptor.\r\n * @returns {Message<IOneofDescriptorProto>} Descriptor\r\n */\n\n\nOneOf.prototype.toDescriptor = function toDescriptor() {\n  return exports.OneofDescriptorProto.create({\n    name: this.name // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option\n\n  });\n}; // --- Service ---\n\n/**\r\n * Properties of a ServiceDescriptorProto message.\r\n * @interface IServiceDescriptorProto\r\n * @property {string} [name] Service name\r\n * @property {IMethodDescriptorProto[]} [method] Methods\r\n * @property {IServiceOptions} [options] Options\r\n */\n\n/**\r\n * Properties of a ServiceOptions message.\r\n * @interface IServiceOptions\r\n * @property {boolean} [deprecated]\r\n */\n\n\nvar unnamedServiceIndex = 0;\n/**\r\n * Creates a service from a descriptor.\r\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Service} Service instance\r\n */\n\nService.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n  var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n  if (descriptor.method) for (var i = 0; i < descriptor.method.length; ++i) {\n    service.add(Method.fromDescriptor(descriptor.method[i]));\n  }\n  return service;\n};\n/**\r\n * Converts a service to a descriptor.\r\n * @returns {Message<IServiceDescriptorProto>} Descriptor\r\n */\n\n\nService.prototype.toDescriptor = function toDescriptor() {\n  // Methods\n  var methods = [];\n\n  for (var i = 0; i < this.methodsArray; ++i) {\n    methods.push(this._methodsArray[i].toDescriptor());\n  }\n\n  return exports.ServiceDescriptorProto.create({\n    name: this.name,\n    methods: methods,\n    options: toDescriptorOptions(this.options, exports.ServiceOptions)\n  });\n}; // --- Method ---\n\n/**\r\n * Properties of a MethodDescriptorProto message.\r\n * @interface IMethodDescriptorProto\r\n * @property {string} [name] Method name\r\n * @property {string} [inputType] Request type name\r\n * @property {string} [outputType] Response type name\r\n * @property {IMethodOptions} [options] Not supported\r\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\r\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\r\n */\n\n/**\r\n * Properties of a MethodOptions message.\r\n * @interface IMethodOptions\r\n * @property {boolean} [deprecated]\r\n */\n\n\nvar unnamedMethodIndex = 0;\n/**\r\n * Creates a method from a descriptor.\r\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\r\n * @returns {Method} Reflected method instance\r\n */\n\nMethod.fromDescriptor = function fromDescriptor(descriptor) {\n  // Decode the descriptor message if specified as a buffer:\n  if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n  return new Method( // unnamedMethodIndex is global, not per service, because we have no ref to a service here\n  descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n/**\r\n * Converts a method to a descriptor.\r\n * @returns {Message<IMethodDescriptorProto>} Descriptor\r\n */\n\n\nMethod.prototype.toDescriptor = function toDescriptor() {\n  return exports.MethodDescriptorProto.create({\n    name: this.name,\n    inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n    outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n    clientStreaming: this.requestStream,\n    serverStreaming: this.responseStream,\n    options: toDescriptorOptions(this.options, exports.MethodOptions)\n  });\n}; // --- utility ---\n// Converts a descriptor type to a protobuf.js basic type\n\n\nfunction fromDescriptorType(type) {\n  switch (type) {\n    // 0 is reserved for errors\n    case 1:\n      return \"double\";\n\n    case 2:\n      return \"float\";\n\n    case 3:\n      return \"int64\";\n\n    case 4:\n      return \"uint64\";\n\n    case 5:\n      return \"int32\";\n\n    case 6:\n      return \"fixed64\";\n\n    case 7:\n      return \"fixed32\";\n\n    case 8:\n      return \"bool\";\n\n    case 9:\n      return \"string\";\n\n    case 12:\n      return \"bytes\";\n\n    case 13:\n      return \"uint32\";\n\n    case 15:\n      return \"sfixed32\";\n\n    case 16:\n      return \"sfixed64\";\n\n    case 17:\n      return \"sint32\";\n\n    case 18:\n      return \"sint64\";\n  }\n\n  throw Error(\"illegal type: \" + type);\n} // Tests if a descriptor type is packable\n\n\nfunction packableDescriptorType(type) {\n  switch (type) {\n    case 1: // double\n\n    case 2: // float\n\n    case 3: // int64\n\n    case 4: // uint64\n\n    case 5: // int32\n\n    case 6: // fixed64\n\n    case 7: // fixed32\n\n    case 8: // bool\n\n    case 13: // uint32\n\n    case 14: // enum (!)\n\n    case 15: // sfixed32\n\n    case 16: // sfixed64\n\n    case 17: // sint32\n\n    case 18:\n      // sint64\n      return true;\n  }\n\n  return false;\n} // Converts a protobuf.js basic type to a descriptor type\n\n\nfunction toDescriptorType(type, resolvedType) {\n  switch (type) {\n    // 0 is reserved for errors\n    case \"double\":\n      return 1;\n\n    case \"float\":\n      return 2;\n\n    case \"int64\":\n      return 3;\n\n    case \"uint64\":\n      return 4;\n\n    case \"int32\":\n      return 5;\n\n    case \"fixed64\":\n      return 6;\n\n    case \"fixed32\":\n      return 7;\n\n    case \"bool\":\n      return 8;\n\n    case \"string\":\n      return 9;\n\n    case \"bytes\":\n      return 12;\n\n    case \"uint32\":\n      return 13;\n\n    case \"sfixed32\":\n      return 15;\n\n    case \"sfixed64\":\n      return 16;\n\n    case \"sint32\":\n      return 17;\n\n    case \"sint64\":\n      return 18;\n  }\n\n  if (resolvedType instanceof Enum) return 14;\n  if (resolvedType instanceof Type) return resolvedType.group ? 10 : 11;\n  throw Error(\"illegal type: \" + type);\n} // Converts descriptor options to an options object\n\n\nfunction fromDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n\n  for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i) {\n    if ((key = (field = type._fieldsArray[i]).name) !== \"uninterpretedOption\") if (options.hasOwnProperty(key)) {\n      // eslint-disable-line no-prototype-builtins\n      val = options[key];\n      if (field.resolvedType instanceof Enum && typeof val === \"number\" && field.resolvedType.valuesById[val] !== undefined) val = field.resolvedType.valuesById[val];\n      out.push(underScore(key), val);\n    }\n  }\n\n  return out.length ? $protobuf.util.toObject(out) : undefined;\n} // Converts an options object to descriptor options\n\n\nfunction toDescriptorOptions(options, type) {\n  if (!options) return undefined;\n  var out = [];\n\n  for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {\n    val = options[key = ks[i]];\n    if (key === \"default\") continue;\n    var field = type.fields[key];\n    if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)])) continue;\n    out.push(key, val);\n  }\n\n  return out.length ? type.fromObject($protobuf.util.toObject(out)) : undefined;\n} // Calculates the shortest relative path from `from` to `to`.\n\n\nfunction shortname(from, to) {\n  var fromPath = from.fullName.split(\".\"),\n      toPath = to.fullName.split(\".\"),\n      i = 0,\n      j = 0,\n      k = toPath.length - 1;\n  if (!(from instanceof Root) && to instanceof Namespace) while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {\n    var other = to.lookup(fromPath[i++], true);\n    if (other !== null && other !== to) break;\n    ++j;\n  } else for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j) {\n    ;\n  }\n  return toPath.slice(j).join(\".\");\n} // copied here from cli/targets/proto.js\n\n\nfunction underScore(str) {\n  return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function ($0, $1) {\n    return \"_\" + $1.toLowerCase();\n  });\n} // --- exports ---\n\n/**\r\n * Reflected file descriptor set.\r\n * @name FileDescriptorSet\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected file descriptor proto.\r\n * @name FileDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected descriptor proto.\r\n * @name DescriptorProto\r\n * @type {Type}\r\n * @property {Type} ExtensionRange\r\n * @property {Type} ReservedRange\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     ExtensionRange: $protobuf.Type,\r\n *     ReservedRange: $protobuf.Type\r\n * }\r\n */\n\n/**\r\n * Reflected field descriptor proto.\r\n * @name FieldDescriptorProto\r\n * @type {Type}\r\n * @property {Enum} Label\r\n * @property {Enum} Type\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     Label: $protobuf.Enum,\r\n *     Type: $protobuf.Enum\r\n * }\r\n */\n\n/**\r\n * Reflected oneof descriptor proto.\r\n * @name OneofDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected enum descriptor proto.\r\n * @name EnumDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected service descriptor proto.\r\n * @name ServiceDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected enum value descriptor proto.\r\n * @name EnumValueDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected method descriptor proto.\r\n * @name MethodDescriptorProto\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected file options.\r\n * @name FileOptions\r\n * @type {Type}\r\n * @property {Enum} OptimizeMode\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     OptimizeMode: $protobuf.Enum\r\n * }\r\n */\n\n/**\r\n * Reflected message options.\r\n * @name MessageOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected field options.\r\n * @name FieldOptions\r\n * @type {Type}\r\n * @property {Enum} CType\r\n * @property {Enum} JSType\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     CType: $protobuf.Enum,\r\n *     JSType: $protobuf.Enum\r\n * }\r\n */\n\n/**\r\n * Reflected oneof options.\r\n * @name OneofOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected enum options.\r\n * @name EnumOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected enum value options.\r\n * @name EnumValueOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected service options.\r\n * @name ServiceOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected method options.\r\n * @name MethodOptions\r\n * @type {Type}\r\n * @const\r\n * @tstype $protobuf.Type\r\n */\n\n/**\r\n * Reflected uninterpretet option.\r\n * @name UninterpretedOption\r\n * @type {Type}\r\n * @property {Type} NamePart\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     NamePart: $protobuf.Type\r\n * }\r\n */\n\n/**\r\n * Reflected source code info.\r\n * @name SourceCodeInfo\r\n * @type {Type}\r\n * @property {Type} Location\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     Location: $protobuf.Type\r\n * }\r\n */\n\n/**\r\n * Reflected generated code info.\r\n * @name GeneratedCodeInfo\r\n * @type {Type}\r\n * @property {Type} Annotation\r\n * @const\r\n * @tstype $protobuf.Type & {\r\n *     Annotation: $protobuf.Type\r\n * }\r\n */","map":null,"metadata":{},"sourceType":"script"}