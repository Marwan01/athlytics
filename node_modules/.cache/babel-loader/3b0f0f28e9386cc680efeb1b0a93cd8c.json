{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar validate_1 = require(\"./validate\");\n/*!\n * @module firestore/convert\n * @private\n *\n * This module contains utility functions to convert\n * `firestore.v1.Documents` from Proto3 JSON to their equivalent\n * representation in Protobuf JS. Protobuf JS is the only encoding supported by\n * this client, and dependencies that use Proto3 JSON (such as the Google Cloud\n * Functions SDK) are supported through this conversion and its usage in\n * {@see Firestore#snapshot_}.\n */\n\n/**\n * Converts an ISO 8601 or google.protobuf.Timestamp proto into Protobuf JS.\n *\n * @private\n * @param timestampValue The value to convert.\n * @param argumentName The argument name to use in the error message if the\n * conversion fails. If omitted, 'timestampValue' is used.\n * @return The value as expected by Protobuf JS or undefined if no input was\n * provided.\n */\n\n\nfunction timestampFromJson(timestampValue, argumentName) {\n  var timestampProto;\n\n  if (typeof timestampValue === 'string') {\n    var date = new Date(timestampValue);\n    var seconds = Math.floor(date.getTime() / 1000);\n    var nanos = 0;\n\n    if (timestampValue.length > 20) {\n      var nanoString = timestampValue.substring(20, timestampValue.length - 1);\n      var trailingZeroes = 9 - nanoString.length;\n      nanos = Number(nanoString) * Math.pow(10, trailingZeroes);\n    }\n\n    if (isNaN(seconds) || isNaN(nanos)) {\n      argumentName = argumentName || 'timestampValue';\n      throw new Error(\"Specify a valid ISO 8601 timestamp for \\\"\".concat(argumentName, \"\\\".\"));\n    }\n\n    timestampProto = {\n      seconds: seconds || undefined,\n      nanos: nanos || undefined\n    };\n  } else if (timestampValue !== undefined) {\n    validate_1.validateObject('timestampValue', timestampValue);\n    timestampProto = {\n      seconds: timestampValue.seconds || undefined,\n      nanos: timestampValue.nanos || undefined\n    };\n  }\n\n  return timestampProto;\n}\n\nexports.timestampFromJson = timestampFromJson;\n/**\n * Converts a Proto3 JSON 'bytesValue' field into Protobuf JS.\n *\n * @private\n * @param bytesValue The value to convert.\n * @return The value as expected by Protobuf JS.\n */\n\nfunction bytesFromJson(bytesValue) {\n  if (typeof bytesValue === 'string') {\n    return Buffer.from(bytesValue, 'base64');\n  } else {\n    return bytesValue;\n  }\n}\n/**\n * Detects 'valueType' from a Proto3 JSON `firestore.v1.Value` proto.\n *\n * @private\n * @param proto The `firestore.v1.Value` proto.\n * @return The string value for 'valueType'.\n */\n\n\nfunction detectValueType(proto) {\n  if (proto.valueType) {\n    return proto.valueType;\n  }\n\n  var detectedValues = [];\n\n  if (proto.stringValue !== undefined) {\n    detectedValues.push('stringValue');\n  }\n\n  if (proto.booleanValue !== undefined) {\n    detectedValues.push('booleanValue');\n  }\n\n  if (proto.integerValue !== undefined) {\n    detectedValues.push('integerValue');\n  }\n\n  if (proto.doubleValue !== undefined) {\n    detectedValues.push('doubleValue');\n  }\n\n  if (proto.timestampValue !== undefined) {\n    detectedValues.push('timestampValue');\n  }\n\n  if (proto.referenceValue !== undefined) {\n    detectedValues.push('referenceValue');\n  }\n\n  if (proto.arrayValue !== undefined) {\n    detectedValues.push('arrayValue');\n  }\n\n  if (proto.nullValue !== undefined) {\n    detectedValues.push('nullValue');\n  }\n\n  if (proto.mapValue !== undefined) {\n    detectedValues.push('mapValue');\n  }\n\n  if (proto.geoPointValue !== undefined) {\n    detectedValues.push('geoPointValue');\n  }\n\n  if (proto.bytesValue !== undefined) {\n    detectedValues.push('bytesValue');\n  }\n\n  if (detectedValues.length !== 1) {\n    throw new Error(\"Unable to infer type value fom '\".concat(JSON.stringify(proto), \"'.\"));\n  }\n\n  return detectedValues[0];\n}\n\nexports.detectValueType = detectValueType;\n/**\n * Converts a `firestore.v1.Value` in Proto3 JSON encoding into the\n * Protobuf JS format expected by this client.\n *\n * @private\n * @param fieldValue The `firestore.v1.Value` in Proto3 JSON format.\n * @return The `firestore.v1.Value` in Protobuf JS format.\n */\n\nfunction valueFromJson(fieldValue) {\n  var valueType = detectValueType(fieldValue);\n\n  switch (valueType) {\n    case 'timestampValue':\n      return {\n        timestampValue: timestampFromJson(fieldValue.timestampValue)\n      };\n\n    case 'bytesValue':\n      return {\n        bytesValue: bytesFromJson(fieldValue.bytesValue)\n      };\n\n    case 'integerValue':\n      return {\n        integerValue: Number(fieldValue.integerValue)\n      };\n\n    case 'doubleValue':\n      return {\n        doubleValue: Number(fieldValue.doubleValue)\n      };\n\n    case 'arrayValue':\n      {\n        var arrayValue = [];\n\n        if (Array.isArray(fieldValue.arrayValue.values)) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = fieldValue.arrayValue.values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var value = _step.value;\n              arrayValue.push(valueFromJson(value));\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n\n        return {\n          arrayValue: {\n            values: arrayValue\n          }\n        };\n      }\n\n    case 'mapValue':\n      {\n        var mapValue = {};\n\n        for (var prop in fieldValue.mapValue.fields) {\n          if (fieldValue.mapValue.fields.hasOwnProperty(prop)) {\n            mapValue[prop] = valueFromJson(fieldValue.mapValue.fields[prop]);\n          }\n        }\n\n        return {\n          mapValue: {\n            fields: mapValue\n          }\n        };\n      }\n\n    default:\n      return fieldValue;\n  }\n}\n\nexports.valueFromJson = valueFromJson;\n/**\n * Converts a map of IValues in Proto3 JSON encoding into the Protobuf JS format\n * expected by this client. This conversion creates a copy of the underlying\n * fields.\n *\n * @private\n * @param document An object with IValues in Proto3 JSON format.\n * @return The object in Protobuf JS format.\n */\n\nfunction fieldsFromJson(document) {\n  var result = {};\n\n  for (var prop in document) {\n    if (document.hasOwnProperty(prop)) {\n      result[prop] = valueFromJson(document[prop]);\n    }\n  }\n\n  return result;\n}\n\nexports.fieldsFromJson = fieldsFromJson;","map":null,"metadata":{},"sourceType":"script"}