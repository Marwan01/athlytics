{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*!\n * @module common/util\n */\n\nvar projectify_1 = require(\"@google-cloud/projectify\");\n\nvar ent = require(\"ent\");\n\nvar extend = require(\"extend\");\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar retryRequest = require(\"retry-request\");\n\nvar stream_1 = require(\"stream\");\n\nvar teeny_request_1 = require(\"teeny-request\");\n\nvar duplexify = require('duplexify');\n\nvar requestDefaults = {\n  timeout: 60000,\n  gzip: true,\n  forever: true,\n  pool: {\n    maxSockets: Infinity\n  }\n};\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\n\nvar ApiError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(ApiError, _Error);\n\n  function ApiError(errorBodyOrMessage) {\n    var _this;\n\n    _classCallCheck(this, ApiError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ApiError).call(this));\n\n    if (typeof errorBodyOrMessage !== 'object') {\n      _this.message = errorBodyOrMessage || '';\n      return _possibleConstructorReturn(_this);\n    }\n\n    var errorBody = errorBodyOrMessage;\n    _this.code = errorBody.code;\n    _this.errors = errorBody.errors;\n    _this.response = errorBody.response;\n\n    try {\n      _this.errors = JSON.parse(_this.response.body).error.errors;\n    } catch (e) {\n      _this.errors = errorBody.errors;\n    }\n\n    _this.message = ApiError.createMultiErrorMessage(errorBody, _this.errors);\n    return _this;\n  }\n  /**\n   * Pieces together an error message by combining all unique error messages\n   * returned from a single GoogleError\n   *\n   * @private\n   *\n   * @param {GoogleErrorBody} err The original error.\n   * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n   * @returns {string}\n   */\n\n\n  _createClass(ApiError, null, [{\n    key: \"createMultiErrorMessage\",\n    value: function createMultiErrorMessage(err, errors) {\n      var messages = new Set();\n\n      if (err.message) {\n        messages.add(err.message);\n      }\n\n      if (errors && errors.length) {\n        errors.forEach(function (_ref) {\n          var message = _ref.message;\n          return messages.add(message);\n        });\n      } else if (err.response && err.response.body) {\n        messages.add(ent.decode(err.response.body.toString()));\n      } else if (!err.message) {\n        messages.add('A failure occurred during this request.');\n      }\n\n      var messageArr = Array.from(messages);\n\n      if (messageArr.length > 1) {\n        messageArr = messageArr.map(function (message, i) {\n          return \"    \".concat(i + 1, \". \").concat(message);\n        });\n        messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n        messageArr.push('\\n');\n      }\n\n      return messageArr.join('\\n');\n    }\n  }]);\n\n  return ApiError;\n}(_wrapNativeSuper(Error));\n\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\n\nvar PartialFailureError =\n/*#__PURE__*/\nfunction (_Error2) {\n  _inherits(PartialFailureError, _Error2);\n\n  function PartialFailureError(b) {\n    var _this2;\n\n    _classCallCheck(this, PartialFailureError);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PartialFailureError).call(this));\n    var errorObject = b;\n    _this2.errors = errorObject.errors;\n    _this2.name = 'PartialFailureError';\n    _this2.response = errorObject.response;\n    _this2.message = ApiError.createMultiErrorMessage(errorObject, _this2.errors);\n    return _this2;\n  }\n\n  return PartialFailureError;\n}(_wrapNativeSuper(Error));\n\nexports.PartialFailureError = PartialFailureError;\n\nvar Util =\n/*#__PURE__*/\nfunction () {\n  function Util() {\n    _classCallCheck(this, Util);\n\n    this.ApiError = ApiError;\n    this.PartialFailureError = PartialFailureError;\n  }\n  /**\n   * No op.\n   *\n   * @example\n   * function doSomething(callback) {\n   *   callback = callback || noop;\n   * }\n   */\n\n\n  _createClass(Util, [{\n    key: \"noop\",\n    value: function noop() {}\n    /**\n     * Uniformly process an API response.\n     *\n     * @param {*} err - Error value.\n     * @param {*} resp - Response value.\n     * @param {*} body - Body value.\n     * @param {function} callback - The callback function.\n     */\n\n  }, {\n    key: \"handleResp\",\n    value: function handleResp(err, resp, body, callback) {\n      callback = callback || util.noop;\n      var parsedResp = extend(true, {\n        err: err || null\n      }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body)); // Assign the parsed body to resp.body, even if { json: false } was passed\n      // as a request option.\n      // We assume that nobody uses the previously unparsed value of resp.body.\n\n      if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n        parsedResp.resp.body = parsedResp.body;\n      }\n\n      callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n    }\n    /**\n     * Sniff an incoming HTTP response message for errors.\n     *\n     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.resp - The original response object.\n     */\n\n  }, {\n    key: \"parseHttpRespMessage\",\n    value: function parseHttpRespMessage(httpRespMessage) {\n      var parsedHttpRespMessage = {\n        resp: httpRespMessage\n      };\n\n      if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n        // Unknown error. Format according to ApiError standard.\n        parsedHttpRespMessage.err = new ApiError({\n          errors: new Array(),\n          code: httpRespMessage.statusCode,\n          message: httpRespMessage.statusMessage,\n          response: httpRespMessage\n        });\n      }\n\n      return parsedHttpRespMessage;\n    }\n    /**\n     * Parse the response body from an HTTP request.\n     *\n     * @param {object} body - The response body.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.body - The original body value provided\n     *     will try to be JSON.parse'd. If it's successful, the parsed value will\n     * be returned here, otherwise the original value.\n     */\n\n  }, {\n    key: \"parseHttpRespBody\",\n    value: function parseHttpRespBody(body) {\n      var parsedHttpRespBody = {\n        body: body\n      };\n\n      if (typeof body === 'string') {\n        try {\n          parsedHttpRespBody.body = JSON.parse(body);\n        } catch (err) {\n          parsedHttpRespBody.err = new ApiError('Cannot parse JSON response');\n        }\n      }\n\n      if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n        // Error from JSON API.\n        parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n      }\n\n      return parsedHttpRespBody;\n    }\n    /**\n     * Take a Duplexify stream, fetch an authenticated connection header, and\n     * create an outgoing writable stream.\n     *\n     * @param {Duplexify} dup - Duplexify stream.\n     * @param {object} options - Configuration object.\n     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n     * @param {object} options.metadata - Metadata to send at the head of the request.\n     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n     * @param {string=} options.request.method - Default: \"POST\".\n     * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n     * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n     */\n\n  }, {\n    key: \"makeWritableStream\",\n    value: function makeWritableStream(dup, options, onComplete) {\n      onComplete = onComplete || util.noop;\n      var writeStream = new stream_1.PassThrough();\n      dup.setWritable(writeStream);\n      var defaultReqOpts = {\n        method: 'POST',\n        qs: {\n          uploadType: 'multipart'\n        },\n        timeout: 0,\n        maxRetries: 0\n      };\n      var metadata = options.metadata || {};\n      var reqOpts = extend(true, defaultReqOpts, options.request, {\n        multipart: [{\n          'Content-Type': 'application/json',\n          body: JSON.stringify(metadata)\n        }, {\n          'Content-Type': metadata.contentType || 'application/octet-stream',\n          body: writeStream\n        }]\n      });\n      options.makeAuthenticatedRequest(reqOpts, {\n        onAuthenticated: function onAuthenticated(err, authenticatedReqOpts) {\n          if (err) {\n            dup.destroy(err);\n            return;\n          }\n\n          var request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n          request(authenticatedReqOpts, function (err, resp, body) {\n            util.handleResp(err, resp, body, function (err, data) {\n              if (err) {\n                dup.destroy(err);\n                return;\n              }\n\n              dup.emit('response', resp);\n              onComplete(data);\n            });\n          });\n        }\n      });\n    }\n    /**\n     * Returns true if the API request should be retried, given the error that was\n     * given the first time the request was attempted. This is used for rate limit\n     * related errors as well as intermittent server errors.\n     *\n     * @param {error} err - The API error to check if it is appropriate to retry.\n     * @return {boolean} True if the API request should be retried, false otherwise.\n     */\n\n  }, {\n    key: \"shouldRetryRequest\",\n    value: function shouldRetryRequest(err) {\n      if (err) {\n        if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n          return true;\n        }\n\n        if (err.errors) {\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = err.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var e = _step.value;\n              var reason = e.reason;\n\n              if (reason === 'rateLimitExceeded') {\n                return true;\n              }\n\n              if (reason === 'userRateLimitExceeded') {\n                return true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Get a function for making authenticated requests.\n     *\n     * @param {object} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {object=} config.credentials - Credentials object.\n     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n     * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n     * @param {array} config.scopes - Array of scopes required for the API.\n     */\n\n  }, {\n    key: \"makeAuthenticatedRequestFactory\",\n    value: function makeAuthenticatedRequestFactory(config) {\n      var googleAutoAuthConfig = extend({}, config);\n\n      if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n        delete googleAutoAuthConfig.projectId;\n      }\n\n      var authClient = googleAutoAuthConfig.authClient || new google_auth_library_1.GoogleAuth(googleAutoAuthConfig);\n\n      function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n        var stream;\n        var reqConfig = extend({}, config);\n        var activeRequest_;\n\n        if (!optionsOrCallback) {\n          stream = duplexify();\n          reqConfig.stream = stream;\n        }\n\n        var options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n        var callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n\n        var onAuthenticated = function onAuthenticated(err, authenticatedReqOpts) {\n          var autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;\n\n          if (autoAuthFailed) {\n            // Even though authentication failed, the API might not actually\n            // care.\n            authenticatedReqOpts = reqOpts;\n          }\n\n          if (!err || autoAuthFailed) {\n            // tslint:disable-next-line:no-any\n            var projectId = authClient._cachedProjectId;\n\n            if (config.projectId && config.projectId !== '{{projectId}}') {\n              projectId = config.projectId;\n            }\n\n            try {\n              authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n              err = null;\n            } catch (e) {\n              // A projectId was required, but we don't have one.\n              // Re-use the \"Could not load the default credentials error\" if\n              // auto auth failed.\n              err = err || e;\n            }\n          }\n\n          if (err) {\n            if (stream) {\n              stream.destroy(err);\n            } else {\n              var fn = options && options.onAuthenticated ? options.onAuthenticated : callback;\n              fn(err);\n            }\n\n            return;\n          }\n\n          if (options && options.onAuthenticated) {\n            options.onAuthenticated(null, authenticatedReqOpts);\n          } else {\n            activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, callback);\n          }\n        };\n\n        if (reqConfig.customEndpoint) {\n          // Using a custom API override. Do not use `google-auth-library` for\n          // authentication. (ex: connecting to a local Datastore server)\n          onAuthenticated(null, reqOpts);\n        } else {\n          authClient.authorizeRequest(reqOpts).then(function (res) {\n            var opts = extend(true, {}, reqOpts, res);\n            onAuthenticated(null, opts);\n          }, function (err) {\n            onAuthenticated(err);\n          });\n        }\n\n        if (stream) {\n          return stream;\n        }\n\n        return {\n          abort: function abort() {\n            setImmediate(function () {\n              if (activeRequest_) {\n                activeRequest_.abort();\n                activeRequest_ = null;\n              }\n            });\n          }\n        };\n      }\n\n      var mar = makeAuthenticatedRequest;\n      mar.getCredentials = authClient.getCredentials.bind(authClient);\n      mar.authClient = authClient;\n      return mar;\n    }\n    /**\n     * Make a request through the `retryRequest` module with built-in error\n     * handling and exponential back off.\n     *\n     * @param {object} reqOpts - Request options in the format `request` expects.\n     * @param {object=} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {number=} config.maxRetries - Maximum number of automatic retries\n     *     attempted before returning the error. (default: 3)\n     * @param {object=} config.request - HTTP module for request calls.\n     * @param {function} callback - The callback function.\n     */\n\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(reqOpts, config, callback) {\n      var options = {\n        request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n        retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n        shouldRetryFn: function shouldRetryFn(httpRespMessage) {\n          var err = util.parseHttpRespMessage(httpRespMessage).err;\n          return err && util.shouldRetryRequest(err);\n        }\n      };\n\n      if (typeof reqOpts.maxRetries === 'number') {\n        options.retries = reqOpts.maxRetries;\n      }\n\n      if (!config.stream) {\n        return retryRequest(reqOpts, options, function (err, response, body) {\n          util.handleResp(err, response, body, callback);\n        });\n      }\n\n      var dup = config.stream; // tslint:disable-next-line:no-any\n\n      var requestStream;\n      var isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n\n      if (isGetRequest) {\n        requestStream = retryRequest(reqOpts, options);\n        dup.setReadable(requestStream);\n      } else {\n        // Streaming writable HTTP requests cannot be retried.\n        requestStream = options.request(reqOpts);\n        dup.setWritable(requestStream);\n      } // Replay the Request events back to the stream.\n\n\n      requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));\n      dup.abort = requestStream.abort;\n      return dup;\n    }\n    /**\n     * Decorate the options about to be made in a request.\n     *\n     * @param {object} reqOpts - The options to be passed to `request`.\n     * @param {string} projectId - The project ID.\n     * @return {object} reqOpts - The decorated reqOpts.\n     */\n\n  }, {\n    key: \"decorateRequest\",\n    value: function decorateRequest(reqOpts, projectId) {\n      delete reqOpts.autoPaginate;\n      delete reqOpts.autoPaginateVal;\n      delete reqOpts.objectMode;\n\n      if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n        delete reqOpts.qs.autoPaginate;\n        delete reqOpts.qs.autoPaginateVal;\n        reqOpts.qs = projectify_1.replaceProjectIdToken(reqOpts.qs, projectId);\n      }\n\n      if (Array.isArray(reqOpts.multipart)) {\n        reqOpts.multipart = reqOpts.multipart.map(function (part) {\n          return projectify_1.replaceProjectIdToken(part, projectId);\n        });\n      }\n\n      if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n        delete reqOpts.json.autoPaginate;\n        delete reqOpts.json.autoPaginateVal;\n        reqOpts.json = projectify_1.replaceProjectIdToken(reqOpts.json, projectId);\n      }\n\n      reqOpts.uri = projectify_1.replaceProjectIdToken(reqOpts.uri, projectId);\n      return reqOpts;\n    } // tslint:disable-next-line:no-any\n\n  }, {\n    key: \"isCustomType\",\n    value: function isCustomType(unknown, module) {\n      function getConstructorName(obj) {\n        return obj.constructor && obj.constructor.name.toLowerCase();\n      }\n\n      var moduleNameParts = module.split('/');\n      var parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n      var subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n\n      if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n        return false;\n      }\n\n      var walkingModule = unknown;\n\n      while (true) {\n        if (getConstructorName(walkingModule) === parentModuleName) {\n          return true;\n        }\n\n        walkingModule = walkingModule.parent;\n\n        if (!walkingModule) {\n          return false;\n        }\n      }\n    }\n    /**\n     * Create a properly-formatted User-Agent string from a package.json file.\n     *\n     * @param {object} packageJson - A module's package.json file.\n     * @return {string} userAgent - The formatted User-Agent string.\n     */\n\n  }, {\n    key: \"getUserAgentFromPackageJson\",\n    value: function getUserAgentFromPackageJson(packageJson) {\n      var hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n      .replace('/', '-'); // For UA spec-compliance purposes.\n\n      return hyphenatedPackageName + '/' + packageJson.version;\n    }\n    /**\n     * Given two parameters, figure out if this is either:\n     *  - Just a callback function\n     *  - An options object, and then a callback function\n     * @param optionsOrCallback An options object or callback.\n     * @param cb A potentially undefined callback.\n     */\n\n  }, {\n    key: \"maybeOptionsOrCallback\",\n    value: function maybeOptionsOrCallback(optionsOrCallback, cb) {\n      return typeof optionsOrCallback === 'function' ? [{}, optionsOrCallback] : [optionsOrCallback, cb];\n    }\n  }]);\n\n  return Util;\n}();\n\nexports.Util = Util;\nvar util = new Util();\nexports.util = util;","map":null,"metadata":{},"sourceType":"script"}