{"ast":null,"code":"/*! firebase-admin v7.3.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar utils = require(\"../utils\");\n\nvar validator = require(\"../utils/validator\");\n\nvar error_1 = require(\"../utils/error\");\n/**\n * @param {any} obj The object to check for number field within.\n * @param {string} key The entry key.\n * @return {number|undefined} The corresponding number if available.\n */\n\n\nfunction getNumberField(obj, key) {\n  if (typeof obj[key] !== 'undefined' && obj[key] !== null) {\n    return parseInt(obj[key].toString(), 10);\n  }\n\n  return undefined;\n}\n/**\n * Converts a UserImportRecord to a UploadAccountUser object. Throws an error when invalid\n * fields are provided.\n * @param {UserImportRecord} user The UserImportRecord to conver to UploadAccountUser.\n * @param {ValidatorFunction=} userValidator The user validator function.\n * @return {UploadAccountUser} The corresponding UploadAccountUser to return.\n */\n\n\nfunction populateUploadAccountUser(user, userValidator) {\n  var result = {\n    localId: user.uid,\n    email: user.email,\n    emailVerified: user.emailVerified,\n    displayName: user.displayName,\n    disabled: user.disabled,\n    photoUrl: user.photoURL,\n    phoneNumber: user.phoneNumber,\n    providerUserInfo: [],\n    customAttributes: user.customClaims && JSON.stringify(user.customClaims)\n  };\n\n  if (typeof user.passwordHash !== 'undefined') {\n    if (!validator.isBuffer(user.passwordHash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n    }\n\n    result.passwordHash = utils.toWebSafeBase64(user.passwordHash);\n  }\n\n  if (typeof user.passwordSalt !== 'undefined') {\n    if (!validator.isBuffer(user.passwordSalt)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n    }\n\n    result.salt = utils.toWebSafeBase64(user.passwordSalt);\n  }\n\n  if (validator.isNonNullObject(user.metadata)) {\n    if (validator.isNonEmptyString(user.metadata.creationTime)) {\n      result.createdAt = new Date(user.metadata.creationTime).getTime();\n    }\n\n    if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {\n      result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();\n    }\n  }\n\n  if (validator.isArray(user.providerData)) {\n    user.providerData.forEach(function (providerData) {\n      result.providerUserInfo.push({\n        providerId: providerData.providerId,\n        rawId: providerData.uid,\n        email: providerData.email,\n        displayName: providerData.displayName,\n        photoUrl: providerData.photoURL\n      });\n    });\n  } // Remove blank fields.\n\n\n  var key;\n\n  for (key in result) {\n    if (typeof result[key] === 'undefined') {\n      delete result[key];\n    }\n  }\n\n  if (result.providerUserInfo.length === 0) {\n    delete result.providerUserInfo;\n  } // Validate the constructured user individual request. This will throw if an error\n  // is detected.\n\n\n  if (typeof userValidator === 'function') {\n    userValidator(result);\n  }\n\n  return result;\n}\n/**\n * Class that provides a helper for building/validating uploadAccount requests and\n * UserImportResult responses.\n */\n\n\nvar UserImportBuilder =\n/** @class */\nfunction () {\n  /**\n   * @param {UserImportRecord[]} users The list of user records to import.\n   * @param {UserImportOptions=} options The import options which includes hashing\n   *     algorithm details.\n   * @param {ValidatorFunction=} userRequestValidator The user request validator function.\n   * @constructor\n   */\n  function UserImportBuilder(users, options, userRequestValidator) {\n    this.users = users;\n    this.options = options;\n    this.userRequestValidator = userRequestValidator;\n    this.requiresHashOptions = false;\n    this.validatedUsers = [];\n    this.userImportResultErrors = [];\n    this.indexMap = {};\n    this.validatedUsers = this.populateUsers(this.users, this.userRequestValidator);\n    this.validatedOptions = this.populateOptions(this.options, this.requiresHashOptions);\n  }\n  /**\n   * Returns the corresponding constructed uploadAccount request.\n   * @return {UploadAccountRequest} The constructed uploadAccount request.\n   */\n\n\n  UserImportBuilder.prototype.buildRequest = function () {\n    var users = this.validatedUsers.map(function (user) {\n      return deep_copy_1.deepCopy(user);\n    });\n    return deep_copy_1.deepExtend({\n      users: users\n    }, deep_copy_1.deepCopy(this.validatedOptions));\n  };\n  /**\n   * Populates the UserImportResult using the client side detected errors and the server\n   * side returned errors.\n   * @return {UserImportResult} The user import result based on the returned failed\n   *     uploadAccount response.\n   */\n\n\n  UserImportBuilder.prototype.buildResponse = function (failedUploads) {\n    var _this = this; // Initialize user import result.\n\n\n    var importResult = {\n      successCount: this.users.length - this.userImportResultErrors.length,\n      failureCount: this.userImportResultErrors.length,\n      errors: deep_copy_1.deepCopy(this.userImportResultErrors)\n    };\n    importResult.failureCount += failedUploads.length;\n    importResult.successCount -= failedUploads.length;\n    failedUploads.forEach(function (failedUpload) {\n      importResult.errors.push({\n        // Map backend request index to original developer provided array index.\n        index: _this.indexMap[failedUpload.index],\n        error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message)\n      });\n    }); // Sort errors by index.\n\n    importResult.errors.sort(function (a, b) {\n      return a.index - b.index;\n    }); // Return sorted result.\n\n    return importResult;\n  };\n  /**\n   * Validates and returns the hashing options of the uploadAccount request.\n   * Throws an error whenever an invalid or missing options is detected.\n   * @param {UserImportOptions} options The UserImportOptions.\n   * @param {boolean} requiresHashOptions Whether to require hash options.\n   * @return {UploadAccountOptions} The populated UploadAccount options.\n   */\n\n\n  UserImportBuilder.prototype.populateOptions = function (options, requiresHashOptions) {\n    var populatedOptions;\n\n    if (!requiresHashOptions) {\n      return {};\n    }\n\n    if (!validator.isNonNullObject(options.hash)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" is missing from the provided \\\"UserImportOptions\\\".\");\n    }\n\n    if (typeof options.hash.algorithm === 'undefined' || !validator.isNonEmptyString(options.hash.algorithm)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"\\\"hash.algorithm\\\" must be a string matching the list of supported algorithms.\");\n    }\n\n    var rounds;\n\n    switch (options.hash.algorithm) {\n      case 'HMAC_SHA512':\n      case 'HMAC_SHA256':\n      case 'HMAC_SHA1':\n      case 'HMAC_MD5':\n        if (!validator.isBuffer(options.hash.key)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A non-empty \\\"hash.key\\\" byte buffer must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          signerKey: utils.toWebSafeBase64(options.hash.key)\n        };\n        break;\n\n      case 'MD5':\n      case 'SHA1':\n      case 'SHA256':\n      case 'SHA512':\n      case 'PBKDF_SHA1':\n      case 'PBKDF2_SHA256':\n        rounds = getNumberField(options.hash, 'rounds');\n\n        if (isNaN(rounds) || rounds < 0 || rounds > 120000) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 0 and 120000 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          rounds: rounds\n        };\n        break;\n\n      case 'SCRYPT':\n        if (!validator.isBuffer(options.hash.key)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, \"A \\\"hash.key\\\" byte buffer must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        rounds = getNumberField(options.hash, 'rounds');\n\n        if (isNaN(rounds) || rounds <= 0 || rounds > 8) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, \"A valid \\\"hash.rounds\\\" number between 1 and 8 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var memoryCost = getNumberField(options.hash, 'memoryCost');\n\n        if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number between 1 and 14 must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        if (typeof options.hash.saltSeparator !== 'undefined' && !validator.isBuffer(options.hash.saltSeparator)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, \"\\\"hash.saltSeparator\\\" must be a byte buffer.\");\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          signerKey: utils.toWebSafeBase64(options.hash.key),\n          rounds: rounds,\n          memoryCost: memoryCost,\n          saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from(''))\n        };\n        break;\n\n      case 'BCRYPT':\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm\n        };\n        break;\n\n      case 'STANDARD_SCRYPT':\n        var cpuMemCost = getNumberField(options.hash, 'memoryCost');\n\n        if (isNaN(cpuMemCost)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, \"A valid \\\"hash.memoryCost\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var parallelization = getNumberField(options.hash, 'parallelization');\n\n        if (isNaN(parallelization)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, \"A valid \\\"hash.parallelization\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var blockSize = getNumberField(options.hash, 'blockSize');\n\n        if (isNaN(blockSize)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, \"A valid \\\"hash.blockSize\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        var dkLen = getNumberField(options.hash, 'derivedKeyLength');\n\n        if (isNaN(dkLen)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, \"A valid \\\"hash.derivedKeyLength\\\" number must be provided for \" + (\"hash algorithm \" + options.hash.algorithm + \".\"));\n        }\n\n        populatedOptions = {\n          hashAlgorithm: options.hash.algorithm,\n          cpuMemCost: cpuMemCost,\n          parallelization: parallelization,\n          blockSize: blockSize,\n          dkLen: dkLen\n        };\n        break;\n\n      default:\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, \"Unsupported hash algorithm provider \\\"\" + options.hash.algorithm + \"\\\".\");\n    }\n\n    return populatedOptions;\n  };\n  /**\n   * Validates and returns the users list of the uploadAccount request.\n   * Whenever a user with an error is detected, the error is cached and will later be\n   * merged into the user import result. This allows the processing of valid users without\n   * failing early on the first error detected.\n   * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser\n   *     objects.\n   * @param {ValidatorFunction=} userValidator The user validator function.\n   * @return {UploadAccountUser[]} The populated uploadAccount users.\n   */\n\n\n  UserImportBuilder.prototype.populateUsers = function (users, userValidator) {\n    var _this = this;\n\n    var populatedUsers = [];\n    users.forEach(function (user, index) {\n      try {\n        var result = populateUploadAccountUser(user, userValidator);\n\n        if (typeof result.passwordHash !== 'undefined') {\n          _this.requiresHashOptions = true;\n        } // Only users that pass client screening will be passed to backend for processing.\n\n\n        populatedUsers.push(result); // Map user's index (the one to be sent to backend) to original developer provided array.\n\n        _this.indexMap[populatedUsers.length - 1] = index;\n      } catch (error) {\n        // Save the client side error with respect to the developer provided array.\n        _this.userImportResultErrors.push({\n          index: index,\n          error: error\n        });\n      }\n    });\n    return populatedUsers;\n  };\n\n  return UserImportBuilder;\n}();\n\nexports.UserImportBuilder = UserImportBuilder;","map":null,"metadata":{},"sourceType":"script"}