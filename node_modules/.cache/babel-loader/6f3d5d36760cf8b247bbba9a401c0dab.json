{"ast":null,"code":"\"use strict\";\n\nvar protobuf = module.exports = require(\"./index-minimal\");\n\nprotobuf.build = \"light\";\n/**\r\n * A node-style callback as used by {@link load} and {@link Root#load}.\r\n * @typedef LoadCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any, otherwise `null`\r\n * @param {Root} [root] Root, if there hasn't been an error\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\r\n * @param {LoadCallback} callback Callback function\r\n * @returns {undefined}\r\n * @see {@link Root#load}\r\n */\n\nfunction load(filename, root, callback) {\n  if (typeof root === \"function\") {\n    callback = root;\n    root = new protobuf.Root();\n  } else if (!root) root = new protobuf.Root();\n\n  return root.load(filename, callback);\n}\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\r\n * @name load\r\n * @function\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {LoadCallback} callback Callback function\r\n * @returns {undefined}\r\n * @see {@link Root#load}\r\n * @variation 2\r\n */\n// function load(filename:string, callback:LoadCallback):undefined\n\n/**\r\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\r\n * @name load\r\n * @function\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\r\n * @returns {Promise<Root>} Promise\r\n * @see {@link Root#load}\r\n * @variation 3\r\n */\n// function load(filename:string, [root:Root]):Promise<Root>\n\n\nprotobuf.load = load;\n/**\r\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\r\n * @param {string|string[]} filename One or multiple files to load\r\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\r\n * @returns {Root} Root namespace\r\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\r\n * @see {@link Root#loadSync}\r\n */\n\nfunction loadSync(filename, root) {\n  if (!root) root = new protobuf.Root();\n  return root.loadSync(filename);\n}\n\nprotobuf.loadSync = loadSync; // Serialization\n\nprotobuf.encoder = require(\"./encoder\");\nprotobuf.decoder = require(\"./decoder\");\nprotobuf.verifier = require(\"./verifier\");\nprotobuf.converter = require(\"./converter\"); // Reflection\n\nprotobuf.ReflectionObject = require(\"./object\");\nprotobuf.Namespace = require(\"./namespace\");\nprotobuf.Root = require(\"./root\");\nprotobuf.Enum = require(\"./enum\");\nprotobuf.Type = require(\"./type\");\nprotobuf.Field = require(\"./field\");\nprotobuf.OneOf = require(\"./oneof\");\nprotobuf.MapField = require(\"./mapfield\");\nprotobuf.Service = require(\"./service\");\nprotobuf.Method = require(\"./method\"); // Runtime\n\nprotobuf.Message = require(\"./message\");\nprotobuf.wrappers = require(\"./wrappers\"); // Utility\n\nprotobuf.types = require(\"./types\");\nprotobuf.util = require(\"./util\"); // Set up possibly cyclic reflection dependencies\n\nprotobuf.ReflectionObject._configure(protobuf.Root);\n\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\n\nprotobuf.Root._configure(protobuf.Type);\n\nprotobuf.Field._configure(protobuf.Type);","map":null,"metadata":{},"sourceType":"script"}