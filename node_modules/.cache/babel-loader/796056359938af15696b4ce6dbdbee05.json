{"ast":null,"code":"// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n'use strict';\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nvar gapicConfig = require('./firestore_client_config.json');\n\nvar gax = require('google-gax');\n\nvar merge = require('lodash.merge');\n\nvar path = require('path');\n\nvar VERSION = require('../../../package.json').version;\n/**\n * The Cloud Firestore service.\n *\n * This service exposes several types of comparable timestamps:\n *\n * *    `create_time` - The time at which a document was created. Changes only\n *      when a document is deleted, then re-created. Increases in a strict\n *       monotonic fashion.\n * *    `update_time` - The time at which a document was last updated. Changes\n *      every time a document is modified. Does not change when a write results\n *      in no modifications. Increases in a strict monotonic fashion.\n * *    `read_time` - The time at which a particular state was observed. Used\n *      to denote a consistent snapshot of the database or the time at which a\n *      Document was observed to not exist.\n * *    `commit_time` - The time at which the writes in a transaction were\n *      committed. Any read with an equal or greater `read_time` is guaranteed\n *      to see the effects of the transaction.\n *\n * @class\n * @memberof v1\n */\n\n\nvar FirestoreClient =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Construct an instance of FirestoreClient.\n   *\n   * @param {object} [options] - The configuration object. See the subsequent\n   *   parameters for more details.\n   * @param {object} [options.credentials] - Credentials object.\n   * @param {string} [options.credentials.client_email]\n   * @param {string} [options.credentials.private_key]\n   * @param {string} [options.email] - Account email address. Required when\n   *     using a .pem or .p12 keyFilename.\n   * @param {string} [options.keyFilename] - Full path to the a .json, .pem, or\n   *     .p12 key downloaded from the Google Developers Console. If you provide\n   *     a path to a JSON file, the projectId option below is not necessary.\n   *     NOTE: .pem and .p12 require you to specify options.email as well.\n   * @param {number} [options.port] - The port on which to connect to\n   *     the remote host.\n   * @param {string} [options.projectId] - The project ID from the Google\n   *     Developer's Console, e.g. 'grape-spaceship-123'. We will also check\n   *     the environment variable GCLOUD_PROJECT for your project ID. If your\n   *     app is running in an environment which supports\n   *     {@link\n   * https://developers.google.com/identity/protocols/application-default-credentials\n   * Application Default Credentials}, your project ID will be detected\n   * automatically.\n   * @param {function} [options.promise] - Custom promise module to use instead\n   *     of native Promises.\n   * @param {string} [options.servicePath] - The domain name of the\n   *     API remote host.\n   */\n  function FirestoreClient(opts) {\n    var _this = this;\n\n    _classCallCheck(this, FirestoreClient);\n\n    this._descriptors = {}; // Ensure that options include the service address and port.\n\n    opts = Object.assign({\n      clientConfig: {},\n      port: this.constructor.port,\n      servicePath: this.constructor.servicePath\n    }, opts); // Create a `gaxGrpc` object, with any grpc-specific options\n    // sent to the client.\n\n    opts.scopes = this.constructor.scopes;\n    var gaxGrpc = new gax.GrpcClient(opts); // Save the auth object to the client, for use by other methods.\n\n    this.auth = gaxGrpc.auth; // Determine the client header string.\n\n    var clientHeader = [\"gl-node/\".concat(process.version), \"grpc/\".concat(gaxGrpc.grpcVersion), \"gax/\".concat(gax.version), \"gapic/\".concat(VERSION)];\n\n    if (opts.libName && opts.libVersion) {\n      clientHeader.push(\"\".concat(opts.libName, \"/\").concat(opts.libVersion));\n    } // Load the applicable protos.\n\n\n    var protos = merge({}, gaxGrpc.loadProto(path.join(__dirname, '..', '..', 'protos'), 'google/firestore/v1/firestore.proto')); // This API contains \"path templates\"; forward-slash-separated\n    // identifiers to uniquely identify resources within the API.\n    // Create useful helper objects for these.\n\n    this._pathTemplates = {\n      databaseRootPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}'),\n      documentRootPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}/documents'),\n      documentPathPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}/documents/{document_path=**}'),\n      anyPathPathTemplate: new gax.PathTemplate('projects/{project}/databases/{database}/documents/{document}/{any_path=**}')\n    }; // Some of the methods on this service return \"paged\" results,\n    // (e.g. 50 results at a time, with tokens to get subsequent\n    // pages). Denote the keys used for pagination and results.\n\n    this._descriptors.page = {\n      listDocuments: new gax.PageDescriptor('pageToken', 'nextPageToken', 'documents'),\n      listCollectionIds: new gax.PageDescriptor('pageToken', 'nextPageToken', 'collectionIds')\n    }; // Some of the methods on this service provide streaming responses.\n    // Provide descriptors for these.\n\n    this._descriptors.stream = {\n      batchGetDocuments: new gax.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n      runQuery: new gax.StreamDescriptor(gax.StreamType.SERVER_STREAMING),\n      write: new gax.StreamDescriptor(gax.StreamType.BIDI_STREAMING),\n      listen: new gax.StreamDescriptor(gax.StreamType.BIDI_STREAMING)\n    }; // Put together the default options sent with requests.\n\n    var defaults = gaxGrpc.constructSettings('google.firestore.v1.Firestore', gapicConfig, opts.clientConfig, {\n      'x-goog-api-client': clientHeader.join(' ')\n    }); // Set up a dictionary of \"inner API calls\"; the core implementation\n    // of calling the API is handled in `google-gax`, with this code\n    // merely providing the destination and request information.\n\n    this._innerApiCalls = {}; // Put together the \"service stub\" for\n    // google.firestore.v1.Firestore.\n\n    var firestoreStub = gaxGrpc.createStub(protos.google.firestore.v1.Firestore, opts); // Iterate over each of the methods that the service provides\n    // and create an API call method for each.\n\n    var firestoreStubMethods = ['getDocument', 'listDocuments', 'createDocument', 'updateDocument', 'deleteDocument', 'batchGetDocuments', 'beginTransaction', 'commit', 'rollback', 'runQuery', 'write', 'listen', 'listCollectionIds'];\n\n    var _loop = function _loop() {\n      var methodName = firestoreStubMethods[_i];\n      _this._innerApiCalls[methodName] = gax.createApiCall(firestoreStub.then(function (stub) {\n        return function () {\n          var args = Array.prototype.slice.call(arguments, 0);\n          return stub[methodName].apply(stub, args);\n        };\n      }, function (err) {\n        return function () {\n          throw err;\n        };\n      }), defaults[methodName], _this._descriptors.page[methodName] || _this._descriptors.stream[methodName]);\n    };\n\n    for (var _i = 0; _i < firestoreStubMethods.length; _i++) {\n      _loop();\n    }\n  }\n  /**\n   * The DNS address for this API service.\n   */\n\n\n  _createClass(FirestoreClient, [{\n    key: \"getProjectId\",\n\n    /**\n     * Return the project ID used by this class.\n     * @param {function(Error, string)} callback - the callback to\n     *   be called with the current project Id.\n     */\n    value: function getProjectId(callback) {\n      return this.auth.getProjectId(callback);\n    } // -------------------\n    // -- Service calls --\n    // -------------------\n\n    /**\n     * Gets a single document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   The resource name of the Document to get. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     * @param {Object} [request.mask]\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     *\n     *   This object should have the same structure as [DocumentMask]{@link\n     * google.firestore.v1.DocumentMask}\n     * @param {string} [request.transaction]\n     *   Reads the document in a transaction.\n     * @param {Object} [request.readTime]\n     *   Reads the version of the document at the given time.\n     *   This may not be older than 60 seconds.\n     *\n     *   This object should have the same structure as [Timestamp]{@link\n     * google.protobuf.Timestamp}\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error, ?Object)} [callback]\n     *   The function which will be called with the result of the API call.\n     *\n     *   The second parameter to the callback is an object representing\n     * [Document]{@link google.firestore.v1.Document}.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link\n     * google.firestore.v1.Document}. The promise has a method named \"cancel\"\n     * which cancels the ongoing API call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedName = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); client.getDocument({name: formattedName})\n     *   .then(responses => {\n     *     const response = responses[0];\n     *     // doThingsWith(response)\n     *   })\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     */\n\n  }, {\n    key: \"getDocument\",\n    value: function getDocument(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.getDocument(request, options, callback);\n    }\n    /**\n     * Lists documents.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {string} request.collectionId\n     *   The collection ID, relative to `parent`, to list. For example:\n     * `chatrooms` or `messages`.\n     * @param {number} [request.pageSize]\n     *   The maximum number of resources contained in the underlying API\n     *   response. If page streaming is performed per-resource, this\n     *   parameter does not affect the return value. If page streaming is\n     *   performed per-page, this determines the maximum number of\n     *   resources in a page.\n     * @param {string} [request.orderBy]\n     *   The order to sort results by. For example: `priority desc, name`.\n     * @param {Object} [request.mask]\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     *\n     *   This object should have the same structure as [DocumentMask]{@link\n     * google.firestore.v1.DocumentMask}\n     * @param {string} [request.transaction]\n     *   Reads documents in a transaction.\n     * @param {Object} [request.readTime]\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     *\n     *   This object should have the same structure as [Timestamp]{@link\n     * google.protobuf.Timestamp}\n     * @param {boolean} [request.showMissing]\n     *   If the list should show missing documents. A missing document is a\n     *   document that does not exist but has sub-documents. These documents will\n     *   be returned with a key but will not have fields, Document.create_time,\n     *   or Document.update_time set.\n     *\n     *   Requests with `show_missing` may not specify `where` or\n     *   `order_by`.\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error, ?Array, ?Object, ?Object)} [callback]\n     *   The function which will be called with the result of the API call.\n     *\n     *   The second parameter to the callback is Array of [Document]{@link\n     * google.firestore.v1.Document}.\n     *\n     *   When autoPaginate: false is specified through options, it contains the\n     * result in a single response. If the response indicates the next page\n     * exists, the third parameter is set to be used for the next request object.\n     * The fourth parameter keeps the raw response object of an object\n     * representing [ListDocumentsResponse]{@link\n     * google.firestore.v1.ListDocumentsResponse}.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of [Document]{@link\n     * google.firestore.v1.Document}.\n     *\n     *   When autoPaginate: false is specified through options, the array has\n     * three elements. The first element is Array of [Document]{@link\n     * google.firestore.v1.Document} in a single response. The second element is\n     * the next request object if the response indicates the next page exists, or\n     * null. The third element is an object representing\n     * [ListDocumentsResponse]{@link google.firestore.v1.ListDocumentsResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API\n     * call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * // Iterate over all elements.\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); const collectionId = ''; const request = {\n     *   parent: formattedParent,\n     *   collectionId: collectionId,\n     * };\n     *\n     * client.listDocuments(request)\n     *   .then(responses => {\n     *     const resources = responses[0];\n     *     for (const resource of resources) {\n     *       // doThingsWith(resource)\n     *     }\n     *   })\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     *\n     * // Or obtain the paged response.\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); const collectionId = ''; const request = {\n     *   parent: formattedParent,\n     *   collectionId: collectionId,\n     * };\n     *\n     *\n     * const options = {autoPaginate: false};\n     * const callback = responses => {\n     *   // The actual resources in a response.\n     *   const resources = responses[0];\n     *   // The next request if the response shows that there are more responses.\n     *   const nextRequest = responses[1];\n     *   // The actual response object, if necessary.\n     *   // const rawResponse = responses[2];\n     *   for (const resource of resources) {\n     *     // doThingsWith(resource);\n     *   }\n     *   if (nextRequest) {\n     *     // Fetch the next page.\n     *     return client.listDocuments(nextRequest, options).then(callback);\n     *   }\n     * }\n     * client.listDocuments(request, options)\n     *   .then(callback)\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     */\n\n  }, {\n    key: \"listDocuments\",\n    value: function listDocuments(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.listDocuments(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listDocuments}, but returns a NodeJS Stream object.\n     *\n     * This fetches the paged responses for {@link listDocuments} continuously\n     * and invokes the callback registered for 'data' event for each element in\n     * the responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {string} request.collectionId\n     *   The collection ID, relative to `parent`, to list. For example:\n     * `chatrooms` or `messages`.\n     * @param {number} [request.pageSize]\n     *   The maximum number of resources contained in the underlying API\n     *   response. If page streaming is performed per-resource, this\n     *   parameter does not affect the return value. If page streaming is\n     *   performed per-page, this determines the maximum number of\n     *   resources in a page.\n     * @param {string} [request.orderBy]\n     *   The order to sort results by. For example: `priority desc, name`.\n     * @param {Object} [request.mask]\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     *\n     *   This object should have the same structure as [DocumentMask]{@link\n     * google.firestore.v1.DocumentMask}\n     * @param {string} [request.transaction]\n     *   Reads documents in a transaction.\n     * @param {Object} [request.readTime]\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     *\n     *   This object should have the same structure as [Timestamp]{@link\n     * google.protobuf.Timestamp}\n     * @param {boolean} [request.showMissing]\n     *   If the list should show missing documents. A missing document is a\n     *   document that does not exist but has sub-documents. These documents will\n     *   be returned with a key but will not have fields, Document.create_time,\n     *   or Document.update_time set.\n     *\n     *   Requests with `show_missing` may not specify `where` or\n     *   `order_by`.\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @returns {Stream}\n     *   An object stream which emits an object representing [Document]{@link\n     * google.firestore.v1.Document} on 'data' event.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); const collectionId = ''; const request = {\n     *   parent: formattedParent,\n     *   collectionId: collectionId,\n     * };\n     * client.listDocumentsStream(request)\n     *   .on('data', element => {\n     *     // doThingsWith(element)\n     *   }).on('error', err => {\n     *     console.log(err);\n     *   });\n     */\n\n  }, {\n    key: \"listDocumentsStream\",\n    value: function listDocumentsStream(request, options) {\n      options = options || {};\n      return this._descriptors.page.listDocuments.createStream(this._innerApiCalls.listDocuments, request, options);\n    }\n  }, {\n    key: \"createDocument\",\n\n    /**\n     * Creates a new document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   The parent resource. For example:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/chatrooms/{chatroom_id}`\n     * @param {string} request.collectionId\n     *   The collection ID, relative to `parent`, to list. For example:\n     * `chatrooms`.\n     * @param {string} request.documentId\n     *   The client-assigned document ID to use for this document.\n     *\n     *   Optional. If not specified, an ID will be assigned by the service.\n     * @param {Object} request.document\n     *   The document to create. `name` must not be set.\n     *\n     *   This object should have the same structure as [Document]{@link\n     * google.firestore.v1.Document}\n     * @param {Object} [request.mask]\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     *\n     *   This object should have the same structure as [DocumentMask]{@link\n     * google.firestore.v1.DocumentMask}\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error, ?Object)} [callback]\n     *   The function which will be called with the result of the API call.\n     *\n     *   The second parameter to the callback is an object representing\n     * [Document]{@link google.firestore.v1.Document}.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link\n     * google.firestore.v1.Document}. The promise has a method named \"cancel\"\n     * which cancels the ongoing API call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); const collectionId = ''; const documentId =\n     * ''; const document = {}; const request = { parent: formattedParent,\n     *   collectionId: collectionId,\n     *   documentId: documentId,\n     *   document: document,\n     * };\n     * client.createDocument(request)\n     *   .then(responses => {\n     *     const response = responses[0];\n     *     // doThingsWith(response)\n     *   })\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     */\n    value: function createDocument(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.createDocument(request, options, callback);\n    }\n    /**\n     * Updates or inserts a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {Object} request.document\n     *   The updated document.\n     *   Creates the document if it does not already exist.\n     *\n     *   This object should have the same structure as [Document]{@link\n     * google.firestore.v1.Document}\n     * @param {Object} request.updateMask\n     *   The fields to update.\n     *   None of the field paths in the mask may contain a reserved name.\n     *\n     *   If the document exists on the server and has fields not referenced in the\n     *   mask, they are left unchanged.\n     *   Fields referenced in the mask, but not present in the input document, are\n     *   deleted from the document on the server.\n     *\n     *   This object should have the same structure as [DocumentMask]{@link\n     * google.firestore.v1.DocumentMask}\n     * @param {Object} [request.mask]\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If the document has a field that is not present in this mask, that field\n     *   will not be returned in the response.\n     *\n     *   This object should have the same structure as [DocumentMask]{@link\n     * google.firestore.v1.DocumentMask}\n     * @param {Object} [request.currentDocument]\n     *   An optional precondition on the document.\n     *   The request will fail if this is set and not met by the target document.\n     *\n     *   This object should have the same structure as [Precondition]{@link\n     * google.firestore.v1.Precondition}\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error, ?Object)} [callback]\n     *   The function which will be called with the result of the API call.\n     *\n     *   The second parameter to the callback is an object representing\n     * [Document]{@link google.firestore.v1.Document}.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing [Document]{@link\n     * google.firestore.v1.Document}. The promise has a method named \"cancel\"\n     * which cancels the ongoing API call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const document = {};\n     * const updateMask = {};\n     * const request = {\n     *   document: document,\n     *   updateMask: updateMask,\n     * };\n     * client.updateDocument(request)\n     *   .then(responses => {\n     *     const response = responses[0];\n     *     // doThingsWith(response)\n     *   })\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     */\n\n  }, {\n    key: \"updateDocument\",\n    value: function updateDocument(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.updateDocument(request, options, callback);\n    }\n    /**\n     * Deletes a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.name\n     *   The resource name of the Document to delete. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     * @param {Object} [request.currentDocument]\n     *   An optional precondition on the document.\n     *   The request will fail if this is set and not met by the target document.\n     *\n     *   This object should have the same structure as [Precondition]{@link\n     * google.firestore.v1.Precondition}\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error)} [callback]\n     *   The function which will be called with the result of the API call.\n     * @returns {Promise} - The promise which resolves when API call finishes.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API\n     * call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedName = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); client.deleteDocument({name:\n     * formattedName}).catch(err => { console.error(err);\n     * });\n     */\n\n  }, {\n    key: \"deleteDocument\",\n    value: function deleteDocument(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.deleteDocument(request, options, callback);\n    }\n    /**\n     * Gets multiple documents.\n     *\n     * Documents returned by this method are not guaranteed to be returned in the\n     * same order that they were requested.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {string[]} request.documents\n     *   The names of the documents to retrieve. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   The request will fail if any of the document is not a child resource of\n     * the given `database`. Duplicate names will be elided.\n     * @param {Object} [request.mask]\n     *   The fields to return. If not set, returns all fields.\n     *\n     *   If a document has a field that is not present in this mask, that field\n     * will not be returned in the response.\n     *\n     *   This object should have the same structure as [DocumentMask]{@link\n     * google.firestore.v1.DocumentMask}\n     * @param {string} [request.transaction]\n     *   Reads documents in a transaction.\n     * @param {Object} [request.newTransaction]\n     *   Starts a new transaction and reads the documents.\n     *   Defaults to a read-only transaction.\n     *   The new transaction ID will be returned as the first response in the\n     *   stream.\n     *\n     *   This object should have the same structure as [TransactionOptions]{@link\n     * google.firestore.v1.TransactionOptions}\n     * @param {Object} [request.readTime]\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     *\n     *   This object should have the same structure as [Timestamp]{@link\n     * google.protobuf.Timestamp}\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @returns {Stream}\n     *   An object stream which emits [BatchGetDocumentsResponse]{@link\n     * google.firestore.v1.BatchGetDocumentsResponse} on 'data' event.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedDatabase = client.databaseRootPath('[PROJECT]',\n     * '[DATABASE]'); const documents = []; const request = { database:\n     * formattedDatabase, documents: documents,\n     * };\n     * client.batchGetDocuments(request).on('data', response => {\n     *   // doThingsWith(response)\n     * });\n     */\n\n  }, {\n    key: \"batchGetDocuments\",\n    value: function batchGetDocuments(request, options) {\n      options = options || {};\n      return this._innerApiCalls.batchGetDocuments(request, options);\n    }\n    /**\n     * Starts a new transaction.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {Object} [request.options]\n     *   The options for the transaction.\n     *   Defaults to a read-write transaction.\n     *\n     *   This object should have the same structure as [TransactionOptions]{@link\n     * google.firestore.v1.TransactionOptions}\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error, ?Object)} [callback]\n     *   The function which will be called with the result of the API call.\n     *\n     *   The second parameter to the callback is an object representing\n     * [BeginTransactionResponse]{@link\n     * google.firestore.v1.BeginTransactionResponse}.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing\n     * [BeginTransactionResponse]{@link\n     * google.firestore.v1.BeginTransactionResponse}. The promise has a method\n     * named \"cancel\" which cancels the ongoing API call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedDatabase = client.databaseRootPath('[PROJECT]',\n     * '[DATABASE]'); client.beginTransaction({database: formattedDatabase})\n     *   .then(responses => {\n     *     const response = responses[0];\n     *     // doThingsWith(response)\n     *   })\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     */\n\n  }, {\n    key: \"beginTransaction\",\n    value: function beginTransaction(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.beginTransaction(request, options, callback);\n    }\n    /**\n     * Commits a transaction, while optionally updating documents.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {Object[]} request.writes\n     *   The writes to apply.\n     *\n     *   Always executed atomically and in order.\n     *\n     *   This object should have the same structure as [Write]{@link\n     * google.firestore.v1.Write}\n     * @param {string} [request.transaction]\n     *   If set, applies all writes in this transaction, and commits it.\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error, ?Object)} [callback]\n     *   The function which will be called with the result of the API call.\n     *\n     *   The second parameter to the callback is an object representing\n     * [CommitResponse]{@link google.firestore.v1.CommitResponse}.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is an object representing\n     * [CommitResponse]{@link google.firestore.v1.CommitResponse}. The promise has\n     * a method named \"cancel\" which cancels the ongoing API call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedDatabase = client.databaseRootPath('[PROJECT]',\n     * '[DATABASE]'); const writes = []; const request = { database:\n     * formattedDatabase, writes: writes,\n     * };\n     * client.commit(request)\n     *   .then(responses => {\n     *     const response = responses[0];\n     *     // doThingsWith(response)\n     *   })\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.commit(request, options, callback);\n    }\n    /**\n     * Rolls back a transaction.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.database\n     *   The database name. In the format:\n     *   `projects/{project_id}/databases/{database_id}`.\n     * @param {string} request.transaction\n     *   The transaction to roll back.\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error)} [callback]\n     *   The function which will be called with the result of the API call.\n     * @returns {Promise} - The promise which resolves when API call finishes.\n     *   The promise has a method named \"cancel\" which cancels the ongoing API\n     * call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedDatabase = client.databaseRootPath('[PROJECT]',\n     * '[DATABASE]'); const transaction = ''; const request = { database:\n     * formattedDatabase, transaction: transaction,\n     * };\n     * client.rollback(request).catch(err => {\n     *   console.error(err);\n     * });\n     */\n\n  }, {\n    key: \"rollback\",\n    value: function rollback(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.rollback(request, options, callback);\n    }\n    /**\n     * Runs a query.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   The parent resource name. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents` or\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents` or\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {Object} [request.structuredQuery]\n     *   A structured query.\n     *\n     *   This object should have the same structure as [StructuredQuery]{@link\n     * google.firestore.v1.StructuredQuery}\n     * @param {string} [request.transaction]\n     *   Reads documents in a transaction.\n     * @param {Object} [request.newTransaction]\n     *   Starts a new transaction and reads the documents.\n     *   Defaults to a read-only transaction.\n     *   The new transaction ID will be returned as the first response in the\n     *   stream.\n     *\n     *   This object should have the same structure as [TransactionOptions]{@link\n     * google.firestore.v1.TransactionOptions}\n     * @param {Object} [request.readTime]\n     *   Reads documents as they were at the given time.\n     *   This may not be older than 60 seconds.\n     *\n     *   This object should have the same structure as [Timestamp]{@link\n     * google.protobuf.Timestamp}\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @returns {Stream}\n     *   An object stream which emits [RunQueryResponse]{@link\n     * google.firestore.v1.RunQueryResponse} on 'data' event.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); client.runQuery({parent:\n     * formattedParent}).on('data', response => {\n     *   // doThingsWith(response)\n     * });\n     */\n\n  }, {\n    key: \"runQuery\",\n    value: function runQuery(request, options) {\n      options = options || {};\n      return this._innerApiCalls.runQuery(request, options);\n    }\n    /**\n     * Streams batches of document updates and deletes, in order.\n     *\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @returns {Stream}\n     *   An object stream which is both readable and writable. It accepts objects\n     *   representing [WriteRequest]{@link google.firestore.v1.WriteRequest} for\n     * write() method, and will emit objects representing [WriteResponse]{@link\n     * google.firestore.v1.WriteResponse} on 'data' event asynchronously.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const stream = client.write().on('data', response => {\n     *   // doThingsWith(response)\n     * });\n     * const formattedDatabase = client.databaseRootPath('[PROJECT]',\n     * '[DATABASE]'); const request = { database: formattedDatabase,\n     * };\n     * // Write request objects.\n     * stream.write(request);\n     */\n\n  }, {\n    key: \"write\",\n    value: function write(options) {\n      options = options || {};\n      return this._innerApiCalls.write(options);\n    }\n    /**\n     * Listens to changes.\n     *\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @returns {Stream}\n     *   An object stream which is both readable and writable. It accepts objects\n     *   representing [ListenRequest]{@link google.firestore.v1.ListenRequest} for\n     * write() method, and will emit objects representing [ListenResponse]{@link\n     * google.firestore.v1.ListenResponse} on 'data' event asynchronously.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const stream = client.listen().on('data', response => {\n     *   // doThingsWith(response)\n     * });\n     * const formattedDatabase = client.databaseRootPath('[PROJECT]',\n     * '[DATABASE]'); const request = { database: formattedDatabase,\n     * };\n     * // Write request objects.\n     * stream.write(request);\n     */\n\n  }, {\n    key: \"listen\",\n    value: function listen(options) {\n      options = options || {};\n      return this._innerApiCalls.listen({}, options);\n    }\n    /**\n     * Lists all the collection IDs underneath a document.\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   The parent document. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {number} [request.pageSize]\n     *   The maximum number of resources contained in the underlying API\n     *   response. If page streaming is performed per-resource, this\n     *   parameter does not affect the return value. If page streaming is\n     *   performed per-page, this determines the maximum number of\n     *   resources in a page.\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @param {function(?Error, ?Array, ?Object, ?Object)} [callback]\n     *   The function which will be called with the result of the API call.\n     *\n     *   The second parameter to the callback is Array of string.\n     *\n     *   When autoPaginate: false is specified through options, it contains the\n     * result in a single response. If the response indicates the next page\n     * exists, the third parameter is set to be used for the next request object.\n     * The fourth parameter keeps the raw response object of an object\n     * representing [ListCollectionIdsResponse]{@link\n     * google.firestore.v1.ListCollectionIdsResponse}.\n     * @returns {Promise} - The promise which resolves to an array.\n     *   The first element of the array is Array of string.\n     *\n     *   When autoPaginate: false is specified through options, the array has\n     * three elements. The first element is Array of string in a single response.\n     *   The second element is the next request object if the response\n     *   indicates the next page exists, or null. The third element is\n     *   an object representing [ListCollectionIdsResponse]{@link\n     * google.firestore.v1.ListCollectionIdsResponse}.\n     *\n     *   The promise has a method named \"cancel\" which cancels the ongoing API\n     * call.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * // Iterate over all elements.\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]');\n     *\n     * client.listCollectionIds({parent: formattedParent})\n     *   .then(responses => {\n     *     const resources = responses[0];\n     *     for (const resource of resources) {\n     *       // doThingsWith(resource)\n     *     }\n     *   })\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     *\n     * // Or obtain the paged response.\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]');\n     *\n     *\n     * const options = {autoPaginate: false};\n     * const callback = responses => {\n     *   // The actual resources in a response.\n     *   const resources = responses[0];\n     *   // The next request if the response shows that there are more responses.\n     *   const nextRequest = responses[1];\n     *   // The actual response object, if necessary.\n     *   // const rawResponse = responses[2];\n     *   for (const resource of resources) {\n     *     // doThingsWith(resource);\n     *   }\n     *   if (nextRequest) {\n     *     // Fetch the next page.\n     *     return client.listCollectionIds(nextRequest, options).then(callback);\n     *   }\n     * }\n     * client.listCollectionIds({parent: formattedParent}, options)\n     *   .then(callback)\n     *   .catch(err => {\n     *     console.error(err);\n     *   });\n     */\n\n  }, {\n    key: \"listCollectionIds\",\n    value: function listCollectionIds(request, options, callback) {\n      if (options instanceof Function && callback === undefined) {\n        callback = options;\n        options = {};\n      }\n\n      options = options || {};\n      return this._innerApiCalls.listCollectionIds(request, options, callback);\n    }\n    /**\n     * Equivalent to {@link listCollectionIds}, but returns a NodeJS Stream\n     * object.\n     *\n     * This fetches the paged responses for {@link listCollectionIds} continuously\n     * and invokes the callback registered for 'data' event for each element in\n     * the responses.\n     *\n     * The returned object has 'end' method when no more elements are required.\n     *\n     * autoPaginate option will be ignored.\n     *\n     * @see {@link https://nodejs.org/api/stream.html}\n     *\n     * @param {Object} request\n     *   The request object that will be sent.\n     * @param {string} request.parent\n     *   The parent document. In the format:\n     *   `projects/{project_id}/databases/{database_id}/documents/{document_path}`.\n     *   For example:\n     *   `projects/my-project/databases/my-database/documents/chatrooms/my-chatroom`\n     * @param {number} [request.pageSize]\n     *   The maximum number of resources contained in the underlying API\n     *   response. If page streaming is performed per-resource, this\n     *   parameter does not affect the return value. If page streaming is\n     *   performed per-page, this determines the maximum number of\n     *   resources in a page.\n     * @param {Object} [options]\n     *   Optional parameters. You can override the default settings for this call,\n     * e.g, timeout, retries, paginations, etc. See [gax.CallOptions]{@link\n     * https://googleapis.github.io/gax-nodejs/global.html#CallOptions} for the\n     * details.\n     * @returns {Stream}\n     *   An object stream which emits a string on 'data' event.\n     *\n     * @example\n     *\n     * const firestore = require('@google-cloud/firestore');\n     *\n     * const client = new firestore.v1.FirestoreClient({\n     *   // optional auth parameters.\n     * });\n     *\n     * const formattedParent = client.anyPathPath('[PROJECT]', '[DATABASE]',\n     * '[DOCUMENT]', '[ANY_PATH]'); client.listCollectionIdsStream({parent:\n     * formattedParent}) .on('data', element => {\n     *     // doThingsWith(element)\n     *   }).on('error', err => {\n     *     console.log(err);\n     *   });\n     */\n\n  }, {\n    key: \"listCollectionIdsStream\",\n    value: function listCollectionIdsStream(request, options) {\n      options = options || {};\n      return this._descriptors.page.listCollectionIds.createStream(this._innerApiCalls.listCollectionIds, request, options);\n    }\n  }, {\n    key: \"databaseRootPath\",\n    // --------------------\n    // -- Path templates --\n    // --------------------\n\n    /**\n     * Return a fully-qualified database_root resource name string.\n     *\n     * @param {String} project\n     * @param {String} database\n     * @returns {String}\n     */\n    value: function databaseRootPath(project, database) {\n      return this._pathTemplates.databaseRootPathTemplate.render({\n        project: project,\n        database: database\n      });\n    }\n    /**\n     * Return a fully-qualified document_root resource name string.\n     *\n     * @param {String} project\n     * @param {String} database\n     * @returns {String}\n     */\n\n  }, {\n    key: \"documentRootPath\",\n    value: function documentRootPath(project, database) {\n      return this._pathTemplates.documentRootPathTemplate.render({\n        project: project,\n        database: database\n      });\n    }\n    /**\n     * Return a fully-qualified document_path resource name string.\n     *\n     * @param {String} project\n     * @param {String} database\n     * @param {String} documentPath\n     * @returns {String}\n     */\n\n  }, {\n    key: \"documentPathPath\",\n    value: function documentPathPath(project, database, documentPath) {\n      return this._pathTemplates.documentPathPathTemplate.render({\n        project: project,\n        database: database,\n        document_path: documentPath\n      });\n    }\n    /**\n     * Return a fully-qualified any_path resource name string.\n     *\n     * @param {String} project\n     * @param {String} database\n     * @param {String} document\n     * @param {String} anyPath\n     * @returns {String}\n     */\n\n  }, {\n    key: \"anyPathPath\",\n    value: function anyPathPath(project, database, document, anyPath) {\n      return this._pathTemplates.anyPathPathTemplate.render({\n        project: project,\n        database: database,\n        document: document,\n        any_path: anyPath\n      });\n    }\n    /**\n     * Parse the databaseRootName from a database_root resource.\n     *\n     * @param {String} databaseRootName\n     *   A fully-qualified path representing a database_root resources.\n     * @returns {String} - A string representing the project.\n     */\n\n  }, {\n    key: \"matchProjectFromDatabaseRootName\",\n    value: function matchProjectFromDatabaseRootName(databaseRootName) {\n      return this._pathTemplates.databaseRootPathTemplate.match(databaseRootName).project;\n    }\n    /**\n     * Parse the databaseRootName from a database_root resource.\n     *\n     * @param {String} databaseRootName\n     *   A fully-qualified path representing a database_root resources.\n     * @returns {String} - A string representing the database.\n     */\n\n  }, {\n    key: \"matchDatabaseFromDatabaseRootName\",\n    value: function matchDatabaseFromDatabaseRootName(databaseRootName) {\n      return this._pathTemplates.databaseRootPathTemplate.match(databaseRootName).database;\n    }\n    /**\n     * Parse the documentRootName from a document_root resource.\n     *\n     * @param {String} documentRootName\n     *   A fully-qualified path representing a document_root resources.\n     * @returns {String} - A string representing the project.\n     */\n\n  }, {\n    key: \"matchProjectFromDocumentRootName\",\n    value: function matchProjectFromDocumentRootName(documentRootName) {\n      return this._pathTemplates.documentRootPathTemplate.match(documentRootName).project;\n    }\n    /**\n     * Parse the documentRootName from a document_root resource.\n     *\n     * @param {String} documentRootName\n     *   A fully-qualified path representing a document_root resources.\n     * @returns {String} - A string representing the database.\n     */\n\n  }, {\n    key: \"matchDatabaseFromDocumentRootName\",\n    value: function matchDatabaseFromDocumentRootName(documentRootName) {\n      return this._pathTemplates.documentRootPathTemplate.match(documentRootName).database;\n    }\n    /**\n     * Parse the documentPathName from a document_path resource.\n     *\n     * @param {String} documentPathName\n     *   A fully-qualified path representing a document_path resources.\n     * @returns {String} - A string representing the project.\n     */\n\n  }, {\n    key: \"matchProjectFromDocumentPathName\",\n    value: function matchProjectFromDocumentPathName(documentPathName) {\n      return this._pathTemplates.documentPathPathTemplate.match(documentPathName).project;\n    }\n    /**\n     * Parse the documentPathName from a document_path resource.\n     *\n     * @param {String} documentPathName\n     *   A fully-qualified path representing a document_path resources.\n     * @returns {String} - A string representing the database.\n     */\n\n  }, {\n    key: \"matchDatabaseFromDocumentPathName\",\n    value: function matchDatabaseFromDocumentPathName(documentPathName) {\n      return this._pathTemplates.documentPathPathTemplate.match(documentPathName).database;\n    }\n    /**\n     * Parse the documentPathName from a document_path resource.\n     *\n     * @param {String} documentPathName\n     *   A fully-qualified path representing a document_path resources.\n     * @returns {String} - A string representing the document_path.\n     */\n\n  }, {\n    key: \"matchDocumentPathFromDocumentPathName\",\n    value: function matchDocumentPathFromDocumentPathName(documentPathName) {\n      return this._pathTemplates.documentPathPathTemplate.match(documentPathName).document_path;\n    }\n    /**\n     * Parse the anyPathName from a any_path resource.\n     *\n     * @param {String} anyPathName\n     *   A fully-qualified path representing a any_path resources.\n     * @returns {String} - A string representing the project.\n     */\n\n  }, {\n    key: \"matchProjectFromAnyPathName\",\n    value: function matchProjectFromAnyPathName(anyPathName) {\n      return this._pathTemplates.anyPathPathTemplate.match(anyPathName).project;\n    }\n    /**\n     * Parse the anyPathName from a any_path resource.\n     *\n     * @param {String} anyPathName\n     *   A fully-qualified path representing a any_path resources.\n     * @returns {String} - A string representing the database.\n     */\n\n  }, {\n    key: \"matchDatabaseFromAnyPathName\",\n    value: function matchDatabaseFromAnyPathName(anyPathName) {\n      return this._pathTemplates.anyPathPathTemplate.match(anyPathName).database;\n    }\n    /**\n     * Parse the anyPathName from a any_path resource.\n     *\n     * @param {String} anyPathName\n     *   A fully-qualified path representing a any_path resources.\n     * @returns {String} - A string representing the document.\n     */\n\n  }, {\n    key: \"matchDocumentFromAnyPathName\",\n    value: function matchDocumentFromAnyPathName(anyPathName) {\n      return this._pathTemplates.anyPathPathTemplate.match(anyPathName).document;\n    }\n    /**\n     * Parse the anyPathName from a any_path resource.\n     *\n     * @param {String} anyPathName\n     *   A fully-qualified path representing a any_path resources.\n     * @returns {String} - A string representing the any_path.\n     */\n\n  }, {\n    key: \"matchAnyPathFromAnyPathName\",\n    value: function matchAnyPathFromAnyPathName(anyPathName) {\n      return this._pathTemplates.anyPathPathTemplate.match(anyPathName).any_path;\n    }\n  }], [{\n    key: \"servicePath\",\n    get: function get() {\n      return 'firestore.googleapis.com';\n    }\n    /**\n     * The port for this API service.\n     */\n\n  }, {\n    key: \"port\",\n    get: function get() {\n      return 443;\n    }\n    /**\n     * The scopes needed to make gRPC calls for every method defined\n     * in this service.\n     */\n\n  }, {\n    key: \"scopes\",\n    get: function get() {\n      return ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/datastore'];\n    }\n  }]);\n\n  return FirestoreClient;\n}();\n\nmodule.exports = FirestoreClient;","map":null,"metadata":{},"sourceType":"script"}