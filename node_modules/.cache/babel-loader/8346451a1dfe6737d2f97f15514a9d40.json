{"ast":null,"code":"/*! firebase-admin v7.3.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar error_1 = require(\"../utils/error\");\n\nvar validator = require(\"../utils/validator\");\n\nvar jwt = require(\"jsonwebtoken\");\n\nvar api_request_1 = require(\"../utils/api-request\"); // Audience to use for Firebase Auth Custom tokens\n\n\nvar FIREBASE_AUDIENCE = 'https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit';\nexports.ALGORITHM_RS256 = 'RS256'; // URL containing the public keys for the Google certs (whose private keys are used to sign Firebase\n// Auth ID tokens)\n\nvar CLIENT_CERT_URL = 'https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com'; // URL containing the public keys for Firebase session cookies. This will be updated to a different URL soon.\n\nvar SESSION_COOKIE_CERT_URL = 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys';\n/** User facing token information related to the Firebase ID token. */\n\nexports.ID_TOKEN_INFO = {\n  url: 'https://firebase.google.com/docs/auth/admin/verify-id-tokens',\n  verifyApiName: 'verifyIdToken()',\n  jwtName: 'Firebase ID token',\n  shortName: 'ID token',\n  expiredErrorCode: error_1.AuthClientErrorCode.ID_TOKEN_EXPIRED\n};\n/** User facing token information related to the Firebase session cookie. */\n\nexports.SESSION_COOKIE_INFO = {\n  url: 'https://firebase.google.com/docs/auth/admin/manage-cookies',\n  verifyApiName: 'verifySessionCookie()',\n  jwtName: 'Firebase session cookie',\n  shortName: 'session cookie',\n  expiredErrorCode: error_1.AuthClientErrorCode.SESSION_COOKIE_EXPIRED\n};\n/**\n * Class for verifying general purpose Firebase JWTs. This verifies ID tokens and session cookies.\n */\n\nvar FirebaseTokenVerifier =\n/** @class */\nfunction () {\n  function FirebaseTokenVerifier(clientCertUrl, algorithm, issuer, projectId, tokenInfo) {\n    this.clientCertUrl = clientCertUrl;\n    this.algorithm = algorithm;\n    this.issuer = issuer;\n    this.projectId = projectId;\n    this.tokenInfo = tokenInfo;\n\n    if (!validator.isURL(clientCertUrl)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided public client certificate URL is an invalid URL.\");\n    } else if (!validator.isNonEmptyString(algorithm)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT algorithm is an empty string.\");\n    } else if (!validator.isURL(issuer)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT issuer is an invalid URL.\");\n    } else if (!validator.isNonNullObject(tokenInfo)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT information is not an object or null.\");\n    } else if (!validator.isURL(tokenInfo.url)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The provided JWT verification documentation URL is invalid.\");\n    } else if (!validator.isNonEmptyString(tokenInfo.verifyApiName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT verify API name must be a non-empty string.\");\n    } else if (!validator.isNonEmptyString(tokenInfo.jwtName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT public full name must be a non-empty string.\");\n    } else if (!validator.isNonEmptyString(tokenInfo.shortName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT public short name must be a non-empty string.\");\n    } else if (!validator.isNonNullObject(tokenInfo.expiredErrorCode) || !('code' in tokenInfo.expiredErrorCode)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"The JWT expiration error code must be a non-null ErrorInfo object.\");\n    }\n\n    this.shortNameArticle = tokenInfo.shortName.charAt(0).match(/[aeiou]/i) ? 'an' : 'a'; // For backward compatibility, the project ID is validated in the verification call.\n  }\n  /**\n   * Verifies the format and signature of a Firebase Auth JWT token.\n   *\n   * @param {string} jwtToken The Firebase Auth JWT token to verify.\n   * @return {Promise<object>} A promise fulfilled with the decoded claims of the Firebase Auth ID\n   *                           token.\n   */\n\n\n  FirebaseTokenVerifier.prototype.verifyJWT = function (jwtToken) {\n    var _this = this;\n\n    if (!validator.isString(jwtToken)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"First argument to \" + this.tokenInfo.verifyApiName + \" must be a \" + this.tokenInfo.jwtName + \" string.\");\n    }\n\n    if (!validator.isNonEmptyString(this.projectId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, \"Must initialize app with a cert credential or set your Firebase project ID as the \" + (\"GOOGLE_CLOUD_PROJECT environment variable to call \" + this.tokenInfo.verifyApiName + \".\"));\n    }\n\n    var fullDecodedToken = jwt.decode(jwtToken, {\n      complete: true\n    });\n    var header = fullDecodedToken && fullDecodedToken.header;\n    var payload = fullDecodedToken && fullDecodedToken.payload;\n    var projectIdMatchMessage = \" Make sure the \" + this.tokenInfo.shortName + \" comes from the same \" + \"Firebase project as the service account used to authenticate this SDK.\";\n    var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" + (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\n    var errorMessage;\n\n    if (!fullDecodedToken) {\n      errorMessage = \"Decoding \" + this.tokenInfo.jwtName + \" failed. Make sure you passed the entire string JWT \" + (\"which represents \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\") + verifyJwtTokenDocsMessage;\n    } else if (typeof header.kid === 'undefined') {\n      var isCustomToken = payload.aud === FIREBASE_AUDIENCE;\n      var isLegacyCustomToken = header.alg === 'HS256' && payload.v === 0 && 'd' in payload && 'uid' in payload.d;\n\n      if (isCustomToken) {\n        errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" + (this.tokenInfo.shortName + \", but was given a custom token.\");\n      } else if (isLegacyCustomToken) {\n        errorMessage = this.tokenInfo.verifyApiName + \" expects \" + this.shortNameArticle + \" \" + (this.tokenInfo.shortName + \", but was given a legacy custom token.\");\n      } else {\n        errorMessage = 'Firebase ID token has no \"kid\" claim.';\n      }\n\n      errorMessage += verifyJwtTokenDocsMessage;\n    } else if (header.alg !== this.algorithm) {\n      errorMessage = this.tokenInfo.jwtName + \" has incorrect algorithm. Expected \\\"\" + this.algorithm + \"\\\" but got \" + \"\\\"\" + header.alg + \"\\\".\" + verifyJwtTokenDocsMessage;\n    } else if (payload.aud !== this.projectId) {\n      errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"aud\\\" (audience) claim. Expected \\\"\" + this.projectId + \"\\\" but got \\\"\" + payload.aud + \"\\\".\" + projectIdMatchMessage + verifyJwtTokenDocsMessage;\n    } else if (payload.iss !== this.issuer + this.projectId) {\n      errorMessage = this.tokenInfo.jwtName + \" has incorrect \\\"iss\\\" (issuer) claim. Expected \" + (\"\\\"\" + this.issuer + \"\\\"\") + this.projectId + \"\\\" but got \\\"\" + payload.iss + \"\\\".\" + projectIdMatchMessage + verifyJwtTokenDocsMessage;\n    } else if (typeof payload.sub !== 'string') {\n      errorMessage = this.tokenInfo.jwtName + \" has no \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\n    } else if (payload.sub === '') {\n      errorMessage = this.tokenInfo.jwtName + \" has an empty string \\\"sub\\\" (subject) claim.\" + verifyJwtTokenDocsMessage;\n    } else if (payload.sub.length > 128) {\n      errorMessage = this.tokenInfo.jwtName + \" has \\\"sub\\\" (subject) claim longer than 128 characters.\" + verifyJwtTokenDocsMessage;\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\n    }\n\n    return this.fetchPublicKeys().then(function (publicKeys) {\n      if (!publicKeys.hasOwnProperty(header.kid)) {\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, _this.tokenInfo.jwtName + \" has \\\"kid\\\" claim which does not correspond to a known public key. \" + (\"Most likely the \" + _this.tokenInfo.shortName + \" is expired, so get a fresh token from your \") + \"client app and try again.\"));\n      } else {\n        return _this.verifyJwtSignatureWithKey(jwtToken, publicKeys[header.kid]);\n      }\n    });\n  };\n  /**\n   * Verifies the JWT signature using the provided public key.\n   * @param {string} jwtToken The JWT token to verify.\n   * @param {string} publicKey The public key certificate.\n   * @return {Promise<object>} A promise that resolves with the decoded JWT claims on successful\n   *     verification.\n   */\n\n\n  FirebaseTokenVerifier.prototype.verifyJwtSignatureWithKey = function (jwtToken, publicKey) {\n    var _this = this;\n\n    var verifyJwtTokenDocsMessage = \" See \" + this.tokenInfo.url + \" \" + (\"for details on how to retrieve \" + this.shortNameArticle + \" \" + this.tokenInfo.shortName + \".\");\n    return new Promise(function (resolve, reject) {\n      jwt.verify(jwtToken, publicKey, {\n        algorithms: [_this.algorithm]\n      }, function (error, decodedToken) {\n        if (error) {\n          if (error.name === 'TokenExpiredError') {\n            var errorMessage = _this.tokenInfo.jwtName + \" has expired. Get a fresh \" + _this.tokenInfo.shortName + (\" from your client app and try again (auth/\" + _this.tokenInfo.expiredErrorCode.code + \").\") + verifyJwtTokenDocsMessage;\n            return reject(new error_1.FirebaseAuthError(_this.tokenInfo.expiredErrorCode, errorMessage));\n          } else if (error.name === 'JsonWebTokenError') {\n            var errorMessage = _this.tokenInfo.jwtName + \" has invalid signature.\" + verifyJwtTokenDocsMessage;\n            return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage));\n          }\n\n          return reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, error.message));\n        } else {\n          decodedToken.uid = decodedToken.sub;\n          resolve(decodedToken);\n        }\n      });\n    });\n  };\n  /**\n   * Fetches the public keys for the Google certs.\n   *\n   * @return {Promise<object>} A promise fulfilled with public keys for the Google certs.\n   */\n\n\n  FirebaseTokenVerifier.prototype.fetchPublicKeys = function () {\n    var _this = this;\n\n    var publicKeysExist = typeof this.publicKeys !== 'undefined';\n    var publicKeysExpiredExists = typeof this.publicKeysExpireAt !== 'undefined';\n    var publicKeysStillValid = publicKeysExpiredExists && Date.now() < this.publicKeysExpireAt;\n\n    if (publicKeysExist && publicKeysStillValid) {\n      return Promise.resolve(this.publicKeys);\n    }\n\n    var client = new api_request_1.HttpClient();\n    var request = {\n      method: 'GET',\n      url: this.clientCertUrl\n    };\n    return client.send(request).then(function (resp) {\n      if (!resp.isJson() || resp.data.error) {\n        // Treat all non-json messages and messages with an 'error' field as\n        // error responses.\n        throw new api_request_1.HttpError(resp);\n      }\n\n      if (resp.headers.hasOwnProperty('cache-control')) {\n        var cacheControlHeader = resp.headers['cache-control'];\n        var parts = cacheControlHeader.split(',');\n        parts.forEach(function (part) {\n          var subParts = part.trim().split('=');\n\n          if (subParts[0] === 'max-age') {\n            var maxAge = +subParts[1];\n            _this.publicKeysExpireAt = Date.now() + maxAge * 1000;\n          }\n        });\n      }\n\n      _this.publicKeys = resp.data;\n      return resp.data;\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        var errorMessage = 'Error fetching public keys for Google certs: ';\n        var resp = err.response;\n\n        if (resp.isJson() && resp.data.error) {\n          errorMessage += \"\" + resp.data.error;\n\n          if (resp.data.error_description) {\n            errorMessage += ' (' + resp.data.error_description + ')';\n          }\n        } else {\n          errorMessage += \"\" + resp.text;\n        }\n\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, errorMessage);\n      }\n\n      throw err;\n    });\n  };\n\n  return FirebaseTokenVerifier;\n}();\n\nexports.FirebaseTokenVerifier = FirebaseTokenVerifier;\n/**\n * Creates a new FirebaseTokenVerifier to verify Firebase ID tokens.\n *\n * @param {string} projectId Project ID string.\n * @return {FirebaseTokenVerifier}\n */\n\nfunction createIdTokenVerifier(projectId) {\n  return new FirebaseTokenVerifier(CLIENT_CERT_URL, exports.ALGORITHM_RS256, 'https://securetoken.google.com/', projectId, exports.ID_TOKEN_INFO);\n}\n\nexports.createIdTokenVerifier = createIdTokenVerifier;\n/**\n * Creates a new FirebaseTokenVerifier to verify Firebase session cookies.\n *\n * @param {string} projectId Project ID string.\n * @return {FirebaseTokenVerifier}\n */\n\nfunction createSessionCookieVerifier(projectId) {\n  return new FirebaseTokenVerifier(SESSION_COOKIE_CERT_URL, exports.ALGORITHM_RS256, 'https://session.firebase.google.com/', projectId, exports.SESSION_COOKIE_INFO);\n}\n\nexports.createSessionCookieVerifier = createSessionCookieVerifier;","map":null,"metadata":{},"sourceType":"script"}