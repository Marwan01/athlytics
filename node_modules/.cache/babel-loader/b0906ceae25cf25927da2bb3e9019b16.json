{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2018 Google LLC\n *\n * Distributed under MIT license.\n * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT\n */\n\nvar _regeneratorRuntime = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar abort_controller_1 = require(\"abort-controller\");\n\nvar ConfigStore = require(\"configstore\");\n\nvar crypto_1 = require(\"crypto\");\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar Pumpify = require(\"pumpify\");\n\nvar stream_1 = require(\"stream\");\n\nvar streamEvents = require(\"stream-events\");\n\nvar BASE_URI = 'https://www.googleapis.com/upload/storage/v1/b';\nvar TERMINATED_UPLOAD_STATUS_CODE = 410;\nvar RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nvar RETRY_LIMIT = 5;\n\nvar Upload =\n/*#__PURE__*/\nfunction (_Pumpify) {\n  _inherits(Upload, _Pumpify);\n\n  function Upload(cfg) {\n    var _this;\n\n    _classCallCheck(this, Upload);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Upload).call(this));\n    _this.numBytesWritten = 0;\n    _this.numRetries = 0;\n    streamEvents(_assertThisInitialized(_assertThisInitialized(_this)));\n    cfg = cfg || {};\n\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    _this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    _this.bucket = cfg.bucket;\n    _this.file = cfg.file;\n    _this.generation = cfg.generation;\n    _this.kmsKeyName = cfg.kmsKeyName;\n    _this.metadata = cfg.metadata || {};\n    _this.offset = cfg.offset;\n    _this.origin = cfg.origin;\n    _this.userProject = cfg.userProject;\n\n    if (cfg.key) {\n      /**\n       * NOTE: This is `as string` because there appears to be some weird kind\n       * of TypeScript bug as 2.8. Tracking the issue here:\n       * https://github.com/Microsoft/TypeScript/issues/23155\n       */\n      var base64Key = Buffer.from(cfg.key).toString('base64');\n      _this.encryption = {\n        key: base64Key,\n        hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64')\n      };\n    }\n\n    _this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) _this.predefinedAcl = 'private';\n    if (cfg.public) _this.predefinedAcl = 'publicRead';\n    var configPath = cfg.configPath;\n    _this.configStore = new ConfigStore('gcs-resumable-upload', {\n      configPath: configPath\n    });\n    _this.uriProvidedManually = !!cfg.uri;\n    _this.uri = cfg.uri || _this.get('uri');\n    _this.numBytesWritten = 0;\n    _this.numRetries = 0;\n    var contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    _this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n\n    _this.once('writing', function () {\n      if (_this.uri) {\n        _this.continueUploading();\n      } else {\n        _this.createURI(function (err) {\n          if (err) {\n            return _this.destroy(err);\n          }\n\n          _this.startUploading();\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Upload, [{\n    key: \"createURI\",\n    value: function createURI(callback) {\n      if (!callback) {\n        return this.createURIAsync();\n      }\n\n      this.createURIAsync().then(function (r) {\n        return callback(null, r);\n      }, callback);\n    }\n  }, {\n    key: \"createURIAsync\",\n    value: function createURIAsync() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var metadata, reqOpts, resp, uri;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                metadata = this.metadata;\n                reqOpts = {\n                  method: 'POST',\n                  url: [BASE_URI, this.bucket, 'o'].join('/'),\n                  params: {\n                    name: this.file,\n                    uploadType: 'resumable'\n                  },\n                  data: metadata,\n                  headers: {}\n                };\n\n                if (metadata.contentLength) {\n                  reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n                }\n\n                if (metadata.contentType) {\n                  reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n                }\n\n                if (typeof this.generation !== 'undefined') {\n                  reqOpts.params.ifGenerationMatch = this.generation;\n                }\n\n                if (this.kmsKeyName) {\n                  reqOpts.params.kmsKeyName = this.kmsKeyName;\n                }\n\n                if (this.predefinedAcl) {\n                  reqOpts.params.predefinedAcl = this.predefinedAcl;\n                }\n\n                if (this.origin) {\n                  reqOpts.headers.Origin = this.origin;\n                }\n\n                _context.next = 10;\n                return this.makeRequest(reqOpts);\n\n              case 10:\n                resp = _context.sent;\n                uri = resp.headers.location;\n                this.uri = uri;\n                this.set({\n                  uri: uri\n                });\n                this.offset = 0;\n                return _context.abrupt(\"return\", uri);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"continueUploading\",\n    value: function continueUploading() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof this.offset === 'number')) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                this.startUploading();\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                _context2.next = 5;\n                return this.getAndSetOffset();\n\n              case 5:\n                this.startUploading();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"startUploading\",\n    value: function startUploading() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var bufferStream, offsetStream, delayStream, requestStreamEmbeddedStream, reqOpts;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // The buffer stream allows us to keep chunks in memory\n                // until we are sure we can successfully resume the upload.\n                bufferStream = this.bufferStream || new stream_1.PassThrough();\n                this.bufferStream = bufferStream; // The offset stream allows us to analyze each incoming\n                // chunk to analyze it against what the upstream API already\n                // has stored for this upload.\n\n                offsetStream = this.offsetStream = new stream_1.Transform({\n                  transform: this.onChunk.bind(this)\n                }); // The delay stream gives us a chance to catch the response\n                // from the API request before we signal to the user that\n                // the upload was successful.\n\n                delayStream = new stream_1.PassThrough(); // The request library (authClient.request()) requires the\n                // stream to be sent within the request options.\n\n                requestStreamEmbeddedStream = new stream_1.PassThrough();\n                delayStream.on('prefinish', function () {\n                  // Pause the stream from finishing so we can process the\n                  // response from the API.\n                  _this2.cork();\n                }); // Process the API response to look for errors that came in\n                // the response body.\n\n                this.on('response', function (resp) {\n                  if (resp.data.error) {\n                    _this2.destroy(resp.data.error);\n\n                    return;\n                  }\n\n                  if (resp.status < 200 || resp.status > 299) {\n                    _this2.destroy(new Error('Upload failed'));\n\n                    return;\n                  }\n\n                  _this2.emit('metadata', resp.data);\n\n                  _this2.deleteConfig(); // Allow the stream to continue naturally so the user's\n                  // \"finish\" event fires.\n\n\n                  _this2.uncork();\n                });\n                this.setPipeline(bufferStream, offsetStream, delayStream);\n                this.pipe(requestStreamEmbeddedStream);\n                this.once('restart', function () {\n                  // The upload is being re-attempted. Disconnect the request\n                  // stream, so it won't receive more data.\n                  _this2.unpipe(requestStreamEmbeddedStream);\n                });\n                reqOpts = {\n                  method: 'PUT',\n                  url: this.uri,\n                  headers: {\n                    'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength\n                  },\n                  body: requestStreamEmbeddedStream\n                };\n                _context3.prev = 11;\n                _context3.next = 14;\n                return this.makeRequestStream(reqOpts);\n\n              case 14:\n                _context3.next = 19;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](11);\n                this.destroy(_context3.t0);\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[11, 16]]);\n      }));\n    }\n  }, {\n    key: \"onChunk\",\n    value: function onChunk(chunk, enc, next) {\n      var offset = this.offset;\n      var numBytesWritten = this.numBytesWritten;\n      this.emit('progress', {\n        bytesWritten: this.numBytesWritten,\n        contentLength: this.contentLength\n      }); // check if this is the same content uploaded previously. this caches a\n      // slice of the first chunk, then compares it with the first byte of\n      // incoming data\n\n      if (numBytesWritten === 0) {\n        var cachedFirstChunk = this.get('firstChunk');\n        var firstChunk = chunk.slice(0, 16).valueOf();\n\n        if (!cachedFirstChunk) {\n          // This is a new upload. Cache the first chunk.\n          this.set({\n            uri: this.uri,\n            firstChunk: firstChunk\n          });\n        } else {\n          // this continues an upload in progress. check if the bytes are the same\n          cachedFirstChunk = Buffer.from(cachedFirstChunk);\n          var nextChunk = Buffer.from(firstChunk);\n\n          if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n            // this data is not the same. start a new upload\n            this.bufferStream.unshift(chunk);\n            this.bufferStream.unpipe(this.offsetStream);\n            this.restart();\n            return;\n          }\n        }\n      }\n\n      var length = chunk.length;\n      if (typeof chunk === 'string') length = Buffer.byteLength(chunk, enc);\n      if (numBytesWritten < offset) chunk = chunk.slice(offset - numBytesWritten);\n      this.numBytesWritten += length; // only push data from the byte after the one we left off on\n\n      next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n    }\n  }, {\n    key: \"getAndSetOffset\",\n    value: function getAndSetOffset() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4() {\n        var opts, resp, range, _resp;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                opts = {\n                  method: 'PUT',\n                  url: this.uri,\n                  headers: {\n                    'Content-Length': 0,\n                    'Content-Range': 'bytes */*'\n                  }\n                };\n                _context4.prev = 1;\n                _context4.next = 4;\n                return this.makeRequest(opts);\n\n              case 4:\n                resp = _context4.sent;\n\n                if (!(resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                if (!resp.headers.range) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                range = resp.headers.range;\n                this.offset = Number(range.split('-')[1]) + 1;\n                return _context4.abrupt(\"return\");\n\n              case 10:\n                this.offset = 0;\n                _context4.next = 23;\n                break;\n\n              case 13:\n                _context4.prev = 13;\n                _context4.t0 = _context4[\"catch\"](1);\n                _resp = _context4.t0.response; // we don't return a 404 to the user if they provided the resumable\n                // URI. if we're just using the configstore file to tell us that this\n                // file exists, and it turns out that it doesn't (the 404), that's\n                // probably stale config data.\n\n                if (!(_resp && _resp.status === 404 && !this.uriProvidedManually)) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                this.restart();\n                return _context4.abrupt(\"return\");\n\n              case 19:\n                if (!(_resp && _resp.status === TERMINATED_UPLOAD_STATUS_CODE)) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                this.restart();\n                return _context4.abrupt(\"return\");\n\n              case 22:\n                this.destroy(_context4.t0);\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 13]]);\n      }));\n    }\n  }, {\n    key: \"makeRequest\",\n    value: function makeRequest(reqOpts) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        var res, e;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.encryption) {\n                  reqOpts.headers = reqOpts.headers || {};\n                  reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n                  reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n                  reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n                }\n\n                if (this.userProject) {\n                  reqOpts.params = reqOpts.params || {};\n                  reqOpts.params.userProject = this.userProject;\n                }\n\n                reqOpts.validateStatus = function () {\n                  return true;\n                };\n\n                _context5.next = 5;\n                return this.authClient.request(reqOpts);\n\n              case 5:\n                res = _context5.sent;\n\n                if (!(res.data && res.data.error)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                throw res.data.error;\n\n              case 8:\n                // If no error was returned, but the response had an invalid status\n                // code, create a new error to be passed to the callback.\n                if ((res.status < 200 || res.status >= 300) && res.status !== RESUMABLE_INCOMPLETE_STATUS_CODE) {\n                  e = new Error(\"The request failed with a \".concat(res.status, \".\"));\n                  e.code = res.status;\n                }\n\n                return _context5.abrupt(\"return\", res);\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"makeRequestStream\",\n    value: function makeRequestStream(reqOpts) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6() {\n        var controller, res;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                controller = new abort_controller_1.default();\n                this.once('error', function () {\n                  return controller.abort();\n                });\n\n                if (this.userProject) {\n                  reqOpts.params = reqOpts.params || {};\n                  reqOpts.params.userProject = this.userProject;\n                }\n\n                reqOpts.signal = controller.signal;\n\n                reqOpts.validateStatus = function () {\n                  return true;\n                };\n\n                _context6.next = 7;\n                return this.authClient.request(reqOpts);\n\n              case 7:\n                res = _context6.sent;\n                this.onResponse(res);\n                return _context6.abrupt(\"return\", res);\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      var _this3 = this;\n\n      this.emit('restart');\n      this.numBytesWritten = 0;\n      this.deleteConfig();\n      this.createURI(function (err) {\n        if (err) {\n          return _this3.destroy(err);\n        }\n\n        _this3.startUploading();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(prop) {\n      var store = this.configStore.get([this.bucket, this.file].join('/'));\n      return store && store[prop];\n    } // tslint:disable-next-line no-any\n\n  }, {\n    key: \"set\",\n    value: function set(props) {\n      this.configStore.set([this.bucket, this.file].join('/'), props);\n    }\n  }, {\n    key: \"deleteConfig\",\n    value: function deleteConfig() {\n      this.configStore.delete([this.bucket, this.file].join('/'));\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n\n  }, {\n    key: \"onResponse\",\n    value: function onResponse(resp) {\n      if (resp.status === 404) {\n        if (this.numRetries < RETRY_LIMIT) {\n          this.numRetries++;\n          this.startUploading();\n        } else {\n          this.destroy(new Error('Retry limit exceeded'));\n        }\n\n        return false;\n      }\n\n      if (resp.status > 499 && resp.status < 600) {\n        if (this.numRetries < RETRY_LIMIT) {\n          var randomMs = Math.round(Math.random() * 1000);\n          var waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n          this.numRetries++;\n          setTimeout(this.continueUploading.bind(this), waitTime);\n        } else {\n          this.destroy(new Error('Retry limit exceeded'));\n        }\n\n        return false;\n      }\n\n      this.emit('response', resp);\n      return true;\n    }\n  }]);\n\n  return Upload;\n}(Pumpify);\n\nexports.Upload = Upload;\n\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\n\nexports.upload = upload;\n\nfunction createURI(cfg, callback) {\n  var up = new Upload(cfg);\n\n  if (!callback) {\n    return up.createURI();\n  }\n\n  up.createURI().then(function (r) {\n    return callback(null, r);\n  }, callback);\n}\n\nexports.createURI = createURI;","map":null,"metadata":{},"sourceType":"script"}