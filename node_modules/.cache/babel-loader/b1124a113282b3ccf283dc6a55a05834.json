{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar convert_1 = require(\"./convert\");\n\nvar field_value_1 = require(\"./field-value\");\n\nvar field_value_2 = require(\"./field-value\");\n\nvar geo_point_1 = require(\"./geo-point\");\n\nvar index_1 = require(\"./index\");\n\nvar path_1 = require(\"./path\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n/**\n * The maximum depth of a Firestore object.\n *\n * @private\n */\n\n\nvar MAX_DEPTH = 20;\n/**\n * Serializer that is used to convert between JavaScripts types and their\n * Firestore Protobuf representation.\n *\n * @private\n */\n\nvar Serializer =\n/*#__PURE__*/\nfunction () {\n  function Serializer(firestore) {\n    _classCallCheck(this, Serializer);\n\n    // Instead of storing the `firestore` object, we store just a reference to\n    // its `.doc()` method. This avoid a circular reference, which breaks\n    // JSON.stringify().\n    this.createReference = function (path) {\n      return firestore.doc(path);\n    };\n\n    if (firestore._settings.timestampsInSnapshots === undefined) {\n      this.timestampsInSnapshots = true;\n    } else {\n      this.timestampsInSnapshots = firestore._settings.timestampsInSnapshots;\n    }\n  }\n  /**\n   * Encodes a JavaScrip object into the Firestore 'Fields' representation.\n   *\n   * @private\n   * @param obj The object to encode.\n   * @returns The Firestore 'Fields' representation\n   */\n\n\n  _createClass(Serializer, [{\n    key: \"encodeFields\",\n    value: function encodeFields(obj) {\n      var fields = {};\n\n      for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          var val = this.encodeValue(obj[prop]);\n\n          if (val) {\n            fields[prop] = val;\n          }\n        }\n      }\n\n      return fields;\n    }\n    /**\n     * Encodes a JavaScript value into the Firestore 'Value' representation.\n     *\n     * @private\n     * @param val The object to encode\n     * @returns The Firestore Proto or null if we are deleting a field.\n     */\n\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(val) {\n      if (val instanceof field_value_1.FieldTransform) {\n        return null;\n      }\n\n      if (typeof val === 'string') {\n        return {\n          stringValue: val\n        };\n      }\n\n      if (typeof val === 'boolean') {\n        return {\n          booleanValue: val\n        };\n      }\n\n      if (typeof val === 'number' && !isNaN(val) && val % 1 === 0) {\n        return {\n          integerValue: val\n        };\n      } // Integers are handled above, the remaining numbers are treated as doubles\n\n\n      if (typeof val === 'number') {\n        return {\n          doubleValue: val\n        };\n      }\n\n      if (val instanceof Date) {\n        var timestamp = timestamp_1.Timestamp.fromDate(val);\n        return {\n          timestampValue: {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanoseconds\n          }\n        };\n      }\n\n      if (val === null) {\n        return {\n          nullValue: 'NULL_VALUE'\n        };\n      }\n\n      if (val instanceof Buffer || val instanceof Uint8Array) {\n        return {\n          bytesValue: val\n        };\n      }\n\n      if (util_1.isObject(val) && 'toProto' in val && typeof val.toProto === 'function') {\n        return val.toProto();\n      }\n\n      if (val instanceof Array) {\n        var array = {\n          arrayValue: {}\n        };\n\n        if (val.length > 0) {\n          array.arrayValue.values = [];\n\n          for (var i = 0; i < val.length; ++i) {\n            var enc = this.encodeValue(val[i]);\n\n            if (enc) {\n              array.arrayValue.values.push(enc);\n            }\n          }\n        }\n\n        return array;\n      }\n\n      if (typeof val === 'object' && isPlainObject(val)) {\n        var map = {\n          mapValue: {}\n        }; // If we encounter an empty object, we always need to send it to make sure\n        // the server creates a map entry.\n\n        if (!util_1.isEmpty(val)) {\n          map.mapValue.fields = this.encodeFields(val);\n\n          if (util_1.isEmpty(map.mapValue.fields)) {\n            return null;\n          }\n        }\n\n        return map;\n      }\n\n      throw new Error(\"Cannot encode value: \".concat(val));\n    }\n    /**\n     * Decodes a single Firestore 'Value' Protobuf.\n     *\n     * @private\n     * @param proto A Firestore 'Value' Protobuf.\n     * @returns The converted JS type.\n     */\n\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(proto) {\n      var valueType = convert_1.detectValueType(proto);\n\n      switch (valueType) {\n        case 'stringValue':\n          {\n            return proto.stringValue;\n          }\n\n        case 'booleanValue':\n          {\n            return proto.booleanValue;\n          }\n\n        case 'integerValue':\n          {\n            return Number(proto.integerValue);\n          }\n\n        case 'doubleValue':\n          {\n            return Number(proto.doubleValue);\n          }\n\n        case 'timestampValue':\n          {\n            var timestamp = timestamp_1.Timestamp.fromProto(proto.timestampValue);\n            return this.timestampsInSnapshots ? timestamp : timestamp.toDate();\n          }\n\n        case 'referenceValue':\n          {\n            var resourcePath = path_1.QualifiedResourcePath.fromSlashSeparatedString(proto.referenceValue);\n            return this.createReference(resourcePath.relativeName);\n          }\n\n        case 'arrayValue':\n          {\n            var array = [];\n\n            if (Array.isArray(proto.arrayValue.values)) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = proto.arrayValue.values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var value = _step.value;\n                  array.push(this.decodeValue(value));\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            }\n\n            return array;\n          }\n\n        case 'nullValue':\n          {\n            return null;\n          }\n\n        case 'mapValue':\n          {\n            var obj = {};\n            var fields = proto.mapValue.fields;\n\n            for (var prop in fields) {\n              if (fields.hasOwnProperty(prop)) {\n                obj[prop] = this.decodeValue(fields[prop]);\n              }\n            }\n\n            return obj;\n          }\n\n        case 'geoPointValue':\n          {\n            return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n          }\n\n        case 'bytesValue':\n          {\n            return proto.bytesValue;\n          }\n\n        default:\n          {\n            throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n          }\n      }\n    }\n  }]);\n\n  return Serializer;\n}();\n\nexports.Serializer = Serializer;\n/**\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\n * 'Map' in Firestore.\n *\n * @private\n * @param input The argument to verify.\n * @returns 'true' if the input can be a treated as a plain object.\n */\n\nfunction isPlainObject(input) {\n  return util_1.isObject(input) && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);\n}\n\nexports.isPlainObject = isPlainObject;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value JavaScript value to validate.\n * @param desc A description of the expected type.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether deletes are allowed in conjunction with `allowDeletes: root`.\n * @param inArray Whether we are inside an array.\n * @throws when the object is invalid.\n */\n\nfunction validateUserInput(arg, value, desc, options, path, level, inArray) {\n  if (path && path.size > MAX_DEPTH) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Input object is deeper than \").concat(MAX_DEPTH, \" levels or contains a cycle.\"));\n  }\n\n  options = options || {};\n  level = level || 0;\n  inArray = inArray || false;\n  var fieldPathMessage = path ? \" (found in field \".concat(path, \")\") : '';\n\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; ++i) {\n      validateUserInput(arg, value[i], desc, options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1,\n      /* inArray= */\n      true);\n    }\n  } else if (isPlainObject(value)) {\n    for (var prop in value) {\n      if (value.hasOwnProperty(prop)) {\n        validateUserInput(arg, value[prop], desc, options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n      }\n    }\n  } else if (value === undefined) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Cannot use \\\"undefined\\\" as a Firestore value\").concat(fieldPathMessage, \".\"));\n  } else if (value instanceof field_value_2.DeleteTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (options.allowDeletes === 'root' && level !== 0 || options.allowDeletes === 'none') {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() must appear at the top-level and can only be used in update() or set() with {merge:true}\").concat(fieldPathMessage, \".\"));\n    }\n  } else if (value instanceof field_value_1.FieldTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (!options.allowTransforms) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" \").concat(value.methodName, \"() can only be used in set(), create() or update()\").concat(fieldPathMessage, \".\"));\n    }\n  } else if (value instanceof path_1.FieldPath) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, desc), \" Cannot use object of type \\\"FieldPath\\\" as a Firestore value\").concat(fieldPathMessage, \".\"));\n  } else if (value instanceof index_1.DocumentReference) {// Ok.\n  } else if (value instanceof geo_point_1.GeoPoint) {// Ok.\n  } else if (value instanceof timestamp_1.Timestamp || value instanceof Date) {// Ok.\n  } else if (value instanceof Buffer || value instanceof Uint8Array) {// Ok.\n  } else if (value === null) {// Ok.\n  } else if (typeof value === 'object') {\n    throw new Error(validate_1.customObjectMessage(arg, value, path));\n  }\n}\n\nexports.validateUserInput = validateUserInput;","map":null,"metadata":{},"sourceType":"script"}