{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _regeneratorRuntime = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/marwan01/Desktop/Athlytics/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar bun = require(\"bun\");\n\nvar through2 = require(\"through2\");\n\nvar convert_1 = require(\"./convert\");\n\nvar document_1 = require(\"./document\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar pool_1 = require(\"./pool\");\n\nvar reference_1 = require(\"./reference\");\n\nvar reference_2 = require(\"./reference\");\n\nvar serializer_1 = require(\"./serializer\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar transaction_1 = require(\"./transaction\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n\nvar write_batch_1 = require(\"./write-batch\");\n\nvar reference_3 = require(\"./reference\");\n\nexports.CollectionReference = reference_3.CollectionReference;\nexports.DocumentReference = reference_3.DocumentReference;\nexports.QuerySnapshot = reference_3.QuerySnapshot;\nexports.Query = reference_3.Query;\n\nvar document_2 = require(\"./document\");\n\nexports.DocumentSnapshot = document_2.DocumentSnapshot;\nexports.QueryDocumentSnapshot = document_2.QueryDocumentSnapshot;\n\nvar field_value_1 = require(\"./field-value\");\n\nexports.FieldValue = field_value_1.FieldValue;\n\nvar write_batch_2 = require(\"./write-batch\");\n\nexports.WriteBatch = write_batch_2.WriteBatch;\nexports.WriteResult = write_batch_2.WriteResult;\n\nvar transaction_2 = require(\"./transaction\");\n\nexports.Transaction = transaction_2.Transaction;\n\nvar timestamp_2 = require(\"./timestamp\");\n\nexports.Timestamp = timestamp_2.Timestamp;\n\nvar document_change_1 = require(\"./document-change\");\n\nexports.DocumentChange = document_change_1.DocumentChange;\n\nvar path_2 = require(\"./path\");\n\nexports.FieldPath = path_2.FieldPath;\n\nvar geo_point_1 = require(\"./geo-point\");\n\nexports.GeoPoint = geo_point_1.GeoPoint;\n\nvar logger_2 = require(\"./logger\");\n\nexports.setLogFunction = logger_2.setLogFunction;\n\nvar libVersion = require('../../package.json').version;\n\nlogger_1.setLibVersion(libVersion);\n/*!\n * DO NOT REMOVE THE FOLLOWING NAMESPACE DEFINITIONS\n */\n\n/**\n * @namespace google.protobuf\n */\n\n/**\n * @namespace google.rpc\n */\n\n/**\n * @namespace google.longrunning\n */\n\n/**\n * @namespace google.firestore.v1\n */\n\n/**\n * @namespace google.firestore.v1beta1\n */\n\n/**\n * @namespace google.firestore.admin.v1\n */\n\n/*!\n * @see v1\n */\n\nvar v1; // Lazy-loaded in `_runRequest()`\n\n/*!\n * @see v1beta1\n */\n\nvar v1beta1; // Lazy-loaded upon access.\n\n/*!\n * HTTP header for the resource prefix to improve routing and project isolation\n * by the backend.\n */\n\nvar CLOUD_RESOURCE_HEADER = 'google-cloud-resource-prefix';\n/*!\n * The maximum number of times to retry idempotent requests.\n */\n\nvar MAX_REQUEST_RETRIES = 5;\n/*!\n * The maximum number of concurrent requests supported by a single GRPC channel,\n * as enforced by Google's Frontend. If the SDK issues more than 100 concurrent\n * operations, we need to use more than one GAPIC client since these clients\n * multiplex all requests over a single channel.\n */\n\nvar MAX_CONCURRENT_REQUESTS_PER_CLIENT = 100;\n/*!\n * GRPC Error code for 'UNAVAILABLE'.\n */\n\nvar GRPC_UNAVAILABLE = 14;\n/**\n * Document data (e.g. for use with\n * [set()]{@link DocumentReference#set}) consisting of fields mapped\n * to values.\n *\n * @typedef {Object.<string, *>} DocumentData\n */\n\n/**\n * Update data (for use with [update]{@link DocumentReference#update})\n * that contains paths (e.g. 'foo' or 'foo.baz') mapped to values. Fields that\n * contain dots reference nested fields within the document.\n *\n * @typedef {Object.<string, *>} UpdateData\n */\n\n/**\n * An options object that configures conditional behavior of\n * [update()]{@link DocumentReference#update} and\n * [delete()]{@link DocumentReference#delete} calls in\n * [DocumentReference]{@link DocumentReference},\n * [WriteBatch]{@link WriteBatch}, and\n * [Transaction]{@link Transaction}. Using Preconditions, these calls\n * can be restricted to only apply to documents that match the specified\n * conditions.\n *\n * @property {string} lastUpdateTime The update time to enforce (specified as\n * an ISO 8601 string).\n * @typedef {Object} Precondition\n */\n\n/**\n * An options object that configures the behavior of\n * [set()]{@link DocumentReference#set} calls in\n * [DocumentReference]{@link DocumentReference},\n * [WriteBatch]{@link WriteBatch}, and\n * [Transaction]{@link Transaction}. These calls can be\n * configured to perform granular merges instead of overwriting the target\n * documents in their entirety by providing a SetOptions object with\n * { merge : true }.\n *\n * @property {boolean} merge Changes the behavior of a set() call to only\n * replace the values specified in its data argument. Fields omitted from the\n * set() call remain untouched.\n * @property {Array<(string|FieldPath)>} mergeFields Changes the behavior of\n * set() calls to only replace the specified field paths. Any field path that is\n * not specified is ignored and remains untouched.\n * It is an error to pass a SetOptions object to a set() call that is missing a\n * value for any of the fields specified here.\n * @typedef {Object} SetOptions\n */\n\n/**\n * An options object that can be used to configure the behavior of\n * [getAll()]{@link Firestore#getAll} calls. By providing a `fieldMask`, these\n * calls can be configured to only return a subset of fields.\n *\n * @property {Array<(string|FieldPath)>} fieldMask Specifies the set of fields\n * to return and reduces the amount of data transmitted by the backend.\n * Adding a field mask does not filter results. Documents do not need to\n * contain values for all the fields in the mask to be part of the result set.\n * @typedef {Object} ReadOptions\n */\n\n/**\n * The Firestore client represents a Firestore Database and is the entry point\n * for all Firestore operations.\n *\n * @see [Firestore Documentation]{@link https://firebase.google.com/docs/firestore/}\n *\n * @class\n *\n * @example <caption>Install the client library with <a\n * href=\"https://www.npmjs.com/\">npm</a>:</caption> npm install --save\n * @google-cloud/firestore\n *\n * @example <caption>Import the client library</caption>\n * var Firestore = require('@google-cloud/firestore');\n *\n * @example <caption>Create a client that uses <a\n * href=\"https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\">Application\n * Default Credentials (ADC)</a>:</caption> var firestore = new Firestore();\n *\n * @example <caption>Create a client with <a\n * href=\"https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually\">explicit\n * credentials</a>:</caption> var firestore = new Firestore({ projectId:\n * 'your-project-id', keyFilename: '/path/to/keyfile.json'\n * });\n *\n * @example <caption>include:samples/quickstart.js</caption>\n * region_tag:firestore_quickstart\n * Full quickstart example:\n */\n\nvar Firestore =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object=} settings [Configuration object](#/docs).\n   * @param {string=} settings.projectId The project ID from the Google\n   * Developer's Console, e.g. 'grape-spaceship-123'. We will also check the\n   * environment variable GCLOUD_PROJECT for your project ID.  Can be omitted in\n   * environments that support\n   * {@link https://cloud.google.com/docs/authentication Application Default\n   * Credentials}\n   * @param {string=} settings.keyFilename Local file containing the Service\n   * Account credentials as downloaded from the Google Developers Console. Can\n   * be omitted in environments that support\n   * {@link https://cloud.google.com/docs/authentication Application Default\n   * Credentials}. To configure Firestore with custom credentials, use\n   * `settings.credentials` and provide the `client_email` and `private_key` of\n   * your service account.\n   * @param {{client_email:string=, private_key:string=}=} settings.credentials\n   * The `client_email` and `private_key` properties of the service account\n   * to use with your Firestore project. Can be omitted in environments that\n   * support {@link https://cloud.google.com/docs/authentication Application\n   * Default Credentials}. If your credentials are stored in a JSON file, you\n   * can specify a `keyFilename` instead.\n   * @param {boolean=} settings.timestampsInSnapshots Specifies whether to use\n   * `Timestamp` objects for timestamp fields in `DocumentSnapshot`s. This is\n   * enabled by default and should not be disabled.\n   * <br/>Previously, Firestore returned timestamp fields as `Date` but `Date`\n   * only supports millisecond precision, which leads to truncation and causes\n   * unexpected behavior when using a timestamp from a snapshot as a part of a\n   * subsequent query.\n   * <br/>So now Firestore returns `Timestamp` values instead of `Date`,\n   * avoiding this kind of problem.\n   * <br/>To opt into the old behavior of returning `Date` objects, you can\n   * temporarily set `timestampsInSnapshots` to false.\n   * <br/>WARNING: This setting will be removed in a future release. You should\n   * update your code to expect `Timestamp` objects and stop using the\n   * `timestampsInSnapshots` setting.\n   */\n  function Firestore(settings) {\n    var _this = this;\n\n    _classCallCheck(this, Firestore);\n\n    /**\n     * The configuration options for the GAPIC client.\n     * @private\n     */\n    this._settings = {};\n    /**\n     * Whether the initialization settings can still be changed by invoking\n     * `settings()`.\n     * @private\n     */\n\n    this._settingsFrozen = false;\n    /**\n     * The serializer to use for the Protobuf transformation.\n     * @private\n     */\n\n    this._serializer = null;\n    /**\n     * The project ID for this client.\n     *\n     * The project ID is auto-detected during the first request unless a project\n     * ID is passed to the constructor (or provided via `.settings()`).\n     * @private\n     */\n\n    this._projectId = undefined;\n    /** @private */\n\n    this._lastSuccessfulRequest = 0;\n    var libraryHeader = {\n      libName: 'gccl',\n      libVersion: libVersion\n    };\n\n    if (settings && settings.firebaseVersion) {\n      libraryHeader.libVersion += ' fire/' + settings.firebaseVersion;\n    }\n\n    this.validateAndApplySettings(Object.assign({}, settings, libraryHeader)); // GCF currently tears down idle connections after two minutes. Requests\n    // that are issued after this period may fail. On GCF, we therefore issue\n    // these requests as part of a transaction so that we can safely retry until\n    // the network link is reestablished.\n    //\n    // The environment variable FUNCTION_TRIGGER_TYPE is used to detect the GCF\n    // environment.\n\n    this._preferTransactions = process.env.FUNCTION_TRIGGER_TYPE !== undefined;\n    this._lastSuccessfulRequest = 0;\n\n    if (this._preferTransactions) {\n      logger_1.logger('Firestore', null, 'Detected GCF environment');\n    }\n\n    this._clientPool = new pool_1.ClientPool(MAX_CONCURRENT_REQUESTS_PER_CLIENT, function () {\n      var client = new module.exports.v1(_this._settings);\n      logger_1.logger('Firestore', null, 'Initialized Firestore GAPIC Client');\n      return client;\n    });\n    logger_1.logger('Firestore', null, 'Initialized Firestore');\n  }\n  /**\n   * Specifies custom settings to be used to configure the `Firestore`\n   * instance. Can only be invoked once and before any other Firestore method.\n   *\n   * If settings are provided via both `settings()` and the `Firestore`\n   * constructor, both settings objects are merged and any settings provided via\n   * `settings()` take precedence.\n   *\n   * @param {object} settings The settings to use for all Firestore operations.\n   */\n\n\n  _createClass(Firestore, [{\n    key: \"settings\",\n    value: function settings(_settings) {\n      validate_1.validateObject('settings', _settings);\n      validate_1.validateString('settings.projectId', _settings.projectId, {\n        optional: true\n      });\n      validate_1.validateBoolean('settings.timestampsInSnapshots', _settings.timestampsInSnapshots, {\n        optional: true\n      });\n\n      if (this._settingsFrozen) {\n        throw new Error('Firestore has already been initialized. You can only call ' + 'settings() once, and only before calling any other methods on a ' + 'Firestore object.');\n      }\n\n      var mergedSettings = Object.assign({}, this._settings, _settings);\n      this.validateAndApplySettings(mergedSettings);\n      this._settingsFrozen = true;\n    }\n  }, {\n    key: \"validateAndApplySettings\",\n    value: function validateAndApplySettings(settings) {\n      validate_1.validateBoolean('settings.timestampsInSnapshots', settings.timestampsInSnapshots, {\n        optional: true\n      });\n\n      if (settings && settings.projectId) {\n        validate_1.validateString('settings.projectId', settings.projectId);\n        this._projectId = settings.projectId;\n      }\n\n      this._settings = settings;\n      this._serializer = new serializer_1.Serializer(this);\n    }\n    /**\n     * Returns the Project ID for this Firestore instance. Validates that\n     * `initializeIfNeeded()` was called before.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"doc\",\n\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path.\n     *\n     * @param {string} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The\n     * [DocumentReference]{@link DocumentReference} instance.\n     *\n     * @example\n     * let documentRef = firestore.doc('collection/document');\n     * console.log(`Path of document is ${documentRef.path}`);\n     */\n    value: function doc(documentPath) {\n      path_1.validateResourcePath('documentPath', documentPath);\n      var path = path_1.ResourcePath.EMPTY.append(documentPath);\n\n      if (!path.isDocument) {\n        throw new Error(\"Value for argument \\\"documentPath\\\" must point to a document, but was \\\"\".concat(documentPath, \"\\\". Your path does not contain an even number of components.\"));\n      }\n\n      return new reference_2.DocumentReference(this, path);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} The\n     * [CollectionReference]{@link CollectionReference} instance.\n     *\n     * @example\n     * let collectionRef = firestore.collection('collection');\n     *\n     * // Add a document with an auto-generated ID.\n     * collectionRef.add({foo: 'bar'}).then((documentRef) => {\n     *   console.log(`Added document at ${documentRef.path})`);\n     * });\n     */\n\n  }, {\n    key: \"collection\",\n    value: function collection(collectionPath) {\n      path_1.validateResourcePath('collectionPath', collectionPath);\n      var path = path_1.ResourcePath.EMPTY.append(collectionPath);\n\n      if (!path.isCollection) {\n        throw new Error(\"Value for argument \\\"collectionPath\\\" must point to a collection, but was \\\"\".concat(collectionPath, \"\\\". Your path does not contain an odd number of components.\"));\n      }\n\n      return new reference_1.CollectionReference(this, path);\n    }\n    /**\n     * Creates a [WriteBatch]{@link WriteBatch}, used for performing\n     * multiple writes as a single atomic operation.\n     *\n     * @returns {WriteBatch} A WriteBatch that operates on this Firestore\n     * client.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     *\n     * // Add two documents in an atomic batch.\n     * let data = { foo: 'bar' };\n     * writeBatch.set(firestore.doc('col/doc1'), data);\n     * writeBatch.set(firestore.doc('col/doc2'), data);\n     *\n     * writeBatch.commit().then(res => {\n     *   console.log(`Added document at ${res.writeResults[0].updateTime}`);\n     * });\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      return new write_batch_1.WriteBatch(this);\n    }\n  }, {\n    key: \"snapshot_\",\n    value: function snapshot_(documentOrName, readTime, encoding) {\n      // TODO: Assert that Firestore Project ID is valid.\n      var convertTimestamp;\n      var convertFields;\n\n      if (encoding === undefined || encoding === 'protobufJS') {\n        convertTimestamp = function convertTimestamp(data) {\n          return data;\n        };\n\n        convertFields = function convertFields(data) {\n          return data;\n        };\n      } else if (encoding === 'json') {\n        // Google Cloud Functions calls us with Proto3 JSON format data, which we\n        // must convert to Protobuf JS.\n        convertTimestamp = convert_1.timestampFromJson;\n        convertFields = convert_1.fieldsFromJson;\n      } else {\n        throw new Error(\"Unsupported encoding format. Expected \\\"json\\\" or \\\"protobufJS\\\", \" + \"but was \\\"\".concat(encoding, \"\\\".\"));\n      }\n\n      var document = new document_1.DocumentSnapshotBuilder();\n\n      if (typeof documentOrName === 'string') {\n        document.ref = new reference_2.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName));\n      } else {\n        document.ref = new reference_2.DocumentReference(this, path_1.QualifiedResourcePath.fromSlashSeparatedString(documentOrName.name));\n        document.fieldsProto = documentOrName.fields ? convertFields(documentOrName.fields) : {};\n        document.createTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.createTime, 'documentOrName.createTime'));\n        document.updateTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.updateTime, 'documentOrName.updateTime'));\n      }\n\n      if (readTime) {\n        document.readTime = timestamp_1.Timestamp.fromProto(convertTimestamp(readTime, 'readTime'));\n      }\n\n      return document.build();\n    }\n    /**\n     * Executes the given updateFunction and commits the changes applied within\n     * the transaction.\n     *\n     * You can use the transaction object passed to 'updateFunction' to read and\n     * modify Firestore documents under lock. Transactions are committed once\n     * 'updateFunction' resolves and attempted up to five times on failure.\n     *\n     * @param {function(Transaction)} updateFunction The function to execute\n     * within the transaction context.\n     * @param {object=} transactionOptions Transaction options.\n     * @param {number=} transactionOptions.maxAttempts - The maximum number of\n     * attempts for this transaction.\n     * @returns {Promise} If the transaction completed successfully or was\n     * explicitly aborted (by the updateFunction returning a failed Promise), the\n     * Promise returned by the updateFunction will be returned here. Else if the\n     * transaction failed, a rejected Promise with the corresponding failure\n     * error will be returned.\n     *\n     * @example\n     * let counterTransaction = firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       let count =  doc.get('count') || 0;\n     *       if (count > 10) {\n     *         return Promise.reject('Reached maximum count');\n     *       }\n     *       transaction.update(documentRef, { count: ++count });\n     *       return Promise.resolve(count);\n     *     }\n     *\n     *     transaction.create(documentRef, { count: 1 });\n     *     return Promise.resolve(1);\n     *   });\n     * });\n     *\n     * counterTransaction.then(res => {\n     *   console.log(`Count updated to ${res}`);\n     * });\n     */\n\n  }, {\n    key: \"runTransaction\",\n    value: function runTransaction(updateFunction, transactionOptions) {\n      var _this2 = this;\n\n      validate_1.validateFunction('updateFunction', updateFunction);\n\n      if (transactionOptions) {\n        validate_1.validateObject('transactionOptions', transactionOptions);\n        validate_1.validateInteger('transactionOptions.maxAttempts', transactionOptions.maxAttempts, {\n          optional: true,\n          minValue: 1\n        });\n      }\n\n      return this.initializeIfNeeded().then(function () {\n        return _this2._runTransaction(updateFunction, transactionOptions);\n      });\n    }\n  }, {\n    key: \"_runTransaction\",\n    value: function _runTransaction(updateFunction, transactionOptions) {\n      var _this3 = this;\n\n      var defaultAttempts = 5;\n      var attemptsRemaining = defaultAttempts;\n      var previousTransaction;\n\n      if (transactionOptions) {\n        attemptsRemaining = transactionOptions.maxAttempts || attemptsRemaining;\n        previousTransaction = transactionOptions.previousTransaction;\n      }\n\n      var transaction = new transaction_1.Transaction(this, previousTransaction);\n      var requestTag = transaction.requestTag;\n      var result;\n      --attemptsRemaining;\n      return transaction.begin().then(function () {\n        var promise = updateFunction(transaction);\n        result = promise instanceof Promise ? promise : Promise.reject(new Error('You must return a Promise in your transaction()-callback.'));\n        return result.catch(function (err) {\n          logger_1.logger('Firestore.runTransaction', requestTag, 'Rolling back transaction after callback error:', err); // Rollback the transaction and return the failed result.\n\n          return transaction.rollback().then(function () {\n            return result;\n          });\n        });\n      }).then(function () {\n        return transaction.commit().then(function () {\n          return result;\n        }).catch(function (err) {\n          if (attemptsRemaining > 0) {\n            logger_1.logger('Firestore.runTransaction', requestTag, \"Retrying transaction after error: \".concat(JSON.stringify(err), \".\"));\n            return _this3._runTransaction(updateFunction, {\n              previousTransaction: transaction,\n              maxAttempts: attemptsRemaining\n            });\n          }\n\n          logger_1.logger('Firestore.runTransaction', requestTag, 'Exhausted transaction retries, returning error: %s', err);\n          return Promise.reject(err);\n        });\n      });\n    }\n    /**\n     * Fetches the root collections that are associated with this Firestore\n     * database.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * firestore.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found collection with id: ${collection.id}`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"listCollections\",\n    value: function listCollections() {\n      var rootDocument = new reference_2.DocumentReference(this, path_1.ResourcePath.EMPTY);\n      return rootDocument.listCollections();\n    }\n    /**\n     * Fetches the root collections that are associated with this Firestore\n     * database.\n     *\n     * @deprecated Use `.listCollections()`.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     */\n\n  }, {\n    key: \"getCollections\",\n    value: function getCollections() {\n      return this.listCollections();\n    }\n    /**\n     * Retrieves multiple documents from Firestore.\n     *\n     * The first argument is required and must be of type `DocumentReference`\n     * followed by any additional `DocumentReference` documents. If used, the\n     * optional `ReadOptions` must be the last argument.\n     *\n     * @param {Array.<DocumentReference|ReadOptions>} documentRefsOrReadOptions\n     * The `DocumentReferences` to receive, followed by an optional field\n     * mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * let docRef1 = firestore.doc('col/doc1');\n     * let docRef2 = firestore.doc('col/doc2');\n     *\n     * firestore.getAll(docRef1, docRef2, { fieldMask: ['user'] }).then(docs => {\n     *   console.log(`First document: ${JSON.stringify(docs[0])}`);\n     *   console.log(`Second document: ${JSON.stringify(docs[1])}`);\n     * });\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      var _this4 = this;\n\n      for (var _len = arguments.length, documentRefsOrReadOptions = new Array(_len), _key = 0; _key < _len; _key++) {\n        documentRefsOrReadOptions[_key] = arguments[_key];\n      }\n\n      validate_1.validateMinNumberOfArguments('Firestore.getAll', arguments, 1);\n\n      var _transaction_1$parseG = transaction_1.parseGetAllArguments(documentRefsOrReadOptions),\n          documents = _transaction_1$parseG.documents,\n          fieldMask = _transaction_1$parseG.fieldMask;\n\n      return this.initializeIfNeeded().then(function () {\n        return _this4.getAll_(documents, fieldMask, util_1.requestTag());\n      });\n    }\n    /**\n     * Internal method to retrieve multiple documents from Firestore, optionally\n     * as part of a transaction.\n     *\n     * @private\n     * @param docRefs The documents to receive.\n     * @param fieldMask An optional field mask to apply to this read.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param transactionId The transaction ID to use for this read.\n     * @returns A Promise that contains an array with the resulting documents.\n     */\n\n  }, {\n    key: \"getAll_\",\n    value: function getAll_(docRefs, fieldMask, requestTag, transactionId) {\n      var requestedDocuments = new Set();\n      var retrievedDocuments = new Map();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = docRefs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var docRef = _step.value;\n          requestedDocuments.add(docRef.formattedName);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var request = {\n        database: this.formattedName,\n        transaction: transactionId,\n        documents: Array.from(requestedDocuments)\n      };\n\n      if (fieldMask) {\n        var fieldPaths = fieldMask.map(function (fieldPath) {\n          return fieldPath.formattedName;\n        });\n        request.mask = {\n          fieldPaths: fieldPaths\n        };\n      }\n\n      var self = this;\n      return self.readStream('batchGetDocuments', request, requestTag, true).then(function (stream) {\n        return new Promise(function (resolve, reject) {\n          stream.on('error', function (err) {\n            logger_1.logger('Firestore.getAll_', requestTag, 'GetAll failed with error:', err);\n            reject(err);\n          }).on('data', function (response) {\n            try {\n              var document;\n\n              if (response.found) {\n                logger_1.logger('Firestore.getAll_', requestTag, 'Received document: %s', response.found.name);\n                document = self.snapshot_(response.found, response.readTime);\n              } else {\n                logger_1.logger('Firestore.getAll_', requestTag, 'Document missing: %s', response.missing);\n                document = self.snapshot_(response.missing, response.readTime);\n              }\n\n              var path = document.ref.path;\n              retrievedDocuments.set(path, document);\n            } catch (err) {\n              logger_1.logger('Firestore.getAll_', requestTag, 'GetAll failed with exception:', err);\n              reject(err);\n            }\n          }).on('end', function () {\n            logger_1.logger('Firestore.getAll_', requestTag, 'Received %d results', retrievedDocuments.size); // BatchGetDocuments doesn't preserve document order. We use\n            // the request order to sort the resulting documents.\n\n            var orderedDocuments = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = docRefs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var docRef = _step2.value;\n                var document = retrievedDocuments.get(docRef.path);\n\n                if (document === undefined) {\n                  reject(new Error(\"Did not receive document for \\\"\".concat(docRef.path, \"\\\".\")));\n                }\n\n                orderedDocuments.push(document);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            resolve(orderedDocuments);\n          });\n          stream.resume();\n        });\n      });\n    }\n    /**\n     * Initializes the client if it is not already initialized. All methods in the\n     * SDK can be used after this method completes.\n     *\n     * @private\n     * @return A Promise that resolves when the client is initialized.\n     */\n\n  }, {\n    key: \"initializeIfNeeded\",\n    value: function initializeIfNeeded() {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._settingsFrozen) {\n                  // Nobody should set timestampsInSnapshots anymore, but the error depends\n                  // on whether they set it to true or false...\n                  if (this._settings.timestampsInSnapshots === true) {\n                    console.error(\"\\n  The timestampsInSnapshots setting now defaults to true and you no\\n  longer need to explicitly set it. In a future release, the setting\\n  will be removed entirely and so it is recommended that you remove it\\n  from your firestore.settings() call now.\");\n                  } else if (this._settings.timestampsInSnapshots === false) {\n                    console.error(\"\\n  The timestampsInSnapshots setting will soon be removed. YOU MUST UPDATE\\n  YOUR CODE.\\n\\n  To hide this warning, stop using the timestampsInSnapshots setting in your\\n  firestore.settings({ ... }) call.\\n\\n  Once you remove the setting, Timestamps stored in Cloud Firestore will be\\n  read back as Firebase Timestamp objects instead of as system Date objects.\\n  So you will also need to update code expecting a Date to instead expect a\\n  Timestamp. For example:\\n\\n  // Old:\\n  const date = snapshot.get('created_at');\\n  // New:\\n  const timestamp = snapshot.get('created_at');\\n  const date = timestamp.toDate();\\n\\n  Please audit all existing usages of Date when you enable the new\\n  behavior.\");\n                  }\n                }\n\n                this._settingsFrozen = true;\n\n                if (!(this._projectId === undefined)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 5;\n                return this._clientPool.run(function (gapicClient) {\n                  return new Promise(function (resolve, reject) {\n                    gapicClient.getProjectId(function (err, projectId) {\n                      if (err) {\n                        logger_1.logger('Firestore._detectProjectId', null, 'Failed to detect project ID: %s', err);\n                        reject(err);\n                      } else {\n                        logger_1.logger('Firestore._detectProjectId', null, 'Detected project ID: %s', projectId);\n                        resolve(projectId);\n                      }\n                    });\n                  });\n                });\n\n              case 5:\n                this._projectId = _context.sent;\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Returns GAX call options that set the cloud resource header.\n     * @private\n     */\n\n  }, {\n    key: \"createCallOptions\",\n    value: function createCallOptions() {\n      var gaxHeaders = {\n        otherArgs: {\n          headers: {}\n        }\n      };\n      gaxHeaders.otherArgs.headers[CLOUD_RESOURCE_HEADER] = this.formattedName;\n      return gaxHeaders;\n    }\n    /**\n     * A function returning a Promise that can be retried.\n     *\n     * @private\n     * @callback retryFunction\n     * @returns {Promise} A Promise indicating the function's success.\n     */\n\n    /**\n     * Helper method that retries failed Promises.\n     *\n     * If 'delayMs' is specified, waits 'delayMs' between invocations. Otherwise,\n     * schedules the first attempt immediately, and then waits 100 milliseconds\n     * for further attempts.\n     *\n     * @private\n     * @param attemptsRemaining The number of available attempts.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param func Method returning a Promise than can be retried.\n     * @param delayMs How long to wait before issuing a this retry. Defaults to\n     * zero.\n     * @returns  - A Promise with the function's result if successful within\n     * `attemptsRemaining`. Otherwise, returns the last rejected Promise.\n     */\n\n  }, {\n    key: \"_retry\",\n    value: function _retry(attemptsRemaining, requestTag, func) {\n      var delayMs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var self = this;\n      var currentDelay = delayMs;\n      var nextDelay = delayMs || 100;\n      --attemptsRemaining;\n      return new Promise(function (resolve) {\n        setTimeout(resolve, currentDelay);\n      }).then(func).then(function (result) {\n        self._lastSuccessfulRequest = new Date().getTime();\n        return result;\n      }).catch(function (err) {\n        if (err.code !== undefined && err.code !== GRPC_UNAVAILABLE) {\n          logger_1.logger('Firestore._retry', requestTag, 'Request failed with unrecoverable error:', err);\n          return Promise.reject(err);\n        }\n\n        if (attemptsRemaining === 0) {\n          logger_1.logger('Firestore._retry', requestTag, 'Request failed with error:', err);\n          return Promise.reject(err);\n        }\n\n        logger_1.logger('Firestore._retry', requestTag, 'Retrying request that failed with error:', err);\n        return self._retry(attemptsRemaining, requestTag, func, nextDelay);\n      });\n    }\n  }, {\n    key: \"_initializeStream\",\n    value: function _initializeStream(resultStream, requestTag, request) {\n      /** The last error we received and have not forwarded yet. */\n      var errorReceived = null;\n      /**\n       * Whether we have resolved the Promise and returned the stream to the\n       * caller.\n       */\n\n      var streamReleased = false;\n      /**\n       * Whether the stream end has been reached. This has to be forwarded to the\n       * caller..\n       */\n\n      var endCalled = false;\n      return new Promise(function (resolve, reject) {\n        var releaseStream = function releaseStream() {\n          if (errorReceived) {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Emit error:', errorReceived);\n            resultStream.emit('error', errorReceived);\n            errorReceived = null;\n          } else if (!streamReleased) {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Releasing stream');\n            streamReleased = true;\n            resultStream.pause(); // Calling 'stream.pause()' only holds up 'data' events and not the\n            // 'end' event we intend to forward here. We therefore need to wait\n            // until the API consumer registers their listeners (in the .then()\n            // call) before emitting any further events.\n\n            resolve(resultStream); // We execute the forwarding of the 'end' event via setTimeout() as\n            // V8 guarantees that the above the Promise chain is resolved before\n            // any calls invoked via setTimeout().\n\n            setTimeout(function () {\n              if (endCalled) {\n                logger_1.logger('Firestore._initializeStream', requestTag, 'Forwarding stream close');\n                resultStream.emit('end');\n              }\n            }, 0);\n          }\n        }; // We capture any errors received and buffer them until the caller has\n        // registered a listener. We register our event handler as early as\n        // possible to avoid the default stream behavior (which is just to log and\n        // continue).\n\n\n        resultStream.on('readable', function () {\n          releaseStream();\n        });\n        resultStream.on('end', function () {\n          logger_1.logger('Firestore._initializeStream', requestTag, 'Received stream end');\n          endCalled = true;\n          releaseStream();\n        });\n        resultStream.on('error', function (err) {\n          logger_1.logger('Firestore._initializeStream', requestTag, 'Received stream error:', err); // If we receive an error before we were able to receive any data,\n          // reject this stream.\n\n          if (!streamReleased) {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Received initial error:', err);\n            streamReleased = true;\n            reject(err);\n          } else {\n            errorReceived = err;\n          }\n        });\n\n        if (request) {\n          logger_1.logger('Firestore._initializeStream', requestTag, 'Sending request: %j', request);\n          resultStream // The stream returned by the Gapic library accepts Protobuf\n          // messages, but the type information does not expose this.\n          // tslint:disable-next-line no-any\n          .write(request, 'utf-8', function () {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Marking stream as healthy');\n            releaseStream();\n          });\n        }\n      });\n    }\n    /**\n     * A funnel for all non-streaming API requests, assigning a project ID where\n     *  necessary within the request options.\n     *\n     * @private\n     * @param methodName Name of the veneer API endpoint that takes a request\n     * and GAX options.\n     * @param request The Protobuf request to send.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param allowRetries Whether this is an idempotent request that can be\n     * retried.\n     * @returns A Promise with the request result.\n     */\n\n  }, {\n    key: \"request\",\n    value: function request(methodName, _request, requestTag, allowRetries) {\n      var _this5 = this;\n\n      var attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;\n      var callOptions = this.createCallOptions();\n      return this._clientPool.run(function (gapicClient) {\n        return _this5._retry(attempts, requestTag, function () {\n          return new Promise(function (resolve, reject) {\n            logger_1.logger('Firestore.request', requestTag, 'Sending request: %j', _request);\n            gapicClient[methodName](_request, callOptions, function (err, result) {\n              if (err) {\n                logger_1.logger('Firestore.request', requestTag, 'Received error:', err);\n                reject(err);\n              } else {\n                logger_1.logger('Firestore.request', requestTag, 'Received response: %j', result);\n                resolve(result);\n              }\n            });\n          });\n        });\n      });\n    }\n    /**\n     * A funnel for read-only streaming API requests, assigning a project ID where\n     * necessary within the request options.\n     *\n     * The stream is returned in paused state and needs to be resumed once all\n     * listeners are attached.\n     *\n     * @private\n     * @param methodName Name of the streaming Veneer API endpoint that\n     * takes a request and GAX options.\n     * @param request The Protobuf request to send.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param allowRetries Whether this is an idempotent request that can be\n     * retried.\n     * @returns A Promise with the resulting read-only stream.\n     */\n\n  }, {\n    key: \"readStream\",\n    value: function readStream(methodName, request, requestTag, allowRetries) {\n      var _this6 = this;\n\n      var attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;\n      var callOptions = this.createCallOptions();\n      return this._clientPool.run(function (gapicClient) {\n        return _this6._retry(attempts, requestTag, function () {\n          return new Promise(function (resolve, reject) {\n            try {\n              logger_1.logger('Firestore.readStream', requestTag, 'Sending request: %j', request);\n              var stream = gapicClient[methodName](request, callOptions);\n              var logStream = through2.obj(function (chunk, enc, callback) {\n                logger_1.logger('Firestore.readStream', requestTag, 'Received response: %j', chunk);\n                this.push(chunk);\n                callback();\n              });\n              resolve(bun([stream, logStream]));\n            } catch (err) {\n              logger_1.logger('Firestore.readStream', requestTag, 'Received error:', err);\n              reject(err);\n            }\n          }).then(function (stream) {\n            return _this6._initializeStream(stream, requestTag);\n          });\n        });\n      });\n    }\n    /**\n     * A funnel for read-write streaming API requests, assigning a project ID\n     * where necessary for all writes.\n     *\n     * The stream is returned in paused state and needs to be resumed once all\n     * listeners are attached.\n     *\n     * @private\n     * @param methodName Name of the streaming Veneer API endpoint that takes\n     * GAX options.\n     * @param request The Protobuf request to send as the first stream message.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param allowRetries Whether this is an idempotent request that can be\n     * retried.\n     * @returns A Promise with the resulting read/write stream.\n     */\n\n  }, {\n    key: \"readWriteStream\",\n    value: function readWriteStream(methodName, request, requestTag, allowRetries) {\n      var _this7 = this;\n\n      var attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;\n      var callOptions = this.createCallOptions();\n      return this._clientPool.run(function (gapicClient) {\n        return _this7._retry(attempts, requestTag, function () {\n          return Promise.resolve().then(function () {\n            logger_1.logger('Firestore.readWriteStream', requestTag, 'Opening stream');\n            var requestStream = gapicClient[methodName](callOptions);\n            var logStream = through2.obj(function (chunk, enc, callback) {\n              logger_1.logger('Firestore.readWriteStream', requestTag, 'Received response: %j', chunk);\n              this.push(chunk);\n              callback();\n            });\n            var resultStream = bun([requestStream, logStream]);\n            return _this7._initializeStream(resultStream, requestTag, request);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"projectId\",\n    get: function get() {\n      if (this._projectId === undefined) {\n        throw new Error('INTERNAL ERROR: Client is not yet ready to issue requests.');\n      }\n\n      return this._projectId;\n    }\n    /**\n     * Returns the root path of the database. Validates that\n     * `initializeIfNeeded()` was called before.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"formattedName\",\n    get: function get() {\n      return \"projects/\".concat(this.projectId, \"/databases/\").concat(path_1.DEFAULT_DATABASE_ID);\n    }\n  }]);\n\n  return Firestore;\n}();\n\nexports.Firestore = Firestore;\n/**\n * A logging function that takes a single string.\n *\n * @callback Firestore~logFunction\n * @param {string} Log message\n */\n// tslint:disable-next-line:no-default-export\n\n/**\n * The default export of the `@google-cloud/firestore` package is the\n * {@link Firestore} class.\n *\n * See {@link Firestore} and {@link ClientConfig} for client methods and\n * configuration options.\n *\n * @module {Firestore} @google-cloud/firestore\n * @alias nodejs-firestore\n *\n * @example <caption>Install the client library with <a\n * href=\"https://www.npmjs.com/\">npm</a>:</caption> npm install --save\n * @google-cloud/firestore\n *\n * @example <caption>Import the client library</caption>\n * var Firestore = require('@google-cloud/firestore');\n *\n * @example <caption>Create a client that uses <a\n * href=\"https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\">Application\n * Default Credentials (ADC)</a>:</caption> var firestore = new Firestore();\n *\n * @example <caption>Create a client with <a\n * href=\"https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually\">explicit\n * credentials</a>:</caption> var firestore = new Firestore({ projectId:\n * 'your-project-id', keyFilename: '/path/to/keyfile.json'\n * });\n *\n * @example <caption>include:samples/quickstart.js</caption>\n * region_tag:firestore_quickstart\n * Full quickstart example:\n */\n// tslint:disable-next-line:no-default-export\n\nexports.default = Firestore; // Horrible hack to ensure backwards compatibility with <= 17.0, which allows\n// users to call the default constructor via\n// `const Fs = require(`@google-cloud/firestore`); new Fs()`;\n\nvar existingExports = module.exports;\nmodule.exports = Firestore;\nmodule.exports = Object.assign(module.exports, existingExports);\n/**\n * {@link v1beta1} factory function.\n *\n * @private\n * @name Firestore.v1beta1\n * @see v1beta1\n * @type {function}\n */\n\nObject.defineProperty(module.exports, 'v1beta1', {\n  // The v1beta1 module is very large. To avoid pulling it in from static\n  // scope, we lazy-load and cache the module.\n  get: function get() {\n    if (!v1beta1) {\n      v1beta1 = require('./v1beta1');\n    }\n\n    return v1beta1;\n  }\n});\n/**\n * {@link v1} factory function.\n *\n * @private\n * @name Firestore.v1\n * @see v1\n * @type {function}\n */\n\nObject.defineProperty(module.exports, 'v1', {\n  // The v1 module is very large. To avoid pulling it in from static\n  // scope, we lazy-load and cache the module.\n  get: function get() {\n    if (!v1) {\n      v1 = require('./v1');\n    }\n\n    return v1;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}