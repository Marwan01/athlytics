{"ast":null,"code":"\"use strict\";\n\nmodule.exports = Type; // extends Namespace\n\nvar Namespace = require(\"./namespace\");\n\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\n\nvar Enum = require(\"./enum\"),\n    OneOf = require(\"./oneof\"),\n    Field = require(\"./field\"),\n    MapField = require(\"./mapfield\"),\n    Service = require(\"./service\"),\n    Message = require(\"./message\"),\n    Reader = require(\"./reader\"),\n    Writer = require(\"./writer\"),\n    util = require(\"./util\"),\n    encoder = require(\"./encoder\"),\n    decoder = require(\"./decoder\"),\n    verifier = require(\"./verifier\"),\n    converter = require(\"./converter\"),\n    wrappers = require(\"./wrappers\");\n/**\r\n * Constructs a new reflected message type instance.\r\n * @classdesc Reflected message type.\r\n * @extends NamespaceBase\r\n * @constructor\r\n * @param {string} name Message name\r\n * @param {Object.<string,*>} [options] Declared options\r\n */\n\n\nfunction Type(name, options) {\n  Namespace.call(this, name, options);\n  /**\r\n   * Message fields.\r\n   * @type {Object.<string,Field>}\r\n   */\n\n  this.fields = {}; // toJSON, marker\n\n  /**\r\n   * Oneofs declared within this namespace, if any.\r\n   * @type {Object.<string,OneOf>}\r\n   */\n\n  this.oneofs = undefined; // toJSON\n\n  /**\r\n   * Extension ranges, if any.\r\n   * @type {number[][]}\r\n   */\n\n  this.extensions = undefined; // toJSON\n\n  /**\r\n   * Reserved ranges, if any.\r\n   * @type {Array.<number[]|string>}\r\n   */\n\n  this.reserved = undefined; // toJSON\n\n  /*?\r\n   * Whether this type is a legacy group.\r\n   * @type {boolean|undefined}\r\n   */\n\n  this.group = undefined; // toJSON\n\n  /**\r\n   * Cached fields by id.\r\n   * @type {Object.<number,Field>|null}\r\n   * @private\r\n   */\n\n  this._fieldsById = null;\n  /**\r\n   * Cached fields as an array.\r\n   * @type {Field[]|null}\r\n   * @private\r\n   */\n\n  this._fieldsArray = null;\n  /**\r\n   * Cached oneofs as an array.\r\n   * @type {OneOf[]|null}\r\n   * @private\r\n   */\n\n  this._oneofsArray = null;\n  /**\r\n   * Cached constructor.\r\n   * @type {Constructor<{}>}\r\n   * @private\r\n   */\n\n  this._ctor = null;\n}\n\nObject.defineProperties(Type.prototype, {\n  /**\r\n   * Message fields by id.\r\n   * @name Type#fieldsById\r\n   * @type {Object.<number,Field>}\r\n   * @readonly\r\n   */\n  fieldsById: {\n    get: function get() {\n      /* istanbul ignore if */\n      if (this._fieldsById) return this._fieldsById;\n      this._fieldsById = {};\n\n      for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {\n        var field = this.fields[names[i]],\n            id = field.id;\n        /* istanbul ignore if */\n\n        if (this._fieldsById[id]) throw Error(\"duplicate id \" + id + \" in \" + this);\n        this._fieldsById[id] = field;\n      }\n\n      return this._fieldsById;\n    }\n  },\n\n  /**\r\n   * Fields of this message as an array for iteration.\r\n   * @name Type#fieldsArray\r\n   * @type {Field[]}\r\n   * @readonly\r\n   */\n  fieldsArray: {\n    get: function get() {\n      return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n    }\n  },\n\n  /**\r\n   * Oneofs of this message as an array for iteration.\r\n   * @name Type#oneofsArray\r\n   * @type {OneOf[]}\r\n   * @readonly\r\n   */\n  oneofsArray: {\n    get: function get() {\n      return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n    }\n  },\n\n  /**\r\n   * The registered constructor, if any registered, otherwise a generic constructor.\r\n   * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\r\n   * @name Type#ctor\r\n   * @type {Constructor<{}>}\r\n   */\n  ctor: {\n    get: function get() {\n      return this._ctor || (this.ctor = Type.generateConstructor(this)());\n    },\n    set: function set(ctor) {\n      // Ensure proper prototype\n      var prototype = ctor.prototype;\n\n      if (!(prototype instanceof Message)) {\n        (ctor.prototype = new Message()).constructor = ctor;\n        util.merge(ctor.prototype, prototype);\n      } // Classes and messages reference their reflected type\n\n\n      ctor.$type = ctor.prototype.$type = this; // Mix in static methods\n\n      util.merge(ctor, Message, true);\n      this._ctor = ctor; // Messages have non-enumerable default values on their prototype\n\n      var i = 0;\n\n      for (; i <\n      /* initializes */\n      this.fieldsArray.length; ++i) {\n        this._fieldsArray[i].resolve();\n      } // ensures a proper value\n      // Messages have non-enumerable getters and setters for each virtual oneof field\n\n\n      var ctorProperties = {};\n\n      for (i = 0; i <\n      /* initializes */\n      this.oneofsArray.length; ++i) {\n        ctorProperties[this._oneofsArray[i].resolve().name] = {\n          get: util.oneOfGetter(this._oneofsArray[i].oneof),\n          set: util.oneOfSetter(this._oneofsArray[i].oneof)\n        };\n      }\n\n      if (i) Object.defineProperties(ctor.prototype, ctorProperties);\n    }\n  }\n});\n/**\r\n * Generates a constructor function for the specified type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\n\nType.generateConstructor = function generateConstructor(mtype) {\n  /* eslint-disable no-unexpected-multiline */\n  var gen = util.codegen([\"p\"], mtype.name); // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n\n  for (var i = 0, field; i < mtype.fieldsArray.length; ++i) {\n    if ((field = mtype._fieldsArray[i]).map) gen(\"this%s={}\", util.safeProp(field.name));else if (field.repeated) gen(\"this%s=[]\", util.safeProp(field.name));\n  }\n\n  return gen(\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n  (\"this[ks[i]]=p[ks[i]]\");\n  /* eslint-enable no-unexpected-multiline */\n};\n\nfunction clearCache(type) {\n  type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n  delete type.encode;\n  delete type.decode;\n  delete type.verify;\n  return type;\n}\n/**\r\n * Message type descriptor.\r\n * @interface IType\r\n * @extends INamespace\r\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\r\n * @property {Object.<string,IField>} fields Field descriptors\r\n * @property {number[][]} [extensions] Extension ranges\r\n * @property {number[][]} [reserved] Reserved ranges\r\n * @property {boolean} [group=false] Whether a legacy group or not\r\n */\n\n/**\r\n * Creates a message type from a message type descriptor.\r\n * @param {string} name Message name\r\n * @param {IType} json Message type descriptor\r\n * @returns {Type} Created message type\r\n */\n\n\nType.fromJSON = function fromJSON(name, json) {\n  var type = new Type(name, json.options);\n  type.extensions = json.extensions;\n  type.reserved = json.reserved;\n  var names = Object.keys(json.fields),\n      i = 0;\n\n  for (; i < names.length; ++i) {\n    type.add((typeof json.fields[names[i]].keyType !== \"undefined\" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));\n  }\n\n  if (json.oneofs) for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i) {\n    type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n  }\n  if (json.nested) for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {\n    var nested = json.nested[names[i]];\n    type.add( // most to least likely\n    (nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));\n  }\n  if (json.extensions && json.extensions.length) type.extensions = json.extensions;\n  if (json.reserved && json.reserved.length) type.reserved = json.reserved;\n  if (json.group) type.group = true;\n  if (json.comment) type.comment = json.comment;\n  return type;\n};\n/**\r\n * Converts this message type to a message type descriptor.\r\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\r\n * @returns {IType} Message type descriptor\r\n */\n\n\nType.prototype.toJSON = function toJSON(toJSONOptions) {\n  var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n  var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n  return util.toObject([\"options\", inherited && inherited.options || undefined, \"oneofs\", Namespace.arrayToJSON(this.oneofsArray, toJSONOptions), \"fields\", Namespace.arrayToJSON(this.fieldsArray.filter(function (obj) {\n    return !obj.declaringField;\n  }), toJSONOptions) || {}, \"extensions\", this.extensions && this.extensions.length ? this.extensions : undefined, \"reserved\", this.reserved && this.reserved.length ? this.reserved : undefined, \"group\", this.group || undefined, \"nested\", inherited && inherited.nested || undefined, \"comment\", keepComments ? this.comment : undefined]);\n};\n/**\r\n * @override\r\n */\n\n\nType.prototype.resolveAll = function resolveAll() {\n  var fields = this.fieldsArray,\n      i = 0;\n\n  while (i < fields.length) {\n    fields[i++].resolve();\n  }\n\n  var oneofs = this.oneofsArray;\n  i = 0;\n\n  while (i < oneofs.length) {\n    oneofs[i++].resolve();\n  }\n\n  return Namespace.prototype.resolveAll.call(this);\n};\n/**\r\n * @override\r\n */\n\n\nType.prototype.get = function get(name) {\n  return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;\n};\n/**\r\n * Adds a nested object to this type.\r\n * @param {ReflectionObject} object Nested object to add\r\n * @returns {Type} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\r\n */\n\n\nType.prototype.add = function add(object) {\n  if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n\n  if (object instanceof Field && object.extend === undefined) {\n    // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n    // The root object takes care of adding distinct sister-fields to the respective extended\n    // type instead.\n    // avoids calling the getter if not absolutely necessary because it's called quite frequently\n    if (this._fieldsById ?\n    /* istanbul ignore next */\n    this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error(\"duplicate id \" + object.id + \" in \" + this);\n    if (this.isReservedId(object.id)) throw Error(\"id \" + object.id + \" is reserved in \" + this);\n    if (this.isReservedName(object.name)) throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n    if (object.parent) object.parent.remove(object);\n    this.fields[object.name] = object;\n    object.message = this;\n    object.onAdd(this);\n    return clearCache(this);\n  }\n\n  if (object instanceof OneOf) {\n    if (!this.oneofs) this.oneofs = {};\n    this.oneofs[object.name] = object;\n    object.onAdd(this);\n    return clearCache(this);\n  }\n\n  return Namespace.prototype.add.call(this, object);\n};\n/**\r\n * Removes a nested object from this type.\r\n * @param {ReflectionObject} object Nested object to remove\r\n * @returns {Type} `this`\r\n * @throws {TypeError} If arguments are invalid\r\n * @throws {Error} If `object` is not a member of this type\r\n */\n\n\nType.prototype.remove = function remove(object) {\n  if (object instanceof Field && object.extend === undefined) {\n    // See Type#add for the reason why extension fields are excluded here.\n\n    /* istanbul ignore if */\n    if (!this.fields || this.fields[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n    delete this.fields[object.name];\n    object.parent = null;\n    object.onRemove(this);\n    return clearCache(this);\n  }\n\n  if (object instanceof OneOf) {\n    /* istanbul ignore if */\n    if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n    delete this.oneofs[object.name];\n    object.parent = null;\n    object.onRemove(this);\n    return clearCache(this);\n  }\n\n  return Namespace.prototype.remove.call(this, object);\n};\n/**\r\n * Tests if the specified id is reserved.\r\n * @param {number} id Id to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\n\n\nType.prototype.isReservedId = function isReservedId(id) {\n  return Namespace.isReservedId(this.reserved, id);\n};\n/**\r\n * Tests if the specified name is reserved.\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\n\n\nType.prototype.isReservedName = function isReservedName(name) {\n  return Namespace.isReservedName(this.reserved, name);\n};\n/**\r\n * Creates a new message of this type using the specified properties.\r\n * @param {Object.<string,*>} [properties] Properties to set\r\n * @returns {Message<{}>} Message instance\r\n */\n\n\nType.prototype.create = function create(properties) {\n  return new this.ctor(properties);\n};\n/**\r\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\r\n * @returns {Type} `this`\r\n */\n\n\nType.prototype.setup = function setup() {\n  // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n  // multiple times (V8, soft-deopt prototype-check).\n  var fullName = this.fullName,\n      types = [];\n\n  for (var i = 0; i <\n  /* initializes */\n  this.fieldsArray.length; ++i) {\n    types.push(this._fieldsArray[i].resolve().resolvedType);\n  } // Replace setup methods with type-specific generated functions\n\n\n  this.encode = encoder(this)({\n    Writer: Writer,\n    types: types,\n    util: util\n  });\n  this.decode = decoder(this)({\n    Reader: Reader,\n    types: types,\n    util: util\n  });\n  this.verify = verifier(this)({\n    types: types,\n    util: util\n  });\n  this.fromObject = converter.fromObject(this)({\n    types: types,\n    util: util\n  });\n  this.toObject = converter.toObject(this)({\n    types: types,\n    util: util\n  }); // Inject custom wrappers for common types\n\n  var wrapper = wrappers[fullName];\n\n  if (wrapper) {\n    var originalThis = Object.create(this); // if (wrapper.fromObject) {\n\n    originalThis.fromObject = this.fromObject;\n    this.fromObject = wrapper.fromObject.bind(originalThis); // }\n    // if (wrapper.toObject) {\n\n    originalThis.toObject = this.toObject;\n    this.toObject = wrapper.toObject.bind(originalThis); // }\n  }\n\n  return this;\n};\n/**\r\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\r\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\r\n * @param {Writer} [writer] Writer to encode to\r\n * @returns {Writer} writer\r\n */\n\n\nType.prototype.encode = function encode_setup(message, writer) {\n  return this.setup().encode(message, writer); // overrides this method\n};\n/**\r\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\r\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\r\n * @param {Writer} [writer] Writer to encode to\r\n * @returns {Writer} writer\r\n */\n\n\nType.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n  return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n/**\r\n * Decodes a message of this type.\r\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\r\n * @param {number} [length] Length of the message, if known beforehand\r\n * @returns {Message<{}>} Decoded message\r\n * @throws {Error} If the payload is not a reader or valid buffer\r\n * @throws {util.ProtocolError<{}>} If required fields are missing\r\n */\n\n\nType.prototype.decode = function decode_setup(reader, length) {\n  return this.setup().decode(reader, length); // overrides this method\n};\n/**\r\n * Decodes a message of this type preceeded by its byte length as a varint.\r\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\r\n * @returns {Message<{}>} Decoded message\r\n * @throws {Error} If the payload is not a reader or valid buffer\r\n * @throws {util.ProtocolError} If required fields are missing\r\n */\n\n\nType.prototype.decodeDelimited = function decodeDelimited(reader) {\n  if (!(reader instanceof Reader)) reader = Reader.create(reader);\n  return this.decode(reader, reader.uint32());\n};\n/**\r\n * Verifies that field values are valid and that required fields are present.\r\n * @param {Object.<string,*>} message Plain object to verify\r\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\r\n */\n\n\nType.prototype.verify = function verify_setup(message) {\n  return this.setup().verify(message); // overrides this method\n};\n/**\r\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\r\n * @param {Object.<string,*>} object Plain object to convert\r\n * @returns {Message<{}>} Message instance\r\n */\n\n\nType.prototype.fromObject = function fromObject(object) {\n  return this.setup().fromObject(object);\n};\n/**\r\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\r\n * @interface IConversionOptions\r\n * @property {Function} [longs] Long conversion type.\r\n * Valid values are `String` and `Number` (the global types).\r\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\r\n * @property {Function} [enums] Enum value conversion type.\r\n * Only valid value is `String` (the global type).\r\n * Defaults to copy the present value, which is the numeric id.\r\n * @property {Function} [bytes] Bytes value conversion type.\r\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\r\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\r\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\r\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\r\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\r\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\r\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\r\n */\n\n/**\r\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\r\n * @param {Message<{}>} message Message instance\r\n * @param {IConversionOptions} [options] Conversion options\r\n * @returns {Object.<string,*>} Plain object\r\n */\n\n\nType.prototype.toObject = function toObject(message, options) {\n  return this.setup().toObject(message, options);\n};\n/**\r\n * Decorator function as returned by {@link Type.d} (TypeScript).\r\n * @typedef TypeDecorator\r\n * @type {function}\r\n * @param {Constructor<T>} target Target constructor\r\n * @returns {undefined}\r\n * @template T extends Message<T>\r\n */\n\n/**\r\n * Type decorator (TypeScript).\r\n * @param {string} [typeName] Type name, defaults to the constructor's name\r\n * @returns {TypeDecorator<T>} Decorator function\r\n * @template T extends Message<T>\r\n */\n\n\nType.d = function decorateType(typeName) {\n  return function typeDecorator(target) {\n    util.decorateType(target, typeName);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}