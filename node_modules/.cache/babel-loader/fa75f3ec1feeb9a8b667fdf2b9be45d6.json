{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar semver = require(\"semver\");\n\nvar call_credentials_1 = require(\"./call-credentials\");\n\nvar channel_credentials_1 = require(\"./channel-credentials\");\n\nvar client_1 = require(\"./client\");\n\nexports.Client = client_1.Client;\n\nvar constants_1 = require(\"./constants\");\n\nexports.logVerbosity = constants_1.LogVerbosity;\nexports.status = constants_1.Status;\n\nvar logging = require(\"./logging\");\n\nvar make_client_1 = require(\"./make-client\");\n\nexports.loadPackageDefinition = make_client_1.loadPackageDefinition;\nexports.makeClientConstructor = make_client_1.makeClientConstructor;\nexports.makeGenericClientConstructor = make_client_1.makeClientConstructor;\n\nvar metadata_1 = require(\"./metadata\");\n\nexports.Metadata = metadata_1.Metadata;\n\nvar status_builder_1 = require(\"./status-builder\");\n\nexports.StatusBuilder = status_builder_1.StatusBuilder;\nvar supportedNodeVersions = '^8.11.2 || >=9.4';\n\nif (!semver.satisfies(process.version, supportedNodeVersions)) {\n  throw new Error(\"@grpc/grpc-js only works on Node \".concat(supportedNodeVersions));\n}\n\nfunction mixin() {\n  var result = {};\n\n  for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n    sources[_key] = arguments[_key];\n  }\n\n  for (var _i = 0; _i < sources.length; _i++) {\n    var source = sources[_i];\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Object.getOwnPropertyNames(source)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var propName = _step.value;\n        var property = source[propName]; // tslint:disable-line no-any\n\n        if (typeof property === 'function') {\n          result[propName] = property;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**** Client Credentials ****/\n// Using assign only copies enumerable properties, which is what we want\n\n\nexports.credentials = mixin({\n  /**\n   * Create a gRPC credential from a Google credential object.\n   * @param googleCredentials The authentication client to use.\n   * @return The resulting CallCredentials object.\n   */\n  createFromGoogleCredential: function createFromGoogleCredential(googleCredentials) {\n    return call_credentials_1.CallCredentials.createFromMetadataGenerator(function (options, callback) {\n      // google-auth-library pre-v2.0.0 does not have getRequestHeaders\n      // but has getRequestMetadata, which is deprecated in v2.0.0\n      var getHeaders;\n\n      if (typeof googleCredentials.getRequestHeaders === 'function') {\n        getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n      } else {\n        getHeaders = new Promise(function (resolve, reject) {\n          googleCredentials.getRequestMetadata(options.service_url, function (err, headers) {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            resolve(headers);\n          });\n        });\n      }\n\n      getHeaders.then(function (headers) {\n        var metadata = new metadata_1.Metadata();\n        metadata.add('authorization', headers.Authorization);\n        callback(null, metadata);\n      }, function (err) {\n        callback(err);\n      });\n    });\n  },\n\n  /**\n   * Combine a ChannelCredentials with any number of CallCredentials into a\n   * single ChannelCredentials object.\n   * @param channelCredentials The ChannelCredentials object.\n   * @param callCredentials Any number of CallCredentials objects.\n   * @return The resulting ChannelCredentials object.\n   */\n  combineChannelCredentials: function combineChannelCredentials(channelCredentials) {\n    for (var _len2 = arguments.length, callCredentials = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      callCredentials[_key2 - 1] = arguments[_key2];\n    }\n\n    return callCredentials.reduce(function (acc, other) {\n      return acc.compose(other);\n    }, channelCredentials);\n  },\n\n  /**\n   * Combine any number of CallCredentials into a single CallCredentials\n   * object.\n   * @param first The first CallCredentials object.\n   * @param additional Any number of additional CallCredentials objects.\n   * @return The resulting CallCredentials object.\n   */\n  combineCallCredentials: function combineCallCredentials(first) {\n    for (var _len3 = arguments.length, additional = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      additional[_key3 - 1] = arguments[_key3];\n    }\n\n    return additional.reduce(function (acc, other) {\n      return acc.compose(other);\n    }, first);\n  }\n}, channel_credentials_1.ChannelCredentials, call_credentials_1.CallCredentials);\n/**\n * Close a Client object.\n * @param client The client to close.\n */\n\nexports.closeClient = function (client) {\n  return client.close();\n};\n\nexports.waitForClientReady = function (client, deadline, callback) {\n  return client.waitForReady(deadline, callback);\n};\n/**** Unimplemented function stubs ****/\n\n/* tslint:disable:no-any variable-name */\n\n\nexports.loadObject = function (value, options) {\n  throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\n\nexports.load = function (filename, format, options) {\n  throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\n\nexports.setLogger = function (logger) {\n  logging.setLogger(logger);\n};\n\nexports.setLogVerbosity = function (verbosity) {\n  logging.setLoggerVerbosity(verbosity);\n};\n\nexports.Server = function (options) {\n  throw new Error('Not yet implemented');\n};\n\nexports.ServerCredentials = {\n  createSsl: function createSsl(rootCerts, keyCertPairs, checkClientCertificate) {\n    throw new Error('Not yet implemented');\n  },\n  createInsecure: function createInsecure() {\n    throw new Error('Not yet implemented');\n  }\n};\n\nexports.getClientChannel = function (client) {\n  return client_1.Client.prototype.getChannel.call(client);\n};\n\nexports.ListenerBuilder = function () {\n  throw new Error('Not yet implemented');\n};\n\nexports.InterceptorBuilder = function () {\n  throw new Error('Not yet implemented');\n};\n\nexports.InterceptingCall = function () {\n  throw new Error('Not yet implemented');\n};","map":null,"metadata":{},"sourceType":"script"}